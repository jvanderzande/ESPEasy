# 1 "c:\\users\\jvdza\\appdata\\local\\temp\\tmp2dxoy1"
#include <Arduino.h>
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"


#ifdef CONTINUOUS_INTEGRATION

#pragma GCC diagnostic error "-Wall"

#else

#pragma GCC diagnostic warning "-Wall"

#endif
# 151 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
#include "ESPEasy-Globals.h"

#include "define_plugin_sets.h"





boolean Blynk_get(const String& command, byte controllerIndex,float *data = NULL );
int firstEnabledBlynkController();
void setup();
void RTOS_TaskServers( void * parameter );
void RTOS_TaskSerial( void * parameter );
void RTOS_Task10ps( void * parameter );
int firstEnabledMQTTController();
bool getControllerProtocolDisplayName(byte ProtocolIndex, byte parameterIdx, String& protoDisplayName);
void loop();
void runPeriodicalMQTT();
void updateMQTTclient_connected();
void run50TimesPerSecond();
void run10TimesPerSecond();
void runOncePerSecond();
void runEach30Seconds();
void checkSensors();
void SensorSendTask(byte TaskIndex);
void setSystemTimer(unsigned long timer, byte plugin, byte Par1, byte Par2, byte Par3);
void setSystemCMDTimer(unsigned long timer, String& action);
void checkSystemTimers();
void backgroundtasks();
Command commandStringToEnum(const char * cmd);
void ExecuteCommand(byte source, const char *Line);
void printDirectory(File dir, int numTabs);
void sendData(struct EventStruct *event);
boolean validUserVar(struct EventStruct *event);
void callback(char* c_topic, byte* b_payload, unsigned int length);
bool MQTTConnect(int controller_idx);
bool MQTTCheck(int controller_idx);
void SendStatus(byte source, String status);
boolean MQTTpublish(int controller_idx, const char* topic, const char* payload, boolean retained);
void MQTTStatus(String& status);
String getBearing(int degrees);
float CelsiusToFahrenheit(float celsius);
int m_secToBeaufort(float m_per_sec);
String centimeterToImperialLength(float cm);
String millimeterToImperialLength(float mm);
float minutesToDay(int minutes);
String minutesToDayHour(int minutes);
String minutesToHourMinute(int minutes);
String minutesToDayHourMinute(int minutes);
String secondsToDayHourMinuteSecond(int seconds);
String format_msec_duration(long duration);
unsigned long float2ul(float f);
float ul2float(unsigned long ul);
void processConnect();
void processDisconnect();
void processGotIP();
void processConnectAPmode();
void processDisconnectAPmode();
void processDisableAPmode();
void processScanDone();
void resetWiFi();
void WifiScanAsync();
bool WifiIsAP(WiFiMode_t wifimode);
bool WifiIsSTA(WiFiMode_t wifimode);
void setSTA(bool enable);
void setAP(bool enable);
void setWifiMode(WiFiMode_t wifimode);
String WifiGetAPssid();
String WifiGetHostname();
bool useStaticIP();
bool WiFiConnected();
void WiFiConnectRelaxed();
bool prepareWiFi();
const char* getLastWiFiSettingsSSID();
const char* getLastWiFiSettingsPassphrase();
bool selectNextWiFiSettings();
bool selectValidWiFiSettings();
bool wifiSettingsValid(const char* ssid, const char* pass);
bool wifiConnectTimeoutReached();
void setupStaticIPconfig();
bool tryConnectWiFi();
void WifiDisconnect();
void WifiScan();
String formatScanResult(int i, const String& separator);
String SDKwifiStatusToString(uint8_t sdk_wifistatus);
String ArduinoWifiStatusToString(uint8_t arduino_corelib_wifistatus);
String ESPeasyWifiStatusToString();
void logConnectionStatus();
void WifiCheck();
bool getSubnetRange(IPAddress& low, IPAddress& high);
String getLastDisconnectReason();
void hardwareInit();
void checkResetFactoryPin();
void tcpCleanup();
bool isDeepSleepEnabled();
bool readyForSleep();
void deepSleep(int delay);
void deepSleepStart(int delay);
boolean remoteConfig(struct EventStruct *event, String& string);
int8_t getTaskIndexByName(String TaskNameSearch);
void flashCount();
String flashGuard();
void setPinState(byte plugin, byte index, byte mode, uint16_t value);
boolean getPinState(byte plugin, byte index, byte *mode, uint16_t *value);
boolean hasPinState(byte plugin, byte index);
String getPinStateJSON(boolean search, byte plugin, byte index, String& log, uint16_t noSearchValue);
void statusLED(boolean traffic);
void delayBackground(unsigned long delay);
void parseCommandString(struct EventStruct *event, const String& string);
void taskClear(byte taskIndex, boolean save);
String FileError(int line, const char * fname);
String BuildFixes();
void fileSystemCheck();
byte getDeviceIndex(byte Number);
String getPluginNameFromDeviceIndex(byte deviceIndex);
byte getProtocolIndex(byte Number);
byte getNotificationProtocolIndex(byte Number);
boolean GetArgv(const char *string, char *argv, unsigned int argc);
void dump (uint32_t addr);
uint32_t progMemMD5check();
String SaveSettings(void);
String LoadSettings();
String SaveTaskSettings(byte TaskIndex);
String LoadTaskSettings(byte TaskIndex);
String SaveCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize);
String ClearCustomTaskSettings(int TaskIndex);
String LoadCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize);
String SaveControllerSettings(int ControllerIndex, byte* memAddress, int datasize);
String LoadControllerSettings(int ControllerIndex, byte* memAddress, int datasize);
String ClearCustomControllerSettings(int ControllerIndex);
String SaveCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize);
String LoadCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize);
String SaveNotificationSettings(int NotificationIndex, byte* memAddress, int datasize);
String LoadNotificationSettings(int NotificationIndex, byte* memAddress, int datasize);
String InitFile(const char* fname, int datasize);
String SaveToFile(char* fname, int index, byte* memAddress, int datasize);
String ClearInFile(char* fname, int index, int datasize);
String LoadFromFile(char* fname, int index, byte* memAddress, int datasize);
int SpiffsSectors();
void ResetFactory(void);
void emergencyReset();
unsigned long FreeMem(void);
String getLastBootCauseString();
String getSystemBuildString();
String getPluginDescriptionString();
String getSystemLibraryString();
String getLWIPversion();
boolean isFloat(const String& tBuf);
boolean isValidFloat(float f);
boolean isInt(const String& tBuf);
boolean isNumerical(const String& tBuf, bool mustBeInteger);
float timeStringToSeconds(String tBuf);
void initLog();
String getLogLevelDisplayString(byte index, int& logLevel);
void addLog(byte loglevel, String& string);
void addLog(byte logLevel, const __FlashStringHelper* flashString);
bool SerialAvailableForWrite();
boolean loglevelActiveFor(byte destination, byte logLevel);
boolean loglevelActive(byte logLevel, byte logLevelSettings);
void addLog(byte logLevel, const char *line);
void delayedReboot(int rebootDelay);
boolean saveToRTC();
void initRTC();
boolean readFromRTC();
boolean saveUserVarToRTC();
boolean readUserVarFromRTC();
uint32_t getChecksum(byte* buffer, size_t size);
String parseTemplate(String &tmpString, byte lineSize);
int push(float value);
float pop();
float apply_operator(char op, float first, float second);
int RPNCalculate(char* token);
int op_preced(const char c);
bool op_left_assoc(const char c);
unsigned int op_arg_count(const char c);
int Calculate(const char *input, float* result);
void checkRuleSets();
void rulesProcessing(String& event);
String rulesProcessingFile(String fileName, String& event);
boolean ruleMatch(String& event, String& rule);
boolean conditionMatchExtended(String& check);
boolean conditionMatch(const String& check);
void rulesTimers();
void createRuleEvents(byte TaskIndex);
void SendValueLogger(byte TaskIndex);
void checkRAMtoLog(void);
void checkRAM(const __FlashStringHelper* flashString, int a );
void checkRAM(const __FlashStringHelper* flashString, String &a );
void checkRAM(String &flashString, String &a );
void checkRAM( const __FlashStringHelper* flashString);
void checkRAM( String &a );
void tone(uint8_t _pin, unsigned int frequency, unsigned long duration);
void play_rtttl(uint8_t _pin, const char *p );
void ArduinoOTAInit();
float compute_dew_point_temp(float temperature, float humidity_percentage);
float compute_humidity_from_dewpoint(float temperature, float dew_temperature);
void syslog(byte logLevel, const char *message);
void checkUDP();
void SendUDPCommand(byte destUnit, char* data, byte dataLength);
void sendUDP(byte unit, byte* data, byte size);
void refreshNodeList();
void sendSysInfoUDP(byte repeats);
void SSDP_schema(WiFiClient &client);
bool SSDP_begin();
void SSDP_send(byte method);
void SSDP_update();
bool WiFiConnected(uint32_t timeout_ms);
bool hostReachable(const IPAddress& ip);
bool hostReachable(const String& hostname);
void serial();
unsigned long str2int(char *string);
bool string2float(const String& string, float& floatvalue);
boolean str2ip(const String& string, byte* IP);
boolean str2ip(const char *string, byte* IP);
String formatIP(const IPAddress& ip);
String formatMAC(const uint8_t* mac);
String toString(float value, byte decimals);
String doFormatUserVar(byte TaskIndex, byte rel_index, bool mustCheck, bool& isvalid);
String formatUserVarNoCheck(byte TaskIndex, byte rel_index);
String formatUserVar(byte TaskIndex, byte rel_index, bool& isvalid);
String formatUserVarNoCheck(struct EventStruct *event, byte rel_index);
String formatUserVar(struct EventStruct *event, byte rel_index, bool& isvalid);
String wrap_String(const String& string, const String& wrap);
String to_json_object_value(const String& object, const String& value);
String parseString(String& string, byte indexFind);
int getParamStartPos(String& string, byte indexFind);
void htmlEscape(String & html);
void parseControllerVariables(String& s, struct EventStruct *event, boolean useURLencode);
void repl(const String& key, const String& val, String& s, boolean useURLencode);
void parseSpecialCharacters(String& s, boolean useURLencode);
void parseSystemVariables(String& s, boolean useURLencode);
void parseEventVariables(String& s, struct EventStruct *event, boolean useURLencode);
bool getConvertArgument(const String& marker, const String& s, float& argument, int& startIndex, int& endIndex);
void parseStandardConversions(String& s, boolean useURLencode);
void breakTime(unsigned long timeInput, struct timeStruct &tm);
void setTime(unsigned long t);
uint32_t getUnixTime();
unsigned long now();
int year(unsigned long t);
int weekday(unsigned long t);
int year();
byte month();
byte day();
byte hour();
byte minute();
byte second();
int weekday();
String weekday_str();
void initTime();
void checkTime();
unsigned long getNtpTime();
long timeDiff(const unsigned long prev, const unsigned long next);
long timePassedSince(unsigned long timestamp);
boolean timeOutReached(unsigned long timer);
void setNextTimeInterval(unsigned long& timer, const unsigned long step);
String timeLong2String(unsigned long lngTime);
String getDateString(const timeStruct& ts, char delimiter);
String getDateString(char delimiter);
String getDateString();
String getTimeString(const timeStruct& ts, char delimiter, bool am_pm, bool show_seconds);
String getTimeString(char delimiter, bool show_seconds );
String getTimeString_ampm(char delimiter, bool show_seconds );
String getTimeString();
String getTimeString_ampm();
String getDateTimeString(const timeStruct& ts, char dateDelimiter, char timeDelimiter, char dateTimeDelimiter, bool am_pm);
String getDateTimeString(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter);
String getDateTimeString_ampm(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter);
unsigned long string2TimeLong(const String &str);
boolean matchClockEvent(unsigned long clockEvent, unsigned long clockSet);
void getDefaultDst_flash_values(uint16_t& start, uint16_t& end);
void applyTimeZone(uint32_t curTime);
void setTimeZone(const TimeChangeRule& dstStart, const TimeChangeRule& stdStart, uint32_t curTime);
void logTimeZoneInfo();
uint32_t makeTime(const timeStruct &tm);
uint32_t calcTimeChangeForRule(const TimeChangeRule& r, int yr);
bool calcTimeChanges(int yr);
uint32_t toLocal(uint32_t utc);
bool utcIsDST(uint32_t utc);
bool locIsDST(uint32_t local);
void sendContentBlocking(String& data);
void sendHeaderBlocking(bool json);
boolean ipLessEqual(const IPAddress& ip, const IPAddress& high);
boolean ipInRange(const IPAddress& ip, const IPAddress& low, const IPAddress& high);
String describeAllowedIPrange();
bool getIPallowedRange(IPAddress& low, IPAddress& high);
boolean clientIPallowed();
void clearAccessBlock();
void addHtmlError(String error);
void addHtml(const String html);
void WebServerInit();
void setWebserverRunning(bool state);
void getWebPageTemplateDefault(const String& tmplName, String& tmpl);
void getErrorNotifications();
void getWebPageTemplateVar(const String& varName );
void writeDefaultCSS(void);
void addHeader(boolean showMenu, String& str);
void addFooter(String& str);
void handle_root();
void handle_config();
void handle_controllers();
void handle_notifications();
void handle_hardware();
void addFormPinStateSelect(const String& label, const String& id, int choice);
void addPinStateSelect(String name, int choice);
void addFormIPaccessControlSelect(const String& label, const String& id, int choice);
void addIPaccessControlSelect(String name, int choice);
void handle_devices();
void addDeviceSelect(String name, int choice);
void switchArray(byte value);
boolean arrayLessThan(const String& ptr_1, const String& ptr_2);
void sortDeviceArray();
void addFormPinSelect(const String& label, const String& id, int choice);
void addFormPinSelectI2C(const String& label, const String& id, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void renderHTMLForPinSelect(String options[], int optionValues[], boolean forI2C, String name, int choice, int count);
void addFormSelectorI2C(const String& id, int addressCount, const int addresses[], int selectedIndex);
void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], int selectedIndex);
void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange);
void addSelector(const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange);
void addSelector_Head(const String& id, boolean reloadonchange);
void addSelector_Item(const String& option, int index, boolean selected, boolean disabled, const String& attr);
void addSelector_Foot();
void addUnit(const String& unit);
void addRowLabel(const String& label);
void addButton(const String &url, const String &label);
void addSubmitButton();
void addSubmitButton(const String &value, const String &name);
void addCopyButton(const String &value, const String &delimiter, const String &name);
void addFormHeader(const String& header1, const String& header2);
void addFormHeader(const String& header);
void addFormSubHeader(const String& header);
void addFormNote(const String& text);
void addFormSeparator(int clspan);
void addCheckBox(const String& id, boolean checked);
void addFormCheckBox(const String& label, const String& id, boolean checked);
void addNumericBox(const String& id, int value, int min, int max);
void addNumericBox(const String& id, int value);
void addFormNumericBox(const String& label, const String& id, int value, int min, int max);
void addFormNumericBox(const String& label, const String& id, int value);
void addTextBox(const String& id, const String& value, int maxlength);
void addFormTextBox(const String& label, const String& id, const String& value, int maxlength);
void addFormPasswordBox(const String& label, const String& id, const String& password, int maxlength);
void copyFormPassword(const String& id, char* pPassword, int maxlength);
void addFormIPBox(const String& label, const String& id, const byte ip[4]);
void addHelpButton(const String& url);
void addEnabled(boolean enabled);
void addTaskSelect(String name, int choice);
bool isFormItemChecked(const String& id);
int getFormItemInt(const String& id);
float getFormItemFloat(const String& id);
bool isFormItem(const String& id);
void addTaskValueSelect(String name, int choice, byte TaskIndex);
void handle_log();
void handle_log_JSON();
void handle_tools();
void handle_pinstates();
void handle_i2cscanner();
void handle_wifiscanner();
void handle_login();
void handle_control();
void stream_to_json_object_value(const String& object, const String& value);
String jsonBool(bool value);
void stream_next_json_object_value(const String& object, const String& value);
void stream_last_json_object_value(const String& object, const String& value);
void handle_json();
void handle_advanced();
void addFormDstSelect(bool isStart, uint16_t choice);
void addFormLogLevelSelect(const String& label, const String& id, int choice);
void addLogLevelSelect(String name, int choice);
void addFormLogFacilitySelect(const String& label, const String& id, int choice);
void addLogFacilitySelect(String name, int choice);
boolean isLoggedIn();
void handle_download();
void handle_upload();
void handle_upload_post();
void handleFileUpload();
bool loadFromFS(boolean spiffs, String path);
boolean handle_custom(String path);
void handle_filelist();
void handle_SDfilelist();
void handleNotFound();
void handle_setup();
void handle_rules();
void handle_sysinfo();
String URLEncode(const char* msg);
String getControllerSymbol(byte index);
String getValueSymbol(byte index);
void handle_favicon();
boolean CPlugin_001(byte function, struct EventStruct *event, String& string);
boolean CPlugin_002(byte function, struct EventStruct *event, String& string);
boolean CPlugin_003(byte function, struct EventStruct *event, String& string);
boolean CPlugin_004(byte function, struct EventStruct *event, String& string);
boolean CPlugin_005(byte function, struct EventStruct *event, String& string);
boolean CPlugin_006(byte function, struct EventStruct *event, String& string);
boolean CPlugin_007(byte function, struct EventStruct *event, String& string);
boolean CPlugin_008(byte function, struct EventStruct *event, String& string);
boolean HTTPSend(struct EventStruct *event, byte varIndex, const String& formattedValue);
boolean CPlugin_009(byte function, struct EventStruct *event, String& string);
void FHEMHTTPsend(String & url, String & buffer, byte index);
boolean CPlugin_010(byte function, struct EventStruct *event, String& string);
void C010_Send(struct EventStruct *event, byte varIndex, const String& formattedValue);
boolean CPlugin_011(byte function, struct EventStruct *event, String& string);
boolean HTTPSend011(struct EventStruct *event);
void DeleteNotNeededValues(String &s, byte numberOfValuesWanted);
void ReplaceTokenByValue(String& s, struct EventStruct *event);
boolean CPlugin_012(byte function, struct EventStruct *event, String& string);
boolean CPlugin_012_send(struct EventStruct *event, int nrValues);
boolean Blynk_get(const String& command, byte controllerIndex, float *data );
boolean CPlugin_013(byte function, struct EventStruct *event, String& string);
void C013_Send(struct EventStruct *event, byte varIndex, float value, unsigned long longValue);
void C013_SendUDPTaskInfo(byte destUnit, byte sourceTaskIndex, byte destTaskIndex);
void C013_SendUDPTaskData(byte destUnit, byte sourceTaskIndex, byte destTaskIndex);
void C013_sendUDP(byte unit, byte* data, byte size);
void C013_Receive(struct EventStruct *event);
String humStatDomoticz(struct EventStruct *event, byte rel_index);
int mapRSSItoDomoticz();
int mapVccToDomoticz();
String formatUserVarDomoticz(struct EventStruct *event, byte rel_index);
String formatUserVarDomoticz(int value);
String formatDomoticzSensorType(struct EventStruct *event);
byte getValueCountFromSensorType(byte sensorType);
boolean NPlugin_001(byte function, struct EventStruct *event, String& string);
boolean NPlugin_001_send(const NotificationSettingsStruct& notificationsettings, const String& aSub, String& aMesg);
boolean NPlugin_001_Auth(WiFiClient& client, String user, String pass);
boolean NPlugin_001_MTA(WiFiClient& client, String aStr, const String &aWaitForPattern);
boolean NPlugin_002(byte function, struct EventStruct *event, String& string);
boolean Plugin_001_read_switch_state(struct EventStruct *event);
boolean Plugin_001(byte function, struct EventStruct *event, String& string);
void analogWriteESP32(int pin, int value);
byte P001_getSwitchType(struct EventStruct *event);
boolean Plugin_002(byte function, struct EventStruct *event, String& string);
boolean Plugin_003(byte function, struct EventStruct *event, String& string);
void Plugin_003_pulsecheck(byte Index);
void Plugin_003_pulse_interrupt1();
void Plugin_003_pulse_interrupt2();
void Plugin_003_pulse_interrupt3();
void Plugin_003_pulse_interrupt4();
void Plugin_003_pulse_interrupt5();
void Plugin_003_pulse_interrupt6();
void Plugin_003_pulse_interrupt7();
void Plugin_003_pulse_interrupt8();
bool Plugin_003_pulseinit(byte Par1, byte Index, byte Mode);
boolean Plugin_004(byte function, struct EventStruct * event, String& string);
void Plugin_004_get_addr(uint8_t addr[], byte TaskIndex);
byte Plugin_004_DS_scan(byte getDeviceROM, uint8_t* ROM);
void Plugin_004_DS_startConvertion(uint8_t ROM[8]);
boolean Plugin_004_DS_readTemp(uint8_t ROM[8], float * value);
int Plugin_004_DS_getResolution(uint8_t ROM[8]);
boolean Plugin_004_DS_setResolution(uint8_t ROM[8], byte res);
uint8_t Plugin_004_DS_reset();
void Plugin_004_DS_reset_search();
uint8_t Plugin_004_DS_search(uint8_t * newAddr);
uint8_t Plugin_004_DS_read(void);
void Plugin_004_DS_write(uint8_t ByteToWrite);
uint8_t Plugin_004_DS_read_bit(void);
void Plugin_004_DS_write_bit(uint8_t v);
boolean Plugin_004_DS_crc8(uint8_t * addr);
boolean Plugin_005(byte function, struct EventStruct *event, String& string);
void logError(struct EventStruct *event, String text);
boolean waitState(int state);
int Plugin_005_read_dht_dat(void);
boolean Plugin_006(byte function, struct EventStruct *event, String& string);
boolean Plugin_006_bmp085_begin();
uint16_t Plugin_006_bmp085_readRawTemperature(void);
uint32_t Plugin_006_bmp085_readRawPressure(void);
int32_t Plugin_006_bmp085_readPressure(void);
float Plugin_006_bmp085_readTemperature(void);
uint8_t Plugin_006_bmp085_read8(uint8_t a);
uint16_t Plugin_006_bmp085_read16(uint8_t a);
boolean Plugin_006_bmp085_write8(uint8_t a, uint8_t d);
float Plugin_006_pressureElevation(float atmospheric, int altitude);
boolean Plugin_007(byte function, struct EventStruct *event, String& string);
boolean Plugin_008(byte function, struct EventStruct *event, String& string);
void Plugin_008_interrupt1();
void Plugin_008_interrupt2();
boolean Plugin_009(byte function, struct EventStruct *event, String& string);
int Plugin_009_Read(byte Par1);
boolean Plugin_009_Write(byte Par1, byte Par2);
void Plugin_009_Config(byte Par1, byte Par2);
boolean Plugin_010(byte function, struct EventStruct *event, String& string);
boolean Plugin_011(byte function, struct EventStruct *event, String& string);
int Plugin_011_Read(byte Par1, byte Par2);
void Plugin_011_Write(byte Par1, byte Par2);
boolean Plugin_012(byte function, struct EventStruct *event, String& string);
String P012_parseTemplate(String &tmpString, byte lineSize);
boolean Plugin_013(byte function, struct EventStruct *event, String& string);
float Plugin_013_read();
boolean Plugin_014(byte function, struct EventStruct *event, String& string);
boolean Plugin_014_si7021_begin(uint8_t resolution);
uint8_t Plugin_014_si7021_checkCRC(uint16_t data, uint8_t check);
int8_t Plugin_014_si7021_readRegister(uint8_t * value);
int8_t Plugin_014_si7021_startConv(uint8_t datatype, uint8_t resolution);
int8_t Plugin_014_si7021_readValues(uint8_t resolution);
int8_t Plugin_014_si7021_setResolution(uint8_t res);
boolean plugin_015_begin();
boolean plugin_015_setPowerUp(void);
boolean plugin_015_setPowerDown(void);
boolean Plugin_015(byte function, struct EventStruct *event, String& string);
boolean Plugin_016(byte function, struct EventStruct *event, String& string);
boolean Plugin_017(byte function, struct EventStruct *event, String& string);
boolean Plugin_017_Init(int8_t resetPin);
uint32_t getFirmwareVersion(void);
byte Plugin_017_readPassiveTargetID(uint8_t cardbaudrate, uint8_t *uid, uint8_t *uidLength);
int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen);
int16_t Plugin_017_readResponse(uint8_t buf[], uint8_t len);
int8_t Plugin_017_readAckFrame();
boolean Plugin_018(byte function, struct EventStruct *event, String& string);
boolean Plugin_019(byte function, struct EventStruct *event, String& string);
int Plugin_019_Read(byte Par1);
boolean Plugin_019_Write(byte Par1, byte Par2);
boolean Plugin_020(byte function, struct EventStruct *event, String& string);
boolean Plugin_021(byte function, struct EventStruct *event, String& string);
boolean Plugin_022(byte function, struct EventStruct *event, String& string);
void Plugin_022_writeRegister(int regAddress, byte data);
uint8_t Plugin_022_readRegister(int regAddress);
void Plugin_022_Write(byte Par1, int Par2);
void Plugin_022_Frequency(uint16_t freq);
void Plugin_022_initialize();
boolean Plugin_023(byte function, struct EventStruct *event, String& string);
String P023_parseTemplate(String &tmpString, byte lineSize);
void Plugin_023_reset_display(void);
void Plugin_023_StartUp_OLED();
void Plugin_023_displayOn(void);
void Plugin_023_displayOff(void);
void Plugin_023_clear_display(void);
void Plugin_023_SendChar(unsigned char data);
void Plugin_023_sendcommand(unsigned char com);
void Plugin_023_setXY(unsigned char row, unsigned char col);
void Plugin_023_sendStrXY(const char *string, int X, int Y);
void Plugin_023_init_OLED(void);
uint16_t readRegister024(uint8_t i2cAddress, uint8_t reg);
float readTemp024(uint8_t i2c_addr, uint8_t i2c_reg);
boolean Plugin_024(byte function, struct EventStruct *event, String& string);
uint16_t readRegister025(uint8_t i2cAddress, uint8_t reg);
boolean Plugin_025(byte function, struct EventStruct *event, String& string);
boolean Plugin_026(byte function, struct EventStruct *event, String& string);
uint8_t Plugin_027_i2c_addr(struct EventStruct *event);
uint8_t Plugin_027_device_index(const uint8_t i2caddr);
boolean Plugin_027(byte function, struct EventStruct *event, String& string);
void Plugin_027_wireWriteRegister (uint8_t i2caddr, uint8_t reg, uint16_t value);
void Plugin_027_wireReadRegister(uint8_t i2caddr, uint8_t reg, uint16_t *value);
void Plugin_027_setCalibration_32V_2A(uint8_t i2caddr);
void Plugin_027_setCalibration_32V_1A(uint8_t i2caddr);
void Plugin_027_setCalibration_16V_400mA(uint8_t i2caddr);
int16_t Plugin_027_getBusVoltage_raw(uint8_t i2caddr);
int16_t Plugin_027_getShuntVoltage_raw(uint8_t i2caddr);
int16_t Plugin_027_getCurrent_raw(uint8_t i2caddr);
float Plugin_027_getShuntVoltage_mV(uint8_t i2caddr);
float Plugin_027_getBusVoltage_V(uint8_t i2caddr);
float Plugin_027_getCurrent_mA(uint8_t i2caddr);
byte Plugin_028_get_config_settings();
byte Plugin_028_get_control_settings();
String Plugin_028_getFullDeviceName();
String Plugin_028_getDeviceName();
boolean Plugin_028_hasHumidity();
uint8_t Plugin_028_i2c_addr(struct EventStruct *event);
uint8_t Plugin_028_device_index(const uint8_t i2cAddress);
boolean Plugin_028(byte function, struct EventStruct *event, String& string);
bool Plugin_028_update_measurements(uint8_t i2cAddress, float tempOffset);
bool Plugin_028_check(uint8_t a);
bool Plugin_028_begin(uint8_t a);
void Plugin_028_write8(byte reg, byte value);
uint8_t Plugin_028_read8(byte reg, bool * is_ok);
uint16_t Plugin_028_read16(byte reg);
int32_t Plugin_028_read24(byte reg);
uint16_t Plugin_028_read16_LE(byte reg);
int16_t Plugin_028_readS16(byte reg);
int16_t Plugin_028_readS16_LE(byte reg);
void Plugin_028_readCoefficients(uint8_t i2cAddress);
float Plugin_028_readTemperature(uint8_t i2cAddress);
float Plugin_028_readPressure(uint8_t i2cAddress);
float Plugin_028_readHumidity(uint8_t i2cAddress);
float Plugin_028_readAltitude(float seaLevel);
float Plugin_028_pressureElevation(float atmospheric, int altitude);
boolean Plugin_029(byte function, struct EventStruct *event, String& string);
boolean Plugin_030(byte function, struct EventStruct *event, String& string);
bool Plugin_030_check(uint8_t a);
bool Plugin_030_begin(uint8_t a);
void Plugin_030_write8(byte reg, byte value);
uint8_t Plugin_030_read8(byte reg, bool * is_ok);
uint16_t Plugin_030_read16(byte reg);
int32_t Plugin_030_read24(byte reg);
uint16_t Plugin_030_read16_LE(byte reg);
int16_t Plugin_030_readS16(byte reg);
int16_t Plugin_030_readS16_LE(byte reg);
void Plugin_030_readCoefficients(uint8_t idx);
float Plugin_030_readTemperature(uint8_t idx);
float Plugin_030_readPressure(uint8_t idx);
float Plugin_030_readAltitude(float seaLevel);
float Plugin_030_pressureElevation(float atmospheric, int altitude);
boolean Plugin_031(byte function, struct EventStruct *event, String& string);
float Plugin_031_readTemperature();
float Plugin_031_readRelHumidity(float tempC);
void Plugin_031_reset();
byte Plugin_031_readStatus();
void Plugin_031_sendCommand(const byte cmd);
void Plugin_031_awaitResult();
int Plugin_031_readData(const int bits);
boolean Plugin_032(byte function, struct EventStruct *event, String& string);
bool Plugin_032_begin(uint8_t a);
byte Plugin_032_send_cmd(byte aCMD);
void Plugin_032_read_prom();
unsigned long Plugin_032_read_adc(unsigned char aCMD);
void Plugin_032_readout();
double Plugin_032_pressureElevation(double atmospheric, int altitude);
boolean Plugin_033(byte function, struct EventStruct *event, String& string);
boolean Plugin_034(byte function, struct EventStruct *event, String& string);
boolean Plugin_035(byte function, struct EventStruct *event, String& string);
boolean Plugin_036(byte function, struct EventStruct *event, String& string);
void P36_setContrast(uint8_t OLED_contrast);
String P36_parseTemplate(String &tmpString, byte lineSize);
void display_header();
void display_time();
void display_title(String& title);
void display_logo();
void display_indicator(int iframe, int frameCount);
void display_scroll(String outString[], String inString[], int nlines, int scrollspeed);
bool display_wifibars();
void Plugin_037_update_connect_status();
boolean Plugin_037(byte function, struct EventStruct *event, String& string);
boolean MQTTSubscribe_037();
void mqttcallback_037(char* c_topic, byte* b_payload, unsigned int length);
boolean MQTTConnect_037(String clientid);
boolean MQTTCheckSubscription_037(String Topic, String Subscription);
boolean Plugin_038(byte function, struct EventStruct *event, String& string);
boolean Plugin_039(byte function, struct EventStruct *event, String& string);
double readMax6675();
double readMax31855();
int Plugin_039_convert_two_complement(uint32_t value, int nr_bits);
boolean Plugin_040(byte function, struct EventStruct *event, String& string);
boolean Plugin_041(byte function, struct EventStruct *event, String& string);
void Plugin_041_update();
void resetAndBlack();
void pushToStrip(int ledId);
void timeToStrip(uint8_t hours, uint8_t minutes);
void pushM_ONE();
void pushM_TWO();
void pushM_THREE();
void pushM_FOUR();
void pushIT_IS();
void pushAFTER();
void pushQUATER();
void pushFOR();
void pushHALF();
void pushONE();
void pushTWO();
void pushTHREE();
void pushFOUR();
void pushFIVE1();
void pushFIVE2();
void pushSIX();
void pushSEVEN();
void pushEIGHT();
void pushNINE();
void pushTEN();
void pushTEN1();
void pushELEVEN();
void pushTWELVE();
void pushTWENTY();
void pushHOURE();
boolean Plugin_042(byte function, struct EventStruct *event, String& string);
void SetPixelsBlack();
void SetPixelToColor(int PixelIdx);
void type_Off();
void type_Static_Light();
void type_Simple_Candle();
void type_Advanced_Candle();
void type_Police();
void type_BlinkStrobe();
void type_ColorFader();
void HSVtoRGB(int hue, int sat, int val, int colors[3]);
void RGBtoHSV(byte r, byte g, byte b, double hsv[3]);
boolean Plugin_043(byte function, struct EventStruct *event, String& string);
boolean Plugin_044(byte function, struct EventStruct *event, String& string);
void blinkLED();
bool validP1char(char ch);
int FindCharInArrayRev(char array[], char c, int len);
unsigned int CRC16(unsigned int crc, unsigned char *buf, int len);
bool checkDatagram(int len);
boolean Plugin_045(byte function, struct EventStruct *event, String& string);
void _P045_trackMinMax(int16_t current, int16_t *min, int16_t *max);
void _P045_getMotion6(uint8_t devAddr, int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz);
void _P045_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data);
boolean Plugin_046(byte function, struct EventStruct *event, String& string);
void Plugin_046_ISR_nSEL();
void Plugin_046_ISR_SCLK();
boolean Plugin_047(byte function, struct EventStruct *event, String& string);
void Plugin_047_write8(byte value);
void Plugin_047_write8(int reg, int value);
uint8_t Plugin_047_read8(byte reg);
uint16_t Plugin_047_read16(byte reg);
int16_t Plugin_047_readS16(byte reg);
float Plugin_047_readTemperature();
float Plugin_047_readLight();
unsigned int Plugin_047_readMoisture();
uint8_t Plugin_047_getVersion();
bool Plugin_047_setAddress(int addr);
boolean Plugin_048(byte function, struct EventStruct *event, String& string);
boolean Plugin_049_Check_and_ApplyFilter(unsigned int prevVal, unsigned int &newVal, uint32_t s, const int filterValue, String& log);
boolean Plugin_049(byte function, struct EventStruct *event, String& string);
byte _P049_calculateChecksum(byte *array);
size_t _P049_send_mhzCmd(byte CommandId);
boolean Plugin_050(byte function, struct EventStruct *event, String& string);
boolean Plugin_051(byte function, struct EventStruct *event, String& string);
boolean Plugin_052(byte function, struct EventStruct *event, String& string);
void Plugin_052_buildFrame(byte slaveAddress,
              byte functionCode,
              short startAddress,
              short numberOfRegisters,
              byte frame[8]);
int Plugin_052_sendCommand(byte command[]);
int Plugin_052_readErrorStatus(void);
int Plugin_052_readCo2(void);
float Plugin_052_readTemperature(void);
float Plugin_052_readRelativeHumidity(void);
int Plugin_052_readRelayStatus(void);
int Plugin_052_readTemperatureAdjustment(void);
void Plugin_052_setRelayStatus(int status);
int Plugin_052_readABCperiod(void);
unsigned int Plugin_052_ModRTU_CRC(byte buf[], int len, byte checkSum[2]);
int getBitOfInt(int reg, int pos);
void SerialRead16(uint16_t* value, uint16_t* checksum);
void SerialFlush();
boolean PacketAvailable(void);
boolean Plugin_053_process_data(struct EventStruct *event);
boolean Plugin_053(byte function, struct EventStruct *event, String& string);
boolean Plugin_054(byte function, struct EventStruct *event, String& string);
boolean Plugin_055(byte function, struct EventStruct *event, String& string);
void Plugin_055_WriteFIFO(char c);
char Plugin_055_ReadFIFO();
char Plugin_055_PeekFIFO();
boolean Plugin_055_IsEmptyFIFO();
void Plugin_055_AddStringFIFO(const String& param);
void Plugin_055_WriteChime(const String& name, const String& tokens);
byte Plugin_055_ReadChime(const String& name, String& tokens);
boolean Plugin_056(byte function, struct EventStruct *event, String& string);
boolean Plugin_056_hasTxPin(struct EventStruct *event);
String Plugin_056_ErrorToString(int error);
String Plugin_056_WorkingPeriodToString(int workingPeriod);
void Plugin_056_setWorkingPeriod(int minutes);
boolean Plugin_057(byte function, struct EventStruct *event, String& string);
boolean Plugin_058(byte function, struct EventStruct *event, String& string);
boolean Plugin_059(byte function, struct EventStruct *event, String& string);
uint16_t readMCP3221(byte addr);
boolean Plugin_060(byte function, struct EventStruct *event, String& string);
boolean Plugin_061(byte function, struct EventStruct *event, String& string);
void MCP23017_setReg(byte addr, byte reg, byte data);
byte MCP23017_getReg(byte addr, byte reg);
void MCP23017_KeyPadMatrixInit(byte addr);
byte MCP23017_KeyPadMatrixScan(byte addr);
void PCF8574_setReg(byte addr, byte data);
byte PCF8574_getReg(byte addr);
void PCF8574_KeyPadMatrixInit(byte addr);
byte PCF8574_KeyPadMatrixScan(byte addr);
void PCF8574_KeyPadDirectInit(byte addr);
byte PCF8574_KeyPadDirectScan(byte addr);
boolean Plugin_062(byte function, struct EventStruct *event, String& string);
uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO);
boolean Plugin_063(byte function, struct EventStruct *event, String& string);
boolean Plugin_064(byte function, struct EventStruct *event, String& string);
boolean Plugin_065(byte function, struct EventStruct *event, String& string);
void Plugin_065_Play(uint16_t track);
void Plugin_065_SetVol(int8_t vol);
void Plugin_065_SetEQ(int8_t eq);
void Plugin_065_SendCmd(byte cmd, int16_t data);
boolean Plugin_066(byte function, struct EventStruct *event, String& string);
void VEML6040_setControlReg(byte data);
float VEML6040_GetValue(byte reg);
void VEML6040_Init(byte it);
float Plugin_066_CalcCCT(float R, float G, float B);
float Plugin_066_CalcAmbientLight(float G, byte it);
float Plugin_066_CalcRelW(float X, float W);
void initHX711(int16_t pinSCL, int16_t pinDOUT);
boolean isReadyHX711(int16_t pinSCL, int16_t pinDOUT);
int32_t readHX711(int16_t pinSCL, int16_t pinDOUT, uint8_t mode);
boolean Plugin_067(byte function, struct EventStruct *event, String& string);
boolean Plugin_068(byte function, struct EventStruct *event, String& string);
boolean Plugin_069(byte function, struct EventStruct *event, String& string);
boolean Plugin_070(byte function, struct EventStruct *event, String& string);
void Clock_update();
void calculateMarks();
void clearClock();
void timeToStrip(int hours, int minutes, int seconds);
boolean Plugin_071(byte function, struct EventStruct *event, String& string);
bool parity_check(unsigned input);
boolean Plugin_072(byte function, struct EventStruct *event, String& string);
boolean Plugin_073(byte function, struct EventStruct *event, String& string);
void p073_FillBufferWithTime();
void p073_FillBufferWithDate();
void p073_FillBufferWithNumber(String number);
void p073_FillBufferWithTemp(long temperature);
void p073_FillBufferWithDash();
void tm1637_i2cStart (uint8_t clk_pin, uint8_t dio_pin);
void tm1637_i2cStop (uint8_t clk_pin, uint8_t dio_pin);
void tm1637_i2cAck (uint8_t clk_pin, uint8_t dio_pin);
void tm1637_i2cWrite (uint8_t clk_pin, uint8_t dio_pin, uint8_t bytetoprint);
void tm1637_ClearDisplay (uint8_t clk_pin, uint8_t dio_pin);
void tm1637_SetPowerBrightness (uint8_t clk_pin, uint8_t dio_pin, uint8_t brightlvl, bool poweron);
void tm1637_InitDisplay(uint8_t clk_pin, uint8_t dio_pin);
void tm1637_ShowTime6(uint8_t clk_pin, uint8_t dio_pin, bool sep);
void tm1637_ShowDate6(uint8_t clk_pin, uint8_t dio_pin, bool sep);
void tm1637_ShowTemp6(uint8_t clk_pin, uint8_t dio_pin, bool sep);
void tm1637_ShowTimeTemp4(uint8_t clk_pin, uint8_t dio_pin, bool sep, byte bufoffset);
void tm1637_SwapDigitInBuffer();
void tm1637_ShowBuffer(uint8_t clk_pin, uint8_t dio_pin, byte digits);
void max7219_spiTransfer (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, volatile byte opcode, volatile byte data);
void max7219_ClearDisplay (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin);
void max7219_SetPowerBrightness (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, uint8_t brightlvl, bool poweron);
void max7219_SetDigit(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, int dgtpos, byte dgtvalue, boolean showdot);
void max7219_InitDisplay(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin);
void max7219_ShowTime(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, bool sep);
void max7219_ShowTemp(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin);
void max7219_ShowDate(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin);
void max7219_ShowBuffer(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin);
boolean Plugin_074(byte function, struct EventStruct *event, String& string);
boolean Plugin_075(byte function, struct EventStruct *event, String &string);
void sendCommand(const char *cmd);
boolean Plugin_076(byte function, struct EventStruct *event, String& string);
void Plugin076_SaveMultipliers();
void ReportStatus();
void CPluginInit(void);
byte CPluginCall(byte Function, struct EventStruct *event);
bool anyControllerEnabled();
byte findFirstEnabledControllerWithId(byte cpluginid);
void NPluginInit(void);
byte NPluginCall(byte Function, struct EventStruct *event);
void PluginInit(void);
byte PluginCall(byte Function, struct EventStruct *event, String& str);
#line 163 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
int firstEnabledBlynkController() {

  for (byte i = 0; i < CONTROLLER_MAX; ++i) {

    byte ProtocolIndex = getProtocolIndex(Settings.Protocol[i]);

    if (Protocol[ProtocolIndex].Number == 12 && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return -1;

}
# 193 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void setup()

{

  WiFi.persistent(false);

  WiFi.setAutoReconnect(false);

  setWifiMode(WIFI_OFF);



  checkRAM(F("setup"));

  #if defined(ESP32)

    for(byte x = 0; x < 16; x++)

      ledChannelPin[x] = -1;

  #endif



  lowestRAM = FreeMem();



  Serial.begin(115200);





  initLog();

#if defined(ESP32)

  WiFi.onEvent((WiFiEventFullCb)WiFiEvent);

#else



  stationConnectedHandler = WiFi.onStationModeConnected(onConnected);

 stationDisconnectedHandler = WiFi.onStationModeDisconnected(onDisconnect);

 stationGotIpHandler = WiFi.onStationModeGotIP(onGotIP);

  APModeStationConnectedHandler = WiFi.onSoftAPModeStationConnected(onConnectedAPmode);

  APModeStationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onDisonnectedAPmode);

#endif



  if (SpiffsSectors() < 32)

  {

    Serial.println(F("\nNo (or too small) SPIFFS area..\nSystem Halted\nPlease reflash with 128k SPIFFS minimum!"));

    while (true)

      delay(1);

  }



  emergencyReset();



  String log = F("\n\n\rINIT : Booting version: ");

  log += BUILD_GIT;

  log += F(" (");

  log += getSystemLibraryString();

  log += F(")");

  addLog(LOG_LEVEL_INFO, log);







  if (readFromRTC())

  {

    RTC.bootCounter++;

    readUserVarFromRTC();



    if (RTC.deepSleepState == 1)

    {

      log = F("INIT : Rebooted from deepsleep #");

      lastBootCause=BOOT_CAUSE_DEEP_SLEEP;

    }

    else

      log = F("INIT : Warm boot #");



    log += RTC.bootCounter;



  }



  else

  {

    initRTC();





    if (lastBootCause == BOOT_CAUSE_MANUAL_REBOOT)

      lastBootCause = BOOT_CAUSE_COLD_BOOT;

    log = F("INIT : Cold Boot");

  }



  RTC.deepSleepState=0;

  saveToRTC();



  addLog(LOG_LEVEL_INFO, log);



  fileSystemCheck();

  progMemMD5check();

  LoadSettings();





  checkRuleSets();



  ExtraTaskSettings.TaskIndex = 255;







  if (Settings.Version != VERSION || Settings.PID != ESP_PROJECT_PID)

  {



    Serial.print(F("\nPID:"));

    Serial.println(Settings.PID);

    Serial.print(F("Version:"));

    Serial.println(Settings.Version);

    Serial.println(F("INIT : Incorrect PID or version!"));

    delay(1000);

    ResetFactory();

  }



  if (Settings.UseSerial)

  {



    Serial.flush();

    Serial.begin(Settings.BaudRate);



  }



  if (Settings.Build != BUILD)

    BuildFixes();





  log = F("INIT : Free RAM:");

  log += FreeMem();

  addLog(LOG_LEVEL_INFO, log);



  if (Settings.UseSerial && Settings.SerialLogLevel >= LOG_LEVEL_DEBUG_MORE)

    Serial.setDebugOutput(true);



  checkRAM(F("hardwareInit"));

  hardwareInit();
# 447 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
  for (byte x = 0; x < TASKS_MAX; x++)

    if (Settings.TaskDeviceTimer[x] !=0)

      timerSensor[x] = millis() + (x * Settings.MessageDelay);



  timer100ms = 0;

  timer1s = 0;

  timerwd = 0;

  timermqtt = 10000;

  timermqtt_interval = 250;

  timerAwakeFromDeepSleep = millis();



  PluginInit();

  CPluginInit();

  NPluginInit();

  log = F("INFO : Plugins: ");

  log += deviceCount + 1;

  log += getPluginDescriptionString();

  log += F(" (");

  log += getSystemLibraryString();

  log += F(")");

  addLog(LOG_LEVEL_INFO, log);



  if (deviceCount + 1 >= PLUGIN_MAX) {

    addLog(LOG_LEVEL_ERROR, F("Programming error! - Increase PLUGIN_MAX"));

  }



  if (Settings.UseRules)

  {

    String event = F("System#Wake");

    rulesProcessing(event);

  }



  if (!selectValidWiFiSettings()) {

    wifiSetup = true;

  }
# 533 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
  WiFiConnectRelaxed();



  #ifdef FEATURE_REPORTING

  ReportStatus();

  #endif



  #ifdef FEATURE_ARDUINO_OTA

  ArduinoOTAInit();

  #endif





  if (Settings.UDPPort != 0)

    portUDP.begin(Settings.UDPPort);



  sendSysInfoUDP(3);



  if (Settings.UseNTP)

    initTime();



#if FEATURE_ADC_VCC

  vcc = ESP.getVcc() / 1000.0;

#endif



  if (Settings.UseRules)

  {

    String event = F("System#Boot");

    rulesProcessing(event);

  }



  writeDefaultCSS();



  UseRTOSMultitasking = Settings.UseRTOSMultitasking;

  #ifdef USE_RTOS_MULTITASKING

    if(UseRTOSMultitasking){

      log = F("RTOS : Launching tasks");

      addLog(LOG_LEVEL_INFO, log);

      xTaskCreatePinnedToCore(RTOS_TaskServers, "RTOS_TaskServers", 8192, NULL, 1, NULL, 1);

      xTaskCreatePinnedToCore(RTOS_TaskSerial, "RTOS_TaskSerial", 8192, NULL, 1, NULL, 1);

      xTaskCreatePinnedToCore(RTOS_Task10ps, "RTOS_Task10ps", 8192, NULL, 1, NULL, 1);

    }

  #endif
# 623 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
  timer20ms = millis();

  timer100ms = millis();

  timer1s = millis();

}



#ifdef USE_RTOS_MULTITASKING

void RTOS_TaskServers( void * parameter )

{

 while (true){

  delay(100);

  WebServer.handleClient();

  checkUDP();

 }

}



void RTOS_TaskSerial( void * parameter )

{

 while (true){

    delay(100);

    if (Settings.UseSerial)

    if (Serial.available())

      if (!PluginCall(PLUGIN_SERIAL_IN, 0, dummyString))

        serial();

 }

}



void RTOS_Task10ps( void * parameter )

{

 while (true){

    delay(100);

    run10TimesPerSecond();

 }

}

#endif



int firstEnabledMQTTController() {

  for (byte i = 0; i < CONTROLLER_MAX; ++i) {

    byte ProtocolIndex = getProtocolIndex(Settings.Protocol[i]);

    if (Protocol[ProtocolIndex].usesMQTT && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return -1;

}



bool getControllerProtocolDisplayName(byte ProtocolIndex, byte parameterIdx, String& protoDisplayName) {

  EventStruct tmpEvent;

  tmpEvent.idx=parameterIdx;

  return CPlugin_ptr[ProtocolIndex](CPLUGIN_GET_PROTOCOL_DISPLAY_NAME, &tmpEvent, protoDisplayName);

}
# 731 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void loop()

{

  if(MainLoopCall_ptr)

      MainLoopCall_ptr();



  loopCounter++;



  if (wifiSetupConnect)

  {



    WiFiConnectRelaxed();

    wifiSetupConnect = false;

  }

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    if (wifiStatus >= ESPEASY_WIFI_CONNECTED) processConnect();

    if (wifiStatus >= ESPEASY_WIFI_GOT_IP) processGotIP();

    if (wifiStatus == ESPEASY_WIFI_DISCONNECTED) processDisconnect();

  } else if (!WiFiConnected()) {
# 775 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
  }

  if (!processedConnectAPmode) processConnectAPmode();

  if (!processedDisconnectAPmode) processDisconnectAPmode();

  if (!processedScanDone) processScanDone();



  bool firstLoopWiFiConnected = wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED && firstLoop;

  if (firstLoopWiFiConnected) {

     firstLoop = false;

     timerAwakeFromDeepSleep = millis();

   }





  if ((firstLoopWiFiConnected || readyForSleep()) && isDeepSleepEnabled())

  {

      runPeriodicalMQTT();



      run50TimesPerSecond();

      run10TimesPerSecond();

      runEach30Seconds();

      runOncePerSecond();

  }



  else

  {



    if (timeOutReached(timer20ms))

      run50TimesPerSecond();



    if (timeOutReached(timer100ms))

      if(!UseRTOSMultitasking)

        run10TimesPerSecond();



    if (timeOutReached(timerwd))

      runEach30Seconds();



    if (timeOutReached(timer1s))

      runOncePerSecond();



    if (timeOutReached(timermqtt)) {

      runPeriodicalMQTT();

    }

  }



  backgroundtasks();



  if (readyForSleep()){

    if (Settings.UseRules)

    {

      String event = F("System#Sleep");

      rulesProcessing(event);

    }



    runPeriodicalMQTT();



    deepSleep(Settings.Delay);



  }

}





void runPeriodicalMQTT() {



  if (!WiFiConnected(10)) {

    updateMQTTclient_connected();

    return;

  }



  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController >= 0) {

    if (!MQTTclient.loop()) {

      updateMQTTclient_connected();

      if (MQTTCheck(enabledMqttController)) {

        updateMQTTclient_connected();

      }

    }

  } else {

    if (MQTTclient.connected()) {

      MQTTclient.disconnect();

      updateMQTTclient_connected();

    }

  }

}



void updateMQTTclient_connected() {

  if (MQTTclient_connected != MQTTclient.connected()) {

    MQTTclient_connected = !MQTTclient_connected;

    if (!MQTTclient_connected)

      addLog(LOG_LEVEL_ERROR, F("MQTT : Connection lost"));

    if (Settings.UseRules) {

      String event = MQTTclient_connected ? F("MQTT#Connected") : F("MQTT#Disconnected");

      rulesProcessing(event);

    }

  }

  if (!MQTTclient_connected) {



    if (timermqtt_interval < 30000) {

      timermqtt_interval += 5000;

    }

  } else {

    timermqtt_interval = 250;

  }

  timermqtt = millis() + timermqtt_interval;

}
# 991 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void run50TimesPerSecond()

{

  setNextTimeInterval(timer20ms, 20);

  unsigned long start = micros();

  PluginCall(PLUGIN_FIFTY_PER_SECOND, 0, dummyString);

  elapsed50ps += micros() - start;

}
# 1013 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void run10TimesPerSecond()

{

  setNextTimeInterval(timer100ms, 100);

  unsigned long start = micros();

  PluginCall(PLUGIN_TEN_PER_SECOND, 0, dummyString);

  elapsed10ps += micros() - start;

  start = micros();

  PluginCall(PLUGIN_UNCONDITIONAL_POLL, 0, dummyString);

  elapsed10psU += micros() - start;

  if (Settings.UseRules && eventBuffer.length() > 0)

  {

    rulesProcessing(eventBuffer);

    eventBuffer = "";

  }

  #ifndef USE_RTOS_MULTITASKING

    WebServer.handleClient();

  #endif

}
# 1059 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void runOncePerSecond()

{

  setNextTimeInterval(timer1s, 1000);

  dailyResetCounter++;

  if (dailyResetCounter > 86400)

  {

    RTC.flashDayCounter=0;

    saveToRTC();

    dailyResetCounter=0;

    String log = F("SYS  : Reset 24h counters");

    addLog(LOG_LEVEL_INFO, log);

  }



  checkSensors();



  if (Settings.ConnectionFailuresThreshold)

    if (connectionFailures > Settings.ConnectionFailuresThreshold)

      delayedReboot(60);



  if (cmd_within_mainloop != 0)

  {

    switch (cmd_within_mainloop)

    {

      case CMD_WIFI_DISCONNECT:

        {

          WifiDisconnect();

          break;

        }

      case CMD_REBOOT:

        {

          #if defined(ESP8266)

            ESP.reset();

          #endif

          #if defined(ESP32)

            ESP.restart();

          #endif

          break;

        }

    }

    cmd_within_mainloop = 0;

  }

  WifiCheck();





  if (Settings.UseNTP)

    checkTime();



  unsigned long start = micros();

  PluginCall(PLUGIN_ONCE_A_SECOND, 0, dummyString);

  unsigned long elapsed = micros() - start;



  checkSystemTimers();



  if (Settings.UseRules)

    rulesTimers();





  if (SecuritySettings.Password[0] != 0)

  {

    if (WebLoggedIn)

      WebLoggedInTimer++;

    if (WebLoggedInTimer > 300)

      WebLoggedIn = false;

  }





  if (Settings.WDI2CAddress != 0)

  {

    Wire.beginTransmission(Settings.WDI2CAddress);

    Wire.write(0xA5);

    Wire.endTransmission();

  }



  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV)

  {

    Serial.print(F("Plugin calls: 50 ps:"));

    Serial.print(elapsed50ps);

    Serial.print(F(" uS, 10 ps:"));

    Serial.print(elapsed10ps);

    Serial.print(F(" uS, 10 psU:"));

    Serial.print(elapsed10psU);

    Serial.print(F(" uS, 1 ps:"));

    Serial.print(elapsed);

    Serial.println(F(" uS"));

    elapsed50ps=0;

    elapsed10ps=0;

    elapsed10psU=0;

  }

  checkResetFactoryPin();

}
# 1247 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void runEach30Seconds()

{

   extern void checkRAMtoLog();

  checkRAMtoLog();

  wdcounter++;

  timerwd = millis() + 30000;

  String log;

  log.reserve(60);

  log = F("WD   : Uptime ");

  log += wdcounter / 2;

  log += F(" ConnectFailures ");

  log += connectionFailures;

  log += F(" FreeMem ");

  log += FreeMem();

  addLog(LOG_LEVEL_INFO, log);

  sendSysInfoUDP(1);

  refreshNodeList();



  #if defined(ESP8266)

  if (Settings.UseSSDP)

    SSDP_update();

  #endif

#if FEATURE_ADC_VCC

  vcc = ESP.getVcc() / 1000.0;

#endif

  loopCounterLast = loopCounter;

  loopCounter = 0;

  if (loopCounterLast > loopCounterMax)

    loopCounterMax = loopCounterLast;



  #ifdef FEATURE_REPORTING

  ReportStatus();

  #endif



}
# 1327 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void checkSensors()

{

  checkRAM(F("checkSensors"));

  bool isDeepSleep = isDeepSleepEnabled();



  for (byte x = 0; x < TASKS_MAX; x++)

  {

    if (

        (Settings.TaskDeviceTimer[x] != 0) &&

        (isDeepSleep || timeOutReached(timerSensor[x]))

    )

    {

      setNextTimeInterval(timerSensor[x], Settings.TaskDeviceTimer[x] * 1000);

      if (timerSensor[x] == 0)

        timerSensor[x] = 1;

      SensorSendTask(x);

    }

  }

  saveUserVarToRTC();

}
# 1401 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void SensorSendTask(byte TaskIndex)

{

  checkRAM(F("SensorSendTask"));

  if (Settings.TaskDeviceEnabled[TaskIndex])

  {

    byte varIndex = TaskIndex * VARS_PER_TASK;



    boolean success = false;

    byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

    LoadTaskSettings(TaskIndex);



    struct EventStruct TempEvent;

    TempEvent.TaskIndex = TaskIndex;

    TempEvent.BaseVarIndex = varIndex;



    TempEvent.sensorType = Device[DeviceIndex].VType;



    float preValue[VARS_PER_TASK];

    for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

      preValue[varNr] = UserVar[varIndex + varNr];



    if(Settings.TaskDeviceDataFeed[TaskIndex] == 0)

      success = PluginCall(PLUGIN_READ, &TempEvent, dummyString);

    else

      success = true;



    if (success)

    {

      for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

      {

        if (ExtraTaskSettings.TaskDeviceFormula[varNr][0] != 0)

        {

          String spreValue = String(preValue[varNr]);

          String formula = ExtraTaskSettings.TaskDeviceFormula[varNr];

          float value = UserVar[varIndex + varNr];

          float result = 0;

          String svalue = String(value);

          formula.replace(F("%pvalue%"), spreValue);

          formula.replace(F("%value%"), svalue);

          byte error = Calculate(formula.c_str(), &result);

          if (error == 0)

            UserVar[varIndex + varNr] = result;

        }

      }

      sendData(&TempEvent);

    }

  }

}
# 1507 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void setSystemTimer(unsigned long timer, byte plugin, byte Par1, byte Par2, byte Par3)

{





  boolean reUse = false;

  byte firstAvailable = SYSTEM_TIMER_MAX;

  for (byte x = 0; x < SYSTEM_TIMER_MAX; x++)

  {

    if (systemTimers[x].timer != 0)

    {

      if ((systemTimers[x].plugin == plugin) && (systemTimers[x].Par1 == Par1))

      {

        systemTimers[x].timer = millis() + timer;

        reUse = true;

        break;

      }

    }

    else if(firstAvailable == SYSTEM_TIMER_MAX)

    {

      firstAvailable = x;

    }

  }

  if (!reUse)

  {

    if (firstAvailable == SYSTEM_TIMER_MAX )

    {

      addLog(LOG_LEVEL_ERROR, F(NOTAVAILABLE_SYSTEM_TIMER_ERROR));

    }

    else

    {

      systemTimers[firstAvailable].timer = millis() + timer;

      systemTimers[firstAvailable].plugin = plugin;

      systemTimers[firstAvailable].Par1 = Par1;

      systemTimers[firstAvailable].Par2 = Par2;

      systemTimers[firstAvailable].Par3 = Par3;

    }

  }

}
# 1595 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void setSystemCMDTimer(unsigned long timer, String& action)

{

  for (byte x = 0; x < SYSTEM_CMD_TIMER_MAX; x++)

    if (systemCMDTimers[x].timer == 0)

    {

      systemCMDTimers[x].timer = millis() + timer;

      systemCMDTimers[x].action = action;

      break;

    }

}
# 1625 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
void checkSystemTimers()

{

  for (byte x = 0; x < SYSTEM_TIMER_MAX; x++)

    if (systemTimers[x].timer != 0)

    {

      if (timeOutReached(systemTimers[x].timer))

      {

        struct EventStruct TempEvent;

        TempEvent.Par1 = systemTimers[x].Par1;

        TempEvent.Par2 = systemTimers[x].Par2;

        TempEvent.Par3 = systemTimers[x].Par3;

        for (byte y = 0; y < PLUGIN_MAX; y++)

          if (Plugin_id[y] == systemTimers[x].plugin)

            Plugin_ptr[y](PLUGIN_TIMER_IN, &TempEvent, dummyString);

        systemTimers[x].timer = 0;

      }

    }



  for (byte x = 0; x < SYSTEM_CMD_TIMER_MAX; x++)

    if (systemCMDTimers[x].timer != 0)

      if (timeOutReached(systemCMDTimers[x].timer))

      {

        struct EventStruct TempEvent;

        parseCommandString(&TempEvent, systemCMDTimers[x].action);

        if (!PluginCall(PLUGIN_WRITE, &TempEvent, systemCMDTimers[x].action))

          ExecuteCommand(VALUE_SOURCE_SYSTEM, systemCMDTimers[x].action.c_str());

        systemCMDTimers[x].timer = 0;

        systemCMDTimers[x].action = "";

      }

}
# 1695 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasy.ino"
bool runningBackgroundTasks=false;

void backgroundtasks()

{





  yield();





  if (runningBackgroundTasks)

  {

    return;

  }

  runningBackgroundTasks=true;



  #if defined(ESP8266)

    tcpCleanup();

  #endif



  if(!UseRTOSMultitasking){

    if (Settings.UseSerial)

      if (Serial.available())

        if (!PluginCall(PLUGIN_SERIAL_IN, 0, dummyString))

          serial();

    WebServer.handleClient();

    checkUDP();

  }





  if (dnsServerActive)

    dnsServer.processNextRequest();



  #ifdef FEATURE_ARDUINO_OTA

  if(Settings.ArduinoOTAEnable)

    ArduinoOTA.handle();





  while (ArduinoOTAtriggered)

  {

    yield();

    ArduinoOTA.handle();

  }



  #endif



  yield();



  statusLED(false);



  runningBackgroundTasks=false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
char* ramtest;







bool safeReadStringUntil(Stream &input, String &str, char terminator, unsigned int maxSize=1024, unsigned int timeout=1000)

{

    int c;

    const unsigned long timer = millis() + timeout;

    str="";



    do {



        c = input.read();

        if(c >= 0) {





            if (c==terminator)

            {

                return(true);

            }



            else

            {

                str+=char(c);



                if (str.length()>=maxSize)

                {

                    addLog(LOG_LEVEL_ERROR, F("Not enough bufferspace to read all input data!"));

                    return(false);

                }

            }

        }

        yield();

    } while(!timeOutReached(timer));



    addLog(LOG_LEVEL_ERROR, F("Timeout while reading input data!"));

    return(false);



}



#define INPUT_COMMAND_SIZE 80

Command commandStringToEnum(const char * cmd) {

  String tmpcmd;

  tmpcmd = cmd;

  tmpcmd.toLowerCase();

  String log = F("Command: ");

  log += tmpcmd;

  addLog(LOG_LEVEL_INFO, log);

  char cmd_lc[INPUT_COMMAND_SIZE];

  tmpcmd.toCharArray(cmd_lc, tmpcmd.length() + 1);

  switch (cmd_lc[0]) {

    case 'a': {

           if (strcmp_P(cmd_lc, PSTR("accessinfo") ) == 0) return cmd_accessinfo;

      break;

    }

    case 'b': {

           if (strcmp_P(cmd_lc, PSTR("background") ) == 0) return cmd_background;

      else if (strcmp_P(cmd_lc, PSTR("blynkget") ) == 0) return cmd_BlynkGet;

      else if (strcmp_P(cmd_lc, PSTR("build") ) == 0) return cmd_build;

      break;

    }

    case 'c': {

           if (strcmp_P(cmd_lc, PSTR("clearaccessblock") ) == 0) return cmd_clearaccessblock;

      else if (strcmp_P(cmd_lc, PSTR("clearrtcram") ) == 0) return cmd_clearRTCRAM;

      else if (strcmp_P(cmd_lc, PSTR("config") ) == 0) return cmd_config;

      break;

    }

    case 'd': {

           if (strcmp_P(cmd_lc, PSTR("debug") ) == 0) return cmd_Debug;

      else if (strcmp_P(cmd_lc, PSTR("delay") ) == 0) return cmd_Delay;

      else if (strcmp_P(cmd_lc, PSTR("deepsleep") ) == 0) return cmd_deepSleep;

      break;

    }

    case 'e': {

           if (strcmp_P(cmd_lc, PSTR("erase") ) == 0) return cmd_Erase;

      else if (strcmp_P(cmd_lc, PSTR("event") ) == 0) return cmd_Event;

      else if (strcmp_P(cmd_lc, PSTR("executerules") ) == 0) return cmd_executeRules;

      break;

    }

    case 'i': {

           if (strcmp_P(cmd_lc, PSTR("i2cscanner") ) == 0) return cmd_i2cscanner;

      else if (strcmp_P(cmd_lc, PSTR("ip") ) == 0) return cmd_IP;

      break;

    }

    case 'l': {

           if (strcmp_P(cmd_lc, PSTR("load") ) == 0) return cmd_Load;

      else if (strcmp_P(cmd_lc, PSTR("logentry") ) == 0) return cmd_logentry;

      else if (strcmp_P(cmd_lc, PSTR("lowmem") ) == 0) return cmd_lowmem;

      break;

    }

    case 'm': {

           if (strcmp_P(cmd_lc, PSTR("malloc") ) == 0) return cmd_malloc;

      else if (strcmp_P(cmd_lc, PSTR("meminfo") ) == 0) return cmd_meminfo;

      break;

    }

    case 'n': {

           if (strcmp_P(cmd_lc, PSTR("name") ) == 0) return cmd_Name;

      else if (strcmp_P(cmd_lc, PSTR("notify") ) == 0) return cmd_notify;

      else if (strcmp_P(cmd_lc, PSTR("nosleep") ) == 0) return cmd_NoSleep;

      break;

    }

    case 'p': {

           if (strcmp_P(cmd_lc, PSTR("password") ) == 0) return cmd_Password;

      else if (strcmp_P(cmd_lc, PSTR("publish") ) == 0) return cmd_Publish;

      break;

    }

    case 'r': {

           if (strcmp_P(cmd_lc, PSTR("reboot") ) == 0) return cmd_Reboot;

      else if (strcmp_P(cmd_lc, PSTR("reset") ) == 0) return cmd_Reset;

      else if (strcmp_P(cmd_lc, PSTR("restart") ) == 0) return cmd_Restart;

      else if (strcmp_P(cmd_lc, PSTR("resetflashwritecounter")) == 0) return cmd_resetFlashWriteCounter;

      else if (strcmp_P(cmd_lc, PSTR("rules") ) == 0) return cmd_Rules;

      break;

    }

    case 's': {

           if (strcmp_P(cmd_lc, PSTR("sdcard") ) == 0) return cmd_sdcard;

      else if (strcmp_P(cmd_lc, PSTR("sdremove") ) == 0) return cmd_sdremove;

      else if (strcmp_P(cmd_lc, PSTR("sysload") ) == 0) return cmd_sysload;

      else if (strcmp_P(cmd_lc, PSTR("save") ) == 0) return cmd_Save;

      else if (strcmp_P(cmd_lc, PSTR("sendto") ) == 0) return cmd_SendTo;

      else if (strcmp_P(cmd_lc, PSTR("sendtohttp") ) == 0) return cmd_SendToHTTP;

      else if (strcmp_P(cmd_lc, PSTR("sendtoudp") ) == 0) return cmd_SendToUDP;

      else if (strcmp_P(cmd_lc, PSTR("serialfloat") ) == 0) return cmd_SerialFloat;

      else if (strcmp_P(cmd_lc, PSTR("settings") ) == 0) return cmd_Settings;

      break;

    }

    case 't': {

           if (strcmp_P(cmd_lc, PSTR("taskclear") ) == 0) return cmd_TaskClear;

      else if (strcmp_P(cmd_lc, PSTR("taskclearall") ) == 0) return cmd_TaskClearAll;

      else if (strcmp_P(cmd_lc, PSTR("taskrun") ) == 0) return cmd_TaskRun;

      else if (strcmp_P(cmd_lc, PSTR("taskvalueset") ) == 0) return cmd_TaskValueSet;

      else if (strcmp_P(cmd_lc, PSTR("taskvaluesetandrun") ) == 0) return cmd_TaskValueSetAndRun;

      else if (strcmp_P(cmd_lc, PSTR("timerset") ) == 0) return cmd_TimerSet;

      else if (strcmp_P(cmd_lc, PSTR("timerpause") ) == 0) return cmd_TimerPause;

      else if (strcmp_P(cmd_lc, PSTR("timerresume") ) == 0) return cmd_TimerResume;

      break;

    }

    case 'u': {

           if (strcmp_P(cmd_lc, PSTR("udptest") ) == 0) return cmd_udptest;

      else if (strcmp_P(cmd_lc, PSTR("unit") ) == 0) return cmd_Unit;

      break;

    }

    case 'w': {

           if (strcmp_P(cmd_lc, PSTR("wdconfig") ) == 0) return cmd_wdconfig;

      else if (strcmp_P(cmd_lc, PSTR("wdread") ) == 0) return cmd_wdread;

      else if (strcmp_P(cmd_lc, PSTR("wifiapmode") ) == 0) return cmd_WifiAPMode;

      else if (strcmp_P(cmd_lc, PSTR("wificonnect") ) == 0) return cmd_WifiConnect;

      else if (strcmp_P(cmd_lc, PSTR("wifidisconnect") ) == 0) return cmd_WifiDisconnect;

      else if (strcmp_P(cmd_lc, PSTR("wifikey2") ) == 0) return cmd_WifiKey2;

      else if (strcmp_P(cmd_lc, PSTR("wifikey") ) == 0) return cmd_WifiKey;

      else if (strcmp_P(cmd_lc, PSTR("wifissid2") ) == 0) return cmd_WifiSSID2;

      else if (strcmp_P(cmd_lc, PSTR("wifissid") ) == 0) return cmd_WifiSSID;

      else if (strcmp_P(cmd_lc, PSTR("wifiscan") ) == 0) return cmd_WifiScan;

      break;

    }

    default:

      addLog(LOG_LEVEL_INFO, F("Command unknown"));

      return cmd_Unknown;

  }

  addLog(LOG_LEVEL_INFO, F("Command unknown"));

  return cmd_Unknown;

}



void ExecuteCommand(byte source, const char *Line)

{

  checkRAM(F("ExecuteCommand"));

  String status = "";

  boolean success = false;

  char TmpStr1[INPUT_COMMAND_SIZE];

  TmpStr1[0] = 0;

  char cmd[INPUT_COMMAND_SIZE];

  cmd[0] = 0;

  int Par1 = 0;

  int Par2 = 0;

  int Par3 = 0;



  GetArgv(Line, cmd, 1);

  if (GetArgv(Line, TmpStr1, 2)) Par1 = str2int(TmpStr1);

  if (GetArgv(Line, TmpStr1, 3)) Par2 = str2int(TmpStr1);

  if (GetArgv(Line, TmpStr1, 4)) Par3 = str2int(TmpStr1);



  const Command cmd_enum = commandStringToEnum(cmd);

  switch (cmd_enum) {
# 377 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
  case cmd_background:

  {

    success = true;

    unsigned long timer = millis() + Par1;

    Serial.println(F("start"));

    while (!timeOutReached(timer))

      backgroundtasks();

    Serial.println(F("end"));

    break;

  }



  case cmd_executeRules:

  {

    success = true;

    if (GetArgv(Line, TmpStr1, 2))

    {

      String fileName = TmpStr1;

      String event = "";

      rulesProcessingFile(fileName, event);

    }

    break;

  }



  case cmd_clearRTCRAM:

  {

    success = true;

    initRTC();

    break;

  }



  case cmd_notify:

  {

    success = true;

    String message = "";

    if (GetArgv(Line, TmpStr1, 3))

      message = TmpStr1;



    if (Par1 > 0)

    {

      if (Settings.NotificationEnabled[Par1 - 1] && Settings.Notification[Par1 - 1] != 0)

      {

        byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[Par1 - 1]);

        if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

        {

          struct EventStruct TempEvent;



          TempEvent.NotificationIndex=Par1-1;

          NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_NOTIFY, &TempEvent, message);

        }

      }

    }

    break;

  }



  case cmd_resetFlashWriteCounter:

  {

    success = true;

    RTC.flashDayCounter = 0;

    break;

  }



  case cmd_udptest:

  {

    success = true;

    for (byte x = 0; x < Par2; x++)

    {

      String event = "Test ";

      event += x;

      SendUDPCommand(Par1, (char*)event.c_str(), event.length());

    }

    break;

  }

#ifdef FEATURE_SD

  case cmd_sdcard:

  {

    success = true;

    File root = SD.open("/");

    root.rewindDirectory();

    printDirectory(root, 0);

    root.close();

    break;

  }



  case cmd_sdremove:

  {

    success = true;

    String fname = Line;

    fname = fname.substring(9);

    Serial.print(F("Removing:"));

    Serial.println(fname.c_str());

    SD.remove((char*)fname.c_str());

    break;

  }

#endif



  case cmd_lowmem:

  {

    Serial.print(lowestRAM);

    Serial.print(F(" : "));

    Serial.println(lowestRAMfunction);

    success = true;

    break;

  }



  case cmd_malloc:

  {

    ramtest = (char *)malloc(Par1);

    success = true;

    break;

  }



  case cmd_sysload:

  {

    success = true;

    Serial.print(100 - (100 * loopCounterLast / loopCounterMax));

    Serial.print(F("% (LC="));

    Serial.print(int(loopCounterLast / 30));

    Serial.println(F(")"));

    break;

  }



  case cmd_SerialFloat:

  {

    success = true;

    pinMode(1, INPUT);

    pinMode(3, INPUT);

    delay(60000);

    break;

  }



  case cmd_accessinfo:

  {

    success = true;

    Serial.print(F("Allowed IP range : "));

    Serial.println(describeAllowedIPrange());

    break;

  }



  case cmd_clearaccessblock:

  {

    success = true;

    clearAccessBlock();

    Serial.print(F("Allowed IP range : "));

    Serial.println(describeAllowedIPrange());

    break;

  }



  case cmd_meminfo:

  {

    success = true;

    Serial.print(F("SecurityStruct         : "));

    Serial.println(sizeof(SecuritySettings));

    Serial.print(F("SettingsStruct         : "));

    Serial.println(sizeof(Settings));

    Serial.print(F("ExtraTaskSettingsStruct: "));

    Serial.println(sizeof(ExtraTaskSettings));

    Serial.print(F("DeviceStruct: "));

    Serial.println(sizeof(Device));

    break;

  }



  case cmd_TaskClear:

  {

    success = true;

    taskClear(Par1 - 1, true);

    break;

  }





  case cmd_TaskClearAll:

  {

    success = true;

    for (byte t=0; t<TASKS_MAX; t++)

      taskClear(t, false);

    break;

  }



  case cmd_wdconfig:

  {

    success = true;

    Wire.beginTransmission(Par1);

    Wire.write(Par2);

    Wire.write(Par3);

    Wire.endTransmission();

    break;

  }



  case cmd_wdread:

  {

    success = true;

    Wire.beginTransmission(Par1);

    Wire.write(0x83);

    Wire.write(Par2);

    Wire.endTransmission();

    Wire.requestFrom((uint8_t)Par1, (uint8_t)1);

    if (Wire.available())

    {

      byte value = Wire.read();

      status = F("Reg value: ");

      status += value;

    }

    break;

  }



  case cmd_build:

  {

    success = true;

    Settings.Build = Par1;

    SaveSettings();

    break;

  }



  case cmd_NoSleep:

  {

    success = true;

    Settings.deepSleep = 0;

    break;

  }



  case cmd_i2cscanner:

  {

    success = true;



    byte error, address;

    for (address = 1; address <= 127; address++ )

    {

      Wire.beginTransmission(address);

      error = Wire.endTransmission();

      if (error == 0)

      {

        Serial.print(F("I2C  : Found 0x"));

        Serial.println(String(address, HEX));

      }

      else if (error == 4)

      {

        Serial.print(F("I2C  : Error at 0x"));

        Serial.println(String(address, HEX));

      }

    }

    break;

  }
# 869 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
  case cmd_config:

  {

    success = true;

    struct EventStruct TempEvent;

    String request = Line;

    remoteConfig(&TempEvent, request);

    break;

  }



  case cmd_deepSleep:

  {

    success = true;

    if (Par1 > 0)

      deepSleepStart(Par1);

    break;

  }



  case cmd_TaskValueSet:

  {

    success = true;

    if (GetArgv(Line, TmpStr1, 4))

    {

      float result = 0;

      Calculate(TmpStr1, &result);

      UserVar[(VARS_PER_TASK * (Par1 - 1)) + Par2 - 1] = result;

    }

    break;

  }



  case cmd_TaskValueSetAndRun:

  {

    success = true;

    if (GetArgv(Line, TmpStr1, 4))

    {

      float result = 0;

      Calculate(TmpStr1, &result);

      UserVar[(VARS_PER_TASK * (Par1 - 1)) + Par2 - 1] = result;

      SensorSendTask(Par1 - 1);

    }

    break;

  }
# 961 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
  case cmd_logentry:

  {

    success = true;

    break;

  }



  case cmd_TaskRun:

  {

    success = true;

    SensorSendTask(Par1 - 1);

    break;

  }



  case cmd_TimerSet:

  {

    if (Par1>=1 && Par1<=RULES_TIMER_MAX)

    {

      success = true;

      if (Par2)

      {



        RulesTimer[Par1 - 1].interval = Par2*1000;

        RulesTimer[Par1 - 1].paused = false;

        RulesTimer[Par1 - 1].timestamp = millis() + (1000 * Par2);

      }

      else

      {



        RulesTimer[Par1 - 1].interval = 0;

        RulesTimer[Par1 - 1].paused = false;

        RulesTimer[Par1 - 1].timestamp = 0L;

      }

    }

    else

    {

      addLog(LOG_LEVEL_ERROR, F("TIMER: invalid timer number"));

    }

    break;

  }



  case cmd_TimerPause:

  {

    if (Par1>=1 && Par1<=RULES_TIMER_MAX)

    {

       success = true;

       if (RulesTimer[Par1 - 1].paused == false)

       {

          long delta = timePassedSince(RulesTimer[Par1 - 1].timestamp);

          if(RulesTimer[Par1 - 1].timestamp != 0L && delta < 0)

          {

            String event = F("Rules#TimerPause=");

            event += Par1;

            rulesProcessing(event);

            RulesTimer[Par1 - 1].paused = true;

            RulesTimer[Par1 - 1].interval = -delta;

          }

       }

       else

       {

         addLog(LOG_LEVEL_INFO, F("TIMER: already paused"));

       }

    }

    else

    {

      addLog(LOG_LEVEL_ERROR, F("TIMER: invalid timer number"));

    }

    break;

  }



  case cmd_TimerResume:

  {

    if (Par1>=1 && Par1<=RULES_TIMER_MAX)

    {

       success = true;

       if (RulesTimer[Par1 - 1].paused == true)

       {

          if(RulesTimer[Par1 - 1].interval > 0 && RulesTimer[Par1 - 1].timestamp != 0L)

          {

            String event = F("Rules#TimerResume=");

            event += Par1;

            rulesProcessing(event);

            RulesTimer[Par1 - 1].timestamp = millis() + (RulesTimer[Par1 - 1].interval);

            RulesTimer[Par1 - 1].paused = false;

          }

       }

       else

       {

         addLog(LOG_LEVEL_INFO, F("TIMER: already resumed"));

       }

    }

    else

    {

      addLog(LOG_LEVEL_ERROR, F("TIMER: invalid timer number"));

    }

    break;

  }



  case cmd_Delay:

  {

    success = true;

    delayBackground(Par1);

    break;

  }



  case cmd_Rules:

  {

    success = true;

    if (Par1 == 1)

      Settings.UseRules = true;

    else

      Settings.UseRules = false;

    break;

  }



  case cmd_Event:

  {

    success = true;

    String event = Line;

    event = event.substring(6);

    event.replace('$', '#');

    if (Settings.UseRules)

      rulesProcessing(event);

    break;

  }



  case cmd_SendTo:

  {

    success = true;

    String event = Line;

    event = event.substring(7);

    int index = event.indexOf(',');

    if (index > 0)

    {

      event = event.substring(index + 1);

      SendUDPCommand(Par1, (char*)event.c_str(), event.length());

    }

    break;

  }

  case cmd_Publish:

  {

    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {



      int enabledMqttController = firstEnabledMQTTController();

      if (enabledMqttController >= 0) {

        success = true;

        String event = Line;

        event = event.substring(8);

        int index = event.indexOf(',');

        if (index > 0)

        {

          String topic = event.substring(0, index);

          String value = event.substring(index + 1);

          MQTTpublish(enabledMqttController, topic.c_str(), value.c_str(), Settings.MQTTRetainFlag);

        }

      }

    }

    break;

  }



  case cmd_SendToUDP:

  {

    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {

      success = true;

      String strLine = Line;

      String ip = parseString(strLine, 2);

      String port = parseString(strLine, 3);

      int msgpos = getParamStartPos(strLine, 4);

      String message = strLine.substring(msgpos);

      IPAddress UDP_IP;

      if(UDP_IP.fromString(ip)) {

        portUDP.beginPacket(UDP_IP, port.toInt());

        #if defined(ESP8266)

          portUDP.write(message.c_str(), message.length());

        #endif

        #if defined(ESP32)

          portUDP.write((uint8_t*)message.c_str(), message.length());

        #endif

        portUDP.endPacket();

      }

    }

    break;

  }



  case cmd_SendToHTTP:

  {

    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {

      success = true;

      String strLine = Line;

      String host = parseString(strLine, 2);

      String port = parseString(strLine, 3);

      int pathpos = getParamStartPos(strLine, 4);

      String path = strLine.substring(pathpos);

      WiFiClient client;

      if (client.connect(host.c_str(), port.toInt()))

      {

        String reply = F("GET ");

        reply += path;

        reply += F(" HTTP/1.1\r\n");

        reply += F("Host: ");

        reply += host;

        reply += F("\r\n");

        reply += F("Connection: close\r\n\r\n");

        client.print(reply);



        unsigned long timer = millis() + 200;

        while (!client.available() && !timeOutReached(timer))

          delay(1);



        while (client.available()) {



          String line;

          safeReadStringUntil(client, line, '\n');





          if (line.substring(0, 15) == F("HTTP/1.1 200 OK"))

            addLog(LOG_LEVEL_DEBUG, line);

          delay(1);

        }

        client.flush();

        client.stop();

      }

    }

    break;

  }
# 1419 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
#ifdef CPLUGIN_012



  case cmd_BlynkGet:

  {

    byte first_enabled_blynk_controller = firstEnabledBlynkController();

    if (first_enabled_blynk_controller == -1) {

      status = F("Controller not enabled");

    } else {

      String strLine = Line;

      strLine = strLine.substring(9);

      int index = strLine.indexOf(',');

      if (index > 0)

      {

        int index = strLine.lastIndexOf(',');

        String blynkcommand = strLine.substring(index+1);

        float value = 0;

        if (Blynk_get(blynkcommand, first_enabled_blynk_controller, &value))

        {

          UserVar[(VARS_PER_TASK * (Par1 - 1)) + Par2 - 1] = value;

        }

        else

          status = F("Error getting data");

      }

      else

      {

        if (!Blynk_get(strLine, first_enabled_blynk_controller))

        {

          status = F("Error getting data");

        }

      }

    }

    break;

  }

#endif
# 1495 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Command.ino"
  case cmd_WifiSSID:

  {

    success = true;

    strcpy(SecuritySettings.WifiSSID, Line + 9);

    break;

  }



  case cmd_WifiKey:

  {

    success = true;

    strcpy(SecuritySettings.WifiKey, Line + 8);

    break;

  }



  case cmd_WifiSSID2:

  {

    success = true;

    strcpy(SecuritySettings.WifiSSID2, Line + 10);

    break;

  }



  case cmd_WifiKey2:

  {

    success = true;

    strcpy(SecuritySettings.WifiKey2, Line + 9);

    break;

  }



  case cmd_WifiScan:

  {

    success = true;

    WifiScan();

    break;

  }



  case cmd_WifiConnect:

  {

    success = true;

    WiFiConnectRelaxed();

    break;

  }



  case cmd_WifiDisconnect:

  {

    success = true;

    WifiDisconnect();

    break;

  }



  case cmd_WifiAPMode:

  {

    setAP(true);

    success = true;

    break;

  }



  case cmd_Unit:

  {

    success = true;

    Settings.Unit=Par1;

    break;

  }



  case cmd_Name:

  {

    success = true;

    strcpy(Settings.Name, Line + 5);

    break;

  }



  case cmd_Password:

  {

    success = true;

    strcpy(SecuritySettings.Password, Line + 9);

    break;

  }



  case cmd_Reboot:

  {

    success = true;

    pinMode(0, INPUT);

    pinMode(2, INPUT);

    pinMode(15, INPUT);

    #if defined(ESP8266)

      ESP.reset();

    #endif

    #if defined(ESP32)

      ESP.restart();

    #endif

    break;

  }



  case cmd_Restart:

  {

    success = true;

    ESP.restart();

    break;

  }



  case cmd_Erase:

  {

    success = true;

    WiFi.persistent(true);

    WifiDisconnect();

    WiFi.persistent(false);

    break;

  }



  case cmd_Reset:

  {

    success = true;

    ResetFactory();

    #if defined(ESP8266)

      ESP.reset();

    #endif

    #if defined(ESP32)

      ESP.restart();

    #endif

    break;

  }



  case cmd_Save:

  {

    success = true;

    SaveSettings();

    break;

  }



  case cmd_Load:

  {

    success = true;

    LoadSettings();

    break;

  }



  case cmd_Debug:

  {

    success = true;

    Settings.SerialLogLevel = Par1;

    break;

  }



  case cmd_IP:

  {

    success = true;

    if (GetArgv(Line, TmpStr1, 2)) {

      if (!str2ip(TmpStr1, Settings.IP))

        Serial.println("?");

    }

    break;

  }



  case cmd_Settings:

  {

    success = true;

    char str[20];

    Serial.println();



    Serial.println(F("System Info"));

    IPAddress ip = WiFi.localIP();

    sprintf_P(str, PSTR("%u.%u.%u.%u"), ip[0], ip[1], ip[2], ip[3]);

    Serial.print(F("  IP Address    : ")); Serial.println(str);

    Serial.print(F("  Build         : ")); Serial.println((int)BUILD);

    Serial.print(F("  Name          : ")); Serial.println(Settings.Name);

    Serial.print(F("  Unit          : ")); Serial.println((int)Settings.Unit);

    Serial.print(F("  WifiSSID      : ")); Serial.println(SecuritySettings.WifiSSID);

    Serial.print(F("  WifiKey       : ")); Serial.println(SecuritySettings.WifiKey);

    Serial.print(F("  WifiSSID2     : ")); Serial.println(SecuritySettings.WifiSSID2);

    Serial.print(F("  WifiKey2      : ")); Serial.println(SecuritySettings.WifiKey2);

    Serial.print(F("  Free mem      : ")); Serial.println(FreeMem());

    break;

  }

  default:

    success = false;

  }



  yield();



  if (success)

    status += F("\nOk");

  else

    status += F("\nUnknown command!");

  SendStatus(source, status);

  yield();

}



#ifdef FEATURE_SD

void printDirectory(File dir, int numTabs) {

  while (true) {



    File entry = dir.openNextFile();

    if (! entry) {



      break;

    }

    for (uint8_t i = 0; i < numTabs; i++) {

      Serial.print('\t');

    }

    Serial.print(entry.name());

    if (entry.isDirectory()) {

      Serial.println("/");

      printDirectory(entry, numTabs + 1);

    } else {



      Serial.print("\t\t");

      Serial.println(entry.size(), DEC);

    }

    entry.close();

  }

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"






void sendData(struct EventStruct *event)

{

  checkRAM(F("sendData"));

 LoadTaskSettings(event->TaskIndex);

  if (Settings.UseRules)

    createRuleEvents(event->TaskIndex);



  if (Settings.UseValueLogger && Settings.InitSPI && Settings.Pin_sd_cs >= 0)

    SendValueLogger(event->TaskIndex);
# 33 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
  if (Settings.MessageDelay != 0)

  {

    const long dif = timePassedSince(lastSend);

    if (dif > 0 && dif < static_cast<long>(Settings.MessageDelay))

    {

      uint16_t delayms = Settings.MessageDelay - dif;







     delayBackground(delayms);
# 61 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
    }

  }



  LoadTaskSettings(event->TaskIndex);



  for (byte x=0; x < CONTROLLER_MAX; x++)

  {

    event->ControllerIndex = x;

    event->idx = Settings.TaskDeviceID[x][event->TaskIndex];

    if (Settings.TaskDeviceSendData[event->ControllerIndex][event->TaskIndex] &&

        Settings.ControllerEnabled[event->ControllerIndex] && Settings.Protocol[event->ControllerIndex])

    {

      event->ProtocolIndex = getProtocolIndex(Settings.Protocol[event->ControllerIndex]);

      if (validUserVar(event)) {

        CPlugin_ptr[event->ProtocolIndex](CPLUGIN_PROTOCOL_SEND, event, dummyString);

      } else {

        String log = F("Invalid value detected for controller ");

        String controllerName;

        CPlugin_ptr[event->ProtocolIndex](CPLUGIN_GET_DEVICENAME, event, controllerName);

        log += controllerName;

        addLog(LOG_LEVEL_DEBUG, log);

      }

    }

  }



  PluginCall(PLUGIN_EVENT_OUT, event, dummyString);

  lastSend = millis();

}



boolean validUserVar(struct EventStruct *event) {

  for (int i = 0; i < VARS_PER_TASK; ++i) {

    const float f(UserVar[event->BaseVarIndex + i]);

    if (!isValidFloat(f)) return false;

  }

  return true;

}
# 143 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
void callback(char* c_topic, byte* b_payload, unsigned int length) {



  char c_payload[384];



  statusLED(true);

  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController < 0) {

    addLog(LOG_LEVEL_ERROR, F("MQTT : No enabled MQTT controller"));

    return;

  }

  if ((length + 1) > sizeof(c_payload))

  {

    addLog(LOG_LEVEL_ERROR, F("MQTT : Ignored too big message"));

    return;

  }





  strncpy(c_payload,(char*)b_payload,length);

  c_payload[length] = 0;
# 215 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
  struct EventStruct TempEvent;

  TempEvent.String1 = c_topic;

  TempEvent.String2 = c_payload;

  byte ProtocolIndex = getProtocolIndex(Settings.Protocol[enabledMqttController]);

  CPlugin_ptr[ProtocolIndex](CPLUGIN_PROTOCOL_RECV, &TempEvent, dummyString);

}
# 237 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
bool MQTTConnect(int controller_idx)

{

  ++mqtt_reconnect_count;

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(controller_idx, (byte*)&ControllerSettings, sizeof(ControllerSettings));

  if (!ControllerSettings.checkHostReachable(true))

    return false;

  if (MQTTclient.connected()) {

    MQTTclient.disconnect();

    updateMQTTclient_connected();

  }

  mqtt = WiFiClient();

  if (ControllerSettings.UseDNS) {

    MQTTclient.setServer(ControllerSettings.getHost().c_str(), ControllerSettings.Port);

  } else {

    MQTTclient.setServer(ControllerSettings.getIP(), ControllerSettings.Port);

  }

  MQTTclient.setCallback(callback);





  String clientid = F("ESPClient_");

  clientid += WiFi.macAddress();



  String LWTTopic = ControllerSettings.Subscribe;

  LWTTopic.replace(F("/#"), F("/status"));

  parseSystemVariables(LWTTopic, false);

  LWTTopic += F("/LWT");



  boolean MQTTresult = false;

  uint8_t willQos = 0;

  boolean willRetain = true;



  if ((SecuritySettings.ControllerUser[controller_idx] != 0) && (SecuritySettings.ControllerPassword[controller_idx] != 0)) {

    MQTTresult = MQTTclient.connect(clientid.c_str(), SecuritySettings.ControllerUser[controller_idx], SecuritySettings.ControllerPassword[controller_idx],

                                    LWTTopic.c_str(), willQos, willRetain, "Connection Lost");

  } else {

    MQTTresult = MQTTclient.connect(clientid.c_str(), LWTTopic.c_str(), willQos, willRetain, "Connection Lost");

  }

  yield();



  if (!MQTTresult) {

    addLog(LOG_LEVEL_ERROR, F("MQTT : Failed to connect to broker"));

    return false;

  }

  MQTTclient_should_reconnect = false;

  String log = F("MQTT : Connected to broker with client ID: ");

  log += clientid;

  addLog(LOG_LEVEL_INFO, log);

  String subscribeTo = ControllerSettings.Subscribe;

  parseSystemVariables(subscribeTo, false);

  MQTTclient.subscribe(subscribeTo.c_str());

  log = F("Subscribed to: ");

  log += subscribeTo;

  addLog(LOG_LEVEL_INFO, log);



  if (MQTTclient.publish(LWTTopic.c_str(), "Connected", 1)) {

    updateMQTTclient_connected();

    statusLED(true);

    mqtt_reconnect_count = 0;

    return true;

  }

  return false;

}
# 373 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
bool MQTTCheck(int controller_idx)

{

  if (!WiFiConnected(10)) {

    return false;

  }

  byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controller_idx]);

  if (Protocol[ProtocolIndex].usesMQTT)

  {

    if (MQTTclient_should_reconnect || !MQTTclient.connected())

    {

      if (MQTTclient_should_reconnect) {

        addLog(LOG_LEVEL_ERROR, F("MQTT : Intentional reconnect"));

      } else {

        connectionFailures += 2;

      }

      return MQTTConnect(controller_idx);

    } else if (connectionFailures) {

      connectionFailures--;

    }

  }



  return true;

}
# 431 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
void SendStatus(byte source, String status)

{

  switch(source)

  {

    case VALUE_SOURCE_HTTP:

      if (printToWeb)

        printWebString += status;

      break;

    case VALUE_SOURCE_MQTT:

      MQTTStatus(status);

      break;

    case VALUE_SOURCE_SERIAL:

      Serial.println(status);

      break;

  }

}



boolean MQTTpublish(int controller_idx, const char* topic, const char* payload, boolean retained)

{

  if (MQTTclient.publish(topic, payload, retained)) {

    timermqtt = millis() + 10;

    return true;

  }

  addLog(LOG_LEVEL_DEBUG, F("MQTT : publish failed"));

  return false;

}
# 491 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Controller.ino"
void MQTTStatus(String& status)

{

  ControllerSettingsStruct ControllerSettings;

  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController >= 0) {

    LoadControllerSettings(enabledMqttController, (byte*)&ControllerSettings, sizeof(ControllerSettings));

    String pubname = ControllerSettings.Subscribe;

    pubname.replace(F("/#"), F("/status"));

    parseSystemVariables(pubname, false);

    MQTTpublish(enabledMqttController, pubname.c_str(), status.c_str(),Settings.MQTTRetainFlag);

  }

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Convert.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Convert.ino"
String getBearing(int degrees)

{

  const __FlashStringHelper* bearing[] = {

    F("N"),

    F("NNE"),

    F("NE"),

    F("ENE"),

    F("E"),

    F("ESE"),

    F("SE"),

    F("SSE"),

    F("S"),

    F("SSW"),

    F("SW"),

    F("WSW"),

    F("W"),

    F("WNW"),

    F("NW"),

    F("NNW")

  };

  int nr_directions = (int) (sizeof(bearing)/sizeof(bearing[0]));

  float stepsize = (360.0 / nr_directions);

  if (degrees < 0) { degrees += 360; }

  int bearing_idx=int((degrees + (stepsize / 2.0)) / stepsize) % nr_directions;

  if (bearing_idx < 0)

    return("");

  else

    return(bearing[bearing_idx]);

}



float CelsiusToFahrenheit(float celsius) {

  return celsius * (9.0 / 5.0) + 32;

}



int m_secToBeaufort(float m_per_sec) {

  if (m_per_sec < 0.3) return 0;

  if (m_per_sec < 1.6) return 1;

  if (m_per_sec < 3.4) return 2;

  if (m_per_sec < 5.5) return 3;

  if (m_per_sec < 8.0) return 4;

  if (m_per_sec < 10.8) return 5;

  if (m_per_sec < 13.9) return 6;

  if (m_per_sec < 17.2) return 7;

  if (m_per_sec < 20.8) return 8;

  if (m_per_sec < 24.5) return 9;

  if (m_per_sec < 28.5) return 10;

  if (m_per_sec < 32.6) return 11;

  return 12;

}



String centimeterToImperialLength(float cm) {

  return millimeterToImperialLength(cm * 10.0);

}



String millimeterToImperialLength(float mm) {

  float inches = mm / 25.4;

  int feet = inches /12;

  inches = inches - (feet * 12);

  String result;

  result.reserve(10);

  if (feet != 0) {

    result += feet;

    result += '\'';

  }

  result += toString(inches,1);

  result += '"';

  return result;

}



float minutesToDay(int minutes) {

  return minutes / 1440.0;

}



String minutesToDayHour(int minutes) {

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  char TimeString[6];

  sprintf_P(TimeString, PSTR("%d%c%02d%c"), days, 'd', hours, 'h');

  return TimeString;

}



String minutesToHourMinute(int minutes) {

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c"), hours, 'h', mins, 'm');

  return TimeString;

}



String minutesToDayHourMinute(int minutes) {

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c%02d%c"), days, 'd', hours, 'h', mins, 'm');

  return TimeString;

}



String secondsToDayHourMinuteSecond(int seconds) {

  int sec = seconds % 60;

  int minutes = seconds / 60;

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c%02d%c%02d"), days, 'd', hours, ':', mins, ':', sec);

  return TimeString;

}



String format_msec_duration(long duration) {

  String result;

  if (duration < 0) {

    result = "-";

    duration = -1 * duration;

  }

  if (duration < 10000) {

    result += duration;

    result += F(" ms");

    return result;

  }

  duration /= 1000;

  if (duration < 3600) {

    int sec = duration % 60;

    int minutes = duration / 60;

    if (minutes > 0) {

      result += minutes;

      result += F(" m ");

    }

    result += sec;

    result += F(" s");

    return result;

  }

  duration /= 60;

  if (duration < 1440) return minutesToHourMinute(duration);

  return minutesToDayHourMinute(duration);

}
# 293 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Convert.ino"
unsigned long float2ul(float f)

{

  unsigned long ul;

  memcpy(&ul, &f, 4);

  return ul;

}
# 315 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Convert.ino"
float ul2float(unsigned long ul)

{

  float f;

  memcpy(&f, &ul, 4);

  return f;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"


#define WIFI_AP_OFF_TIMER_DURATION 60000
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
void processConnect() {

  if (processedConnect) return;

  processedConnect = true;

  ++wifi_reconnects;

  if (wifiStatus < ESPEASY_WIFI_CONNECTED) return;

  const long connect_duration = timeDiff(last_wifi_connect_attempt_moment, lastConnectMoment);

  String log = F("WIFI : Connected! AP: ");

  log += WiFi.SSID();

  log += F(" (");

  log += WiFi.BSSIDstr();

  log += F(") Ch: ");

  log += last_channel;

  if (connect_duration > 0 && connect_duration < 30000) {



    log += F(" Duration: ");

    log += connect_duration;

    log += F(" ms");

  }

  addLog(LOG_LEVEL_INFO, log);

  if (Settings.UseRules && bssid_changed) {

    String event = F("WiFi#ChangedAccesspoint");

    rulesProcessing(event);

  }

  if (useStaticIP()) {

    setupStaticIPconfig();

    markGotIP();

  }

  logConnectionStatus();

}



void processDisconnect() {

  if (processedDisconnect) return;

  processedDisconnect = true;

  if (Settings.UseRules) {

    String event = F("WiFi#Disconnected");

    rulesProcessing(event);

  }

  String log = F("WIFI : Disconnected! Reason: '");

  log += getLastDisconnectReason();

  log += F("'");

  if (lastConnectedDuration > 0) {

    log += F(" Connected for ");

    log += format_msec_duration(lastConnectedDuration);

  }

  addLog(LOG_LEVEL_INFO, log);

  logConnectionStatus();

}





void processGotIP() {

  if (processedGetIP)

    return;

  IPAddress ip = WiFi.localIP();

  if (!useStaticIP())

    if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0)

      return;

  processedGetIP = true;

  const IPAddress gw = WiFi.gatewayIP();

  const IPAddress subnet = WiFi.subnetMask();

  String log = F("WIFI : ");

  if (useStaticIP()) {

    log += F("Static IP: ");

  } else {

    log += F("DHCP IP: ");

  }

  log += formatIP(ip);

  log += F(" (");

  log += WifiGetHostname();

  log += F(") GW: ");

  log += formatIP(gw);

  log += F(" SN: ");

  log += formatIP(subnet);



  const long dhcp_duration = timeDiff(lastConnectMoment, lastGetIPmoment);

  if (dhcp_duration > 0 && dhcp_duration < 30000) {



    log += F("   duration: ");

    log += dhcp_duration;

    log += F(" ms");

  }

  addLog(LOG_LEVEL_INFO, log);





  if (Settings.IP_Octet != 0 && Settings.IP_Octet != 255)

  {

    ip[3] = Settings.IP_Octet;

    log = F("IP   : Fixed IP octet:");

    log += formatIP(ip);

    addLog(LOG_LEVEL_INFO, log);

    WiFi.config(ip, gw, subnet);

  }



  #ifdef FEATURE_MDNS



    log = F("WIFI : ");

    if (MDNS.begin(WifiGetHostname().c_str(), WiFi.localIP())) {



      log += F("mDNS started, with name: ");

      log += WifiGetHostname();

      log += F(".local");

    }

    else{

      log += F("mDNS failed");

    }

    addLog(LOG_LEVEL_INFO, log);

  #endif





  if (Settings.UseNTP) {

    initTime();

  }

  mqtt_reconnect_count = 0;

  timermqtt_interval = 100;

  timermqtt = millis() + timermqtt_interval;

  if (Settings.UseRules)

  {

    String event = F("WiFi#Connected");

    rulesProcessing(event);

  }

  statusLED(true);



  wifiStatus = ESPEASY_WIFI_SERVICES_INITIALIZED;

  setWebserverRunning(true);

  wifi_connect_attempt = 0;

  if (wifiSetup) {



    wifiSetup = false;

    SaveSettings();

  }

  logConnectionStatus();

}



void processConnectAPmode() {

  if (processedConnectAPmode) return;

  processedConnectAPmode = true;

  String log = F("AP Mode: Client connected: ");

  log += formatMAC(lastMacConnectedAPmode);

  log += F(" Connected devices: ");

  log += WiFi.softAPgetStationNum();

  addLog(LOG_LEVEL_INFO, log);

  timerAPoff = 0;

  setWebserverRunning(true);







  if (!dnsServerActive) {

    dnsServerActive = true;

    dnsServer.start(DNS_PORT, "*", apIP);

  }

}



void processDisconnectAPmode() {

  if (processedDisconnectAPmode) return;

  processedDisconnectAPmode = true;

  const int nrStationsConnected = WiFi.softAPgetStationNum();

  String log = F("AP Mode: Client disconnected: ");

  log += formatMAC(lastMacDisconnectedAPmode);

  log += F(" Connected devices: ");

  log += nrStationsConnected;

  addLog(LOG_LEVEL_INFO, log);

  if (nrStationsConnected == 0) {

    timerAPoff = millis() + WIFI_AP_OFF_TIMER_DURATION;

  }

}



void processDisableAPmode() {

  if (timerAPoff == 0) return;

  if (WifiIsAP(WiFi.getMode())) {



    if (timeOutReached(timerAPoff)) {

      setAP(false);

    }

  }

}



void processScanDone() {

  if (processedScanDone) return;

  processedScanDone = true;

  String log = F("WIFI  : Scan finished, found: ");

  log += scan_done_number;

  addLog(LOG_LEVEL_INFO, log);



  int bestScanID = -1;

  int32_t bestRssi = -1000;

  uint8_t bestWiFiSettings = lastWiFiSettings;

  if (selectValidWiFiSettings()) {

    bool done = false;

    String lastWiFiSettingsSSID = getLastWiFiSettingsSSID();

    for (int settingNr = 0; !done && settingNr < 2; ++settingNr) {

      for (int i = 0; i < scan_done_number; ++i) {

        if (WiFi.SSID(i) == lastWiFiSettingsSSID) {

          int32_t rssi = WiFi.RSSI(i);

          if (bestRssi < rssi) {

            bestRssi = rssi;

            bestScanID = i;

            bestWiFiSettings = lastWiFiSettings;

          }

        }

      }

      if (!selectNextWiFiSettings()) done = true;

    }

    if (bestScanID >= 0) {

      log = F("WIFI  : Selected: ");

      log += formatScanResult(bestScanID, " ");

      addLog(LOG_LEVEL_INFO, log);

      lastWiFiSettings = bestWiFiSettings;

      uint8_t * scanbssid = WiFi.BSSID(bestScanID);

      if (scanbssid) {

        for (int i = 0; i < 6 ; ++i) {

          lastBSSID[i] = *(scanbssid + i);

        }

      }

    }

  }

}



void resetWiFi() {

  addLog(LOG_LEVEL_INFO, F("Reset WiFi."));

  setWifiMode(WIFI_OFF);

  setWifiMode(WIFI_STA);

  lastDisconnectMoment = millis();

  processedDisconnect = false;

  wifiStatus = ESPEASY_WIFI_DISCONNECTED;

}



void WifiScanAsync() {

  addLog(LOG_LEVEL_INFO, F("WIFI  : Start network scan"));

  #ifdef ESP32

    bool async = true;

    bool show_hidden = false;

    bool passive = false;

    uint32_t max_ms_per_chan = 300;

    WiFi.scanNetworks(async, show_hidden, passive, max_ms_per_chan);

  #else





  #endif

}
# 521 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
bool WifiIsAP(WiFiMode_t wifimode)

{

  #if defined(ESP32)

    return (wifimode == WIFI_MODE_AP) || (wifimode == WIFI_MODE_APSTA);

  #else

    return (wifimode == WIFI_AP) || (wifimode == WIFI_AP_STA);

  #endif

}



bool WifiIsSTA(WiFiMode_t wifimode)

{

  #if defined(ESP32)

    return ((wifimode & WIFI_MODE_STA) != 0);

  #else

    return ((wifimode & WIFI_STA) != 0);

  #endif

}
# 565 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
void setSTA(bool enable) {

  switch(WiFi.getMode()) {

    case WIFI_OFF:

      if (enable) setWifiMode(WIFI_STA);

      break;

    case WIFI_STA:

      if (!enable) setWifiMode(WIFI_OFF);

      break;

    case WIFI_AP:

      if (enable) setWifiMode(WIFI_AP_STA);

      break;

    case WIFI_AP_STA:

      if (!enable) setWifiMode(WIFI_AP);

      break;

    default:

      break;

  }

}



void setAP(bool enable) {

  switch(WiFi.getMode()) {

    case WIFI_OFF:

      if (enable) setWifiMode(WIFI_AP);

      break;

    case WIFI_STA:

      if (enable) setWifiMode(WIFI_AP_STA);

      break;

    case WIFI_AP:

      if (!enable) setWifiMode(WIFI_OFF);

      break;

    case WIFI_AP_STA:

      if (!enable) setWifiMode(WIFI_STA);

      break;

    default:

      break;

  }

  if (enable) {

    timerAPoff = millis() + WIFI_AP_OFF_TIMER_DURATION;





    String softAPSSID=WifiGetAPssid();

    String pwd = SecuritySettings.WifiAPKey;

    IPAddress subnet(DEFAULT_AP_SUBNET);

    if (!WiFi.softAPConfig(apIP, apIP, subnet)) {

      addLog(LOG_LEVEL_ERROR, F("WIFI : [AP] softAPConfig failed!"));

    }

    if (WiFi.softAP(softAPSSID.c_str(),pwd.c_str())) {

      String log(F("WIFI : AP Mode ssid will be "));

      log += softAPSSID;

      log += F(" with address ");

      log += WiFi.softAPIP().toString();

      addLog(LOG_LEVEL_INFO, log);

    } else {

      String log(F("WIFI : Error while starting AP Mode with SSID: "));

      log += softAPSSID;

      log += F(" IP: ");

      log += apIP.toString();

      addLog(LOG_LEVEL_ERROR, log);

    }

    #ifdef ESP32



    #else

      if(wifi_softap_dhcps_status() != DHCP_STARTED) {

        if(!wifi_softap_dhcps_start()) {

          addLog(LOG_LEVEL_ERROR, F("WIFI : [AP] wifi_softap_dhcps_start failed!"));

        }

      }

    #endif

  } else {

    timerAPoff = 0;

    if (dnsServerActive) {

      dnsServerActive = false;

      dnsServer.stop();

    }

  }

}





void setWifiMode(WiFiMode_t wifimode) {

  if (WiFi.getMode() == wifimode) {

    return;

  }

  switch (wifimode) {

    case WIFI_OFF:

      addLog(LOG_LEVEL_INFO, F("WIFI : Switch off WiFi"));

      break;

    case WIFI_STA:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to STA"));

      break;

    case WIFI_AP:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to AP"));

      break;

    case WIFI_AP_STA:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to AP+STA"));

      break;

    default:

      break;

  }

  setUseStaticIP(useStaticIP());

  WiFi.mode(wifimode);

  delay(30);

}
# 779 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
String WifiGetAPssid()

{

  String ssid(Settings.Name);

  ssid+=F("_");

  ssid+=Settings.Unit;

  return (ssid);

}
# 801 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
String WifiGetHostname()

{

  String hostname(WifiGetAPssid());

  hostname.replace(F(" "), F("-"));

  hostname.replace(F("_"), F("-"));

  return (hostname);

}





bool useStaticIP() {

  return (Settings.IP[0] != 0 && Settings.IP[0] != 255);

}



bool WiFiConnected() {



  return wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED;

}



void WiFiConnectRelaxed() {

  if (WiFiConnected())

    return;

  if (prepareWiFi()) {

    if (selectValidWiFiSettings()) {

      tryConnectWiFi();

      return;

    }

  }

  addLog(LOG_LEVEL_ERROR, F("WIFI : Could not connect to AP!"));



  setAP(true);

}
# 871 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
bool prepareWiFi() {

  if (!selectValidWiFiSettings()) {

    addLog(LOG_LEVEL_ERROR, F("WIFI : No valid wifi settings"));

    return false;

  }

  setSTA(true);

  String log = "";

  char hostname[40];

  strncpy(hostname, WifiGetHostname().c_str(), sizeof(hostname));

  #if defined(ESP8266)

    wifi_station_set_hostname(hostname);

  #endif

  #if defined(ESP32)

    WiFi.setHostname(hostname);

  #endif

  return true;

}
# 915 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
const char* getLastWiFiSettingsSSID() {

  return lastWiFiSettings == 0 ? SecuritySettings.WifiSSID : SecuritySettings.WifiSSID2;

}



const char* getLastWiFiSettingsPassphrase() {

  return lastWiFiSettings == 0 ? SecuritySettings.WifiKey : SecuritySettings.WifiKey2;

}



bool selectNextWiFiSettings() {

  uint8_t tmp = lastWiFiSettings;

  lastWiFiSettings = (lastWiFiSettings + 1) % 2;

  if (!wifiSettingsValid(getLastWiFiSettingsSSID(), getLastWiFiSettingsPassphrase())) {



    lastWiFiSettings = tmp;

    return false;

  }

  return true;

}



bool selectValidWiFiSettings() {

  if (wifiSettingsValid(getLastWiFiSettingsSSID(), getLastWiFiSettingsPassphrase()))

    return true;

  return selectNextWiFiSettings();

}



bool wifiSettingsValid(const char* ssid, const char* pass) {

  if (ssid[0] == 0 || (strcasecmp(ssid, "ssid") == 0)) {

    return false;

  }



  if (strlen(ssid) > 32) return false;

  if (strlen(pass) > 64) return false;

  return true;

}



bool wifiConnectTimeoutReached() {

  if (wifi_connect_attempt == 0) return true;

  if (timeDiff(last_wifi_connect_attempt_moment, lastDisconnectMoment) >0 ) {



    return true;

  }

  if (WifiIsAP(WiFi.getMode())) {



    return timeOutReached(last_wifi_connect_attempt_moment + 20000);

  }





  #if defined(ESP8266)

  const unsigned int randomOffset_in_sec = wifi_connect_attempt == 1 ? 0 : 1000 * ((ESP.getChipId() & 0xF));

  #endif

  #if defined(ESP32)

  const unsigned int randomOffset_in_sec = wifi_connect_attempt == 1 ? 0 : 1000 * ((ESP.getEfuseMac() & 0xF));

  #endif

  return timeOutReached(last_wifi_connect_attempt_moment + DEFAULT_WIFI_CONNECTION_TIMEOUT + randomOffset_in_sec);

}



void setupStaticIPconfig() {

  setUseStaticIP(useStaticIP());

  if (!useStaticIP()) return;

  const IPAddress ip = Settings.IP;

  const IPAddress gw = Settings.Gateway;

  const IPAddress subnet = Settings.Subnet;

  const IPAddress dns = Settings.DNS;

  String log = F("IP   : Static IP : ");

  log += formatIP(ip);

  log += F(" GW: ");

  log += formatIP(gw);

  log += F(" SN: ");

  log += formatIP(subnet);

  log += F(" DNS: ");

  log += formatIP(dns);

  addLog(LOG_LEVEL_INFO, log);

  WiFi.config(ip, gw, subnet, dns);

}
# 1071 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
bool tryConnectWiFi() {

  if (wifiSetupConnect) {

    lastWiFiSettings = 0;

    wifi_connect_attempt = 0;

  }

  if (wifiStatus != ESPEASY_WIFI_DISCONNECTED) {

    if (!WifiIsAP(WiFi.getMode())) {



      return(true);

    }

  }

  if (!wifiConnectTimeoutReached())

    return true;

  if (!selectValidWiFiSettings()) {

    addLog(LOG_LEVEL_ERROR, F("WIFI : No valid WiFi settings!"));

    return false;

  }

  if (wifi_connect_attempt != 0 && (wifi_connect_attempt % 2) == 0) {

    selectNextWiFiSettings();

  }

  if (wifi_connect_attempt > 5) {

    setAP(true);

  }

  const char* ssid = getLastWiFiSettingsSSID();

  const char* passphrase = getLastWiFiSettingsPassphrase();

  String log = F("WIFI : Connecting ");

  log += ssid;

  log += F(" attempt #");

  log += wifi_connect_attempt;

  addLog(LOG_LEVEL_INFO, log);

  setupStaticIPconfig();

  last_wifi_connect_attempt_moment = millis();

  switch (wifi_connect_attempt) {

    case 0:

      if (lastBSSID[0] == 0)

        WiFi.begin(ssid, passphrase);

      else

        WiFi.begin(ssid, passphrase, 0, &lastBSSID[0]);

      break;

    default:

      WiFi.begin(ssid, passphrase);

  }

  ++wifi_connect_attempt;

  logConnectionStatus();

  switch (WiFi.status()) {

    case WL_NO_SSID_AVAIL: {

      log = F("WIFI : No SSID found matching: ");

      log += ssid;

      addLog(LOG_LEVEL_INFO, log);

      return false;

    }

    case WL_CONNECT_FAILED: {

      log = F("WIFI : Connection failed to: ");

      log += ssid;

      addLog(LOG_LEVEL_INFO, log);

      return false;

    }

    default:

     break;

  }

  return true;

}
# 1203 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
void WifiDisconnect()

{

  #if defined(ESP32)

    WiFi.disconnect();

  #else

    ETS_UART_INTR_DISABLE();

    wifi_station_disconnect();

    ETS_UART_INTR_ENABLE();

  #endif

}
# 1233 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
void WifiScan()

{



  Serial.println(F("WIFI : SSID Scan start"));

  int n = WiFi.scanNetworks(false, true);

  if (n == 0)

    Serial.println(F("WIFI : No networks found"));

  else

  {

    Serial.print(F("WIFI : "));

    Serial.print(n);

    Serial.println(F(" networks found"));

    for (int i = 0; i < n; ++i)

    {



      Serial.print(F("WIFI : "));

      Serial.print(i + 1);

      Serial.print(": ");

      Serial.println(formatScanResult(i, " "));

      delay(10);

    }

  }

  Serial.println("");

}



String formatScanResult(int i, const String& separator) {

  String result = WiFi.SSID(i);

  #ifndef ESP32

  if (WiFi.isHidden(i)) {

    result += F("#Hidden#");

  }

  #endif

  result += separator;

  result += WiFi.BSSIDstr(i);

  result += separator;

  result += F("Ch:");

  result += WiFi.channel(i);

  result += F(" (");

  result += WiFi.RSSI(i);

  result += F("dBm) ");

  switch (WiFi.encryptionType(i)) {

  #ifdef ESP32

    case WIFI_AUTH_OPEN: result += F("open"); break;

    case WIFI_AUTH_WEP: result += F("WEP"); break;

    case WIFI_AUTH_WPA_PSK: result += F("WPA/PSK"); break;

    case WIFI_AUTH_WPA2_PSK: result += F("WPA2/PSK"); break;

    case WIFI_AUTH_WPA_WPA2_PSK: result += F("WPA/WPA2/PSK"); break;

    case WIFI_AUTH_WPA2_ENTERPRISE: result += F("WPA2 Enterprise"); break;

  #else

    case ENC_TYPE_WEP: result += F("WEP"); break;

    case ENC_TYPE_TKIP: result += F("WPA/PSK"); break;

    case ENC_TYPE_CCMP: result += F("WPA2/PSK"); break;

    case ENC_TYPE_NONE: result += F("open"); break;

    case ENC_TYPE_AUTO: result += F("WPA/WPA2/PSK"); break;

  #endif

    default:

      break;

  }

  return result;

}



#ifndef ESP32

String SDKwifiStatusToString(uint8_t sdk_wifistatus) {

  switch (sdk_wifistatus) {

    case STATION_IDLE: return F("STATION_IDLE");

    case STATION_CONNECTING: return F("STATION_CONNECTING");

    case STATION_WRONG_PASSWORD: return F("STATION_WRONG_PASSWORD");

    case STATION_NO_AP_FOUND: return F("STATION_NO_AP_FOUND");

    case STATION_CONNECT_FAIL: return F("STATION_CONNECT_FAIL");

    case STATION_GOT_IP: return F("STATION_GOT_IP");

  }

  return F("Unknown");

}

#endif



String ArduinoWifiStatusToString(uint8_t arduino_corelib_wifistatus) {

  String log;

  switch (arduino_corelib_wifistatus) {

    case WL_IDLE_STATUS: log += F("WL_IDLE_STATUS"); break;

    case WL_NO_SSID_AVAIL: log += F("WL_NO_SSID_AVAIL"); break;

    case WL_SCAN_COMPLETED: log += F("WL_SCAN_COMPLETED"); break;

    case WL_CONNECTED: log += F("WL_CONNECTED"); break;

    case WL_CONNECT_FAILED: log += F("WL_CONNECT_FAILED"); break;

    case WL_CONNECTION_LOST: log += F("WL_CONNECTION_LOST"); break;

    case WL_DISCONNECTED: log += F("WL_DISCONNECTED"); break;

    default: log += arduino_corelib_wifistatus; break;

  }

  return log;

}



String ESPeasyWifiStatusToString() {

  String log;

  switch (wifiStatus) {

    case ESPEASY_WIFI_DISCONNECTED: log += F("ESPEASY_WIFI_DISCONNECTED"); break;

    case ESPEASY_WIFI_CONNECTED: log += F("ESPEASY_WIFI_CONNECTED"); break;

    case ESPEASY_WIFI_GOT_IP: log += F("ESPEASY_WIFI_GOT_IP"); break;

    case ESPEASY_WIFI_SERVICES_INITIALIZED: log += F("ESPEASY_WIFI_SERVICES_INITIALIZED"); break;

    default: log += wifiStatus;

  }

  return log;

}



void logConnectionStatus() {

  const uint8_t arduino_corelib_wifistatus = WiFi.status();

  String log;

  #ifndef ESP32

  const uint8_t sdk_wifistatus = wifi_station_get_connect_status();

  if ((arduino_corelib_wifistatus == WL_CONNECTED) != (sdk_wifistatus == STATION_GOT_IP)) {

    log = F("WIFI  : SDK station status differs from Arduino status. SDK-status: ");

    log += SDKwifiStatusToString(sdk_wifistatus);

    log += F(" Arduino status: ");

    log += ArduinoWifiStatusToString(arduino_corelib_wifistatus);

    addLog(LOG_LEVEL_ERROR, log);

  }

  #endif

  log = F("WIFI  : Arduino wifi status: ");

  log += ArduinoWifiStatusToString(arduino_corelib_wifistatus);

  log += F(" ESPeasy internal wifi status: ");

  log += ESPeasyWifiStatusToString();

  addLog(LOG_LEVEL_DEBUG_MORE, log);

}
# 1485 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
void WifiCheck()

{

  if(wifiSetup)

    return;



  processDisableAPmode();

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    if (timeOutReached(last_wifi_connect_attempt_moment + (1000 + wifi_connect_attempt * 200))) {

      WiFiConnectRelaxed();

    }

  }

  if (mqtt_reconnect_count > 10) {

    connectionCheckHandler();

  }

}
# 1523 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/ESPEasyWifi.ino"
bool getSubnetRange(IPAddress& low, IPAddress& high)

{

  if (WifiIsAP(WiFi.getMode())) {



    return false;

  }

  if (wifiStatus < ESPEASY_WIFI_GOT_IP) {

    return false;

  }

  const IPAddress ip = WiFi.localIP();

  const IPAddress subnet = WiFi.subnetMask();

  low = ip;

  high = ip;



  for (byte i=0; i < 4; ++i) {

    if (subnet[i] != 255) {

      low[i] = low[i] & subnet[i];

      high[i] = high[i] | ~subnet[i];

    }

  }

  return true;

}





String getLastDisconnectReason() {

  String reason = F("(");

  reason += lastDisconnectReason;

  reason += F(") ");

  switch (lastDisconnectReason) {

    case WIFI_DISCONNECT_REASON_UNSPECIFIED: reason += F("Unspecified"); break;

    case WIFI_DISCONNECT_REASON_AUTH_EXPIRE: reason += F("Auth expire"); break;

    case WIFI_DISCONNECT_REASON_AUTH_LEAVE: reason += F("Auth leave"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_EXPIRE: reason += F("Assoc expire"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_TOOMANY: reason += F("Assoc toomany"); break;

    case WIFI_DISCONNECT_REASON_NOT_AUTHED: reason += F("Not authed"); break;

    case WIFI_DISCONNECT_REASON_NOT_ASSOCED: reason += F("Not assoced"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_LEAVE: reason += F("Assoc leave"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_NOT_AUTHED: reason += F("Assoc not authed"); break;

    case WIFI_DISCONNECT_REASON_DISASSOC_PWRCAP_BAD: reason += F("Disassoc pwrcap bad"); break;

    case WIFI_DISCONNECT_REASON_DISASSOC_SUPCHAN_BAD: reason += F("Disassoc supchan bad"); break;

    case WIFI_DISCONNECT_REASON_IE_INVALID: reason += F("IE invalid"); break;

    case WIFI_DISCONNECT_REASON_MIC_FAILURE: reason += F("Mic failure"); break;

    case WIFI_DISCONNECT_REASON_4WAY_HANDSHAKE_TIMEOUT: reason += F("4way handshake timeout"); break;

    case WIFI_DISCONNECT_REASON_GROUP_KEY_UPDATE_TIMEOUT: reason += F("Group key update timeout"); break;

    case WIFI_DISCONNECT_REASON_IE_IN_4WAY_DIFFERS: reason += F("IE in 4way differs"); break;

    case WIFI_DISCONNECT_REASON_GROUP_CIPHER_INVALID: reason += F("Group cipher invalid"); break;

    case WIFI_DISCONNECT_REASON_PAIRWISE_CIPHER_INVALID: reason += F("Pairwise cipher invalid"); break;

    case WIFI_DISCONNECT_REASON_AKMP_INVALID: reason += F("AKMP invalid"); break;

    case WIFI_DISCONNECT_REASON_UNSUPP_RSN_IE_VERSION: reason += F("Unsupp RSN IE version"); break;

    case WIFI_DISCONNECT_REASON_INVALID_RSN_IE_CAP: reason += F("Invalid RSN IE cap"); break;

    case WIFI_DISCONNECT_REASON_802_1X_AUTH_FAILED: reason += F("802 1X auth failed"); break;

    case WIFI_DISCONNECT_REASON_CIPHER_SUITE_REJECTED: reason += F("Cipher suite rejected"); break;

    case WIFI_DISCONNECT_REASON_BEACON_TIMEOUT: reason += F("Beacon timeout"); break;

    case WIFI_DISCONNECT_REASON_NO_AP_FOUND: reason += F("No AP found"); break;

    case WIFI_DISCONNECT_REASON_AUTH_FAIL: reason += F("Auth fail"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_FAIL: reason += F("Assoc fail"); break;

    case WIFI_DISCONNECT_REASON_HANDSHAKE_TIMEOUT: reason += F("Handshake timeout"); break;

    default: reason += F("Unknown"); break;

  }

  return reason;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Hardware.ino"
# 9 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Hardware.ino"
void hardwareInit()

{





  for (byte x=0; x < 17; x++)

    if (Settings.PinBootStates[x] != 0)

      switch(Settings.PinBootStates[x])

      {

        case 1:

          pinMode(x,OUTPUT);

          digitalWrite(x,LOW);

          setPinState(1, x, PIN_MODE_OUTPUT, LOW);

          break;

        case 2:

          pinMode(x,OUTPUT);

          digitalWrite(x,HIGH);

          setPinState(1, x, PIN_MODE_OUTPUT, HIGH);

          break;

        case 3:

          pinMode(x,INPUT_PULLUP);

          setPinState(1, x, PIN_MODE_INPUT, 0);

          break;

      }



  if (Settings.Pin_Reset != -1)

    pinMode(Settings.Pin_Reset,INPUT_PULLUP);





  if (Settings.Pin_i2c_sda != -1)

  {

    String log = F("INIT : I2C");

    addLog(LOG_LEVEL_INFO, log);

    Wire.begin(Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

      if(Settings.WireClockStretchLimit)

      {

        String log = F("INIT : I2C custom clockstretchlimit:");

        log += Settings.WireClockStretchLimit;

        addLog(LOG_LEVEL_INFO, log);

        #if defined(ESP8266)

          Wire.setClockStretchLimit(Settings.WireClockStretchLimit);

        #endif

      }

  }





  if (Settings.WDI2CAddress != 0)

  {

    delay(500);

    Wire.beginTransmission(Settings.WDI2CAddress);

    Wire.write(0x83);

    Wire.write(17);

    Wire.endTransmission();



    Wire.requestFrom(Settings.WDI2CAddress, (uint8_t)1);

    if (Wire.available())

    {

      byte status = Wire.read();

      if (status & 0x1)

      {

        String log = F("INIT : Reset by WD!");

        addLog(LOG_LEVEL_ERROR, log);

        lastBootCause = BOOT_CAUSE_EXT_WD;

      }

    }

  }





  if (Settings.InitSPI)

  {

    SPI.setHwCs(false);

    SPI.begin();

    String log = F("INIT : SPI Init (without CS)");

    addLog(LOG_LEVEL_INFO, log);

  }

  else

  {

    String log = F("INIT : SPI not enabled");

    addLog(LOG_LEVEL_INFO, log);

  }



#ifdef FEATURE_SD

  if (Settings.Pin_sd_cs >= 0)

  {

    if (SD.begin(Settings.Pin_sd_cs))

    {

      String log = F("SD   : Init OK");

      addLog(LOG_LEVEL_INFO, log);

    }

    else

    {

      String log = F("SD   : Init failed");

      addLog(LOG_LEVEL_ERROR, log);

    }

  }

#endif



}



void checkResetFactoryPin(){

  static byte factoryResetCounter=0;

  if (Settings.Pin_Reset == -1)

    return;



  if (digitalRead(Settings.Pin_Reset) == 0){

    factoryResetCounter++;

  }

  else

  {

    if (factoryResetCounter > 9)

      ResetFactory();

    if (factoryResetCounter > 3)

    #if defined(ESP8266)

      ESP.reset();

    #endif

    #if defined(ESP32)

      ESP.restart();

    #endif



    factoryResetCounter = 0;

  }

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#if defined(ESP8266)

  #include <md5.h>

#endif

#if defined(ESP8266)



struct tcp_pcb;

extern struct tcp_pcb* tcp_tw_pcbs;

extern "C" void tcp_abort (struct tcp_pcb* pcb);



void tcpCleanup()

{



     while(tcp_tw_pcbs!=NULL)

    {

      tcp_abort(tcp_tw_pcbs);

    }



 }

#endif



bool isDeepSleepEnabled()

{

  if (!Settings.deepSleep)

    return false;
# 69 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
  pinMode(16,INPUT_PULLUP);

  if (!digitalRead(16))

  {

    return false;

  }

  return true;

}



bool readyForSleep()

{

  if (!isDeepSleepEnabled())

    return false;

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {



    return timeOutReached(timerAwakeFromDeepSleep + 6000);

  }

  return timeOutReached(timerAwakeFromDeepSleep + 1000 * Settings.deepSleep);

}



void deepSleep(int delay)

{



  checkRAM(F("deepSleep"));

  if (!isDeepSleepEnabled())

  {



    return;

  }





  if (lastBootCause!=BOOT_CAUSE_DEEP_SLEEP)

  {

    addLog(LOG_LEVEL_INFO, F("SLEEP: Entering deep sleep in 30 seconds."));

    delayBackground(30000);



    if (!isDeepSleepEnabled())

    {

      addLog(LOG_LEVEL_INFO, F("SLEEP: Deep sleep cancelled (GPIO16 connected to GND)"));

      return;

    }

  }



  deepSleepStart(delay);

}



void deepSleepStart(int delay)

{



  String event = F("System#Sleep");

  rulesProcessing(event);





  RTC.deepSleepState = 1;

  saveToRTC();



  if (delay > 4294 || delay < 0)

    delay = 4294;



  addLog(LOG_LEVEL_INFO, F("SLEEP: Powering down to deepsleep..."));

  #if defined(ESP8266)

    ESP.deepSleep((uint32_t)delay * 1000000, WAKE_RF_DEFAULT);

  #endif

  #if defined(ESP32)

    esp_sleep_enable_timer_wakeup((uint32_t)delay * 1000000);

    esp_deep_sleep_start();

  #endif

}



boolean remoteConfig(struct EventStruct *event, String& string)

{

  checkRAM(F("remoteConfig"));

  boolean success = false;

  String command = parseString(string, 1);



  if (command == F("config"))

  {

    success = true;

    if (parseString(string, 2) == F("task"))

    {

      int configCommandPos1 = getParamStartPos(string, 3);

      int configCommandPos2 = getParamStartPos(string, 4);



      String configTaskName = string.substring(configCommandPos1, configCommandPos2 - 1);

      String configCommand = string.substring(configCommandPos2);



      int8_t index = getTaskIndexByName(configTaskName);

      if (index != -1)

      {

        event->TaskIndex = index;

        success = PluginCall(PLUGIN_SET_CONFIG, event, configCommand);

      }

    }

  }

  return success;

}



int8_t getTaskIndexByName(String TaskNameSearch)

{



  for (byte x = 0; x < TASKS_MAX; x++)

  {

    LoadTaskSettings(x);

    String TaskName = ExtraTaskSettings.TaskDeviceName;

    if ((ExtraTaskSettings.TaskDeviceName[0] != 0 ) && (TaskNameSearch.equalsIgnoreCase(TaskName)))

    {

      return x;

    }

  }

  return -1;

}





void flashCount()

{

  if (RTC.flashDayCounter <= MAX_FLASHWRITES_PER_DAY)

    RTC.flashDayCounter++;

  RTC.flashCounter++;

  saveToRTC();

}



String flashGuard()

{

  checkRAM(F("flashGuard"));

  if (RTC.flashDayCounter > MAX_FLASHWRITES_PER_DAY)

  {

    String log = F("FS   : Daily flash write rate exceeded! (powercycle to reset this)");

    addLog(LOG_LEVEL_ERROR, log);

    return log;

  }

  flashCount();

  return(String());

}





#define FLASH_GUARD() { String flashErr=flashGuard(); if (flashErr.length()) return(flashErr); }
# 349 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void setPinState(byte plugin, byte index, byte mode, uint16_t value)

{





  boolean reUse = false;

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      pinStates[x].mode = mode;

      pinStates[x].value = value;

      reUse = true;

      break;

    }



  if (!reUse)

  {

    for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

      if (pinStates[x].plugin == 0)

      {

        pinStates[x].plugin = plugin;

        pinStates[x].index = index;

        pinStates[x].mode = mode;

        pinStates[x].value = value;

        break;

      }

  }

}
# 413 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean getPinState(byte plugin, byte index, byte *mode, uint16_t *value)

{

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      *mode = pinStates[x].mode;

      *value = pinStates[x].value;

      return true;

    }

  return false;

}
# 445 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean hasPinState(byte plugin, byte index)

{

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      return true;

    }

  return false;

}
# 473 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String getPinStateJSON(boolean search, byte plugin, byte index, String& log, uint16_t noSearchValue)

{

  checkRAM(F("getPinStateJSON"));

  printToWebJSON = true;

  byte mode = PIN_MODE_INPUT;

  uint16_t value = noSearchValue;

  String reply = "";

  boolean found = false;



  if (search)

  {

    for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

      if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

      {

        mode = pinStates[x].mode;

        value = pinStates[x].value;

        found = true;

        break;

      }

  }



  if (!search || (search && found))

  {

    reply += F("{\n\"log\": \"");

    reply += log.substring(7, 32);

    reply += F("\",\n\"plugin\": ");

    reply += plugin;

    reply += F(",\n\"pin\": ");

    reply += index;

    reply += F(",\n\"mode\": \"");

    switch (mode)

    {

      case PIN_MODE_UNDEFINED:

        reply += F("undefined");

        break;

      case PIN_MODE_INPUT:

        reply += F("input");

        break;

      case PIN_MODE_OUTPUT:

        reply += F("output");

        break;

      case PIN_MODE_PWM:

        reply += F("PWM");

        break;

      case PIN_MODE_SERVO:

        reply += F("servo");

        break;

    }

    reply += F("\",\n\"state\": ");

    reply += value;

    reply += F("\n}\n");

    return reply;

  }

  return "?";

}
# 593 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#if defined(ESP32)

  #define PWMRANGE 1024

#endif

#define STATUS_PWM_NORMALVALUE (PWMRANGE>>2)

#define STATUS_PWM_NORMALFADE (PWMRANGE>>8)

#define STATUS_PWM_TRAFFICRISE (PWMRANGE>>1)



void statusLED(boolean traffic)

{

  static int gnStatusValueCurrent = -1;

  static long int gnLastUpdate = millis();



  if (Settings.Pin_status_led == -1)

    return;



  if (gnStatusValueCurrent<0)

    pinMode(Settings.Pin_status_led, OUTPUT);



  int nStatusValue = gnStatusValueCurrent;



  if (traffic)

  {

    nStatusValue += STATUS_PWM_TRAFFICRISE;

  }

  else

  {



    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

    {

      long int delta = timePassedSince(gnLastUpdate);

      if (delta>0 || delta<0 )

      {

        nStatusValue -= STATUS_PWM_NORMALFADE;

        nStatusValue = std::max(nStatusValue, STATUS_PWM_NORMALVALUE);

        gnLastUpdate=millis();

      }

    }



    else if (WifiIsAP(WiFi.getMode()))

    {

      nStatusValue = ((millis()>>1) & PWMRANGE) - (PWMRANGE>>2);

    }



    else

    {

      nStatusValue = (millis()>>1) & (PWMRANGE>>2);

    }

  }



  nStatusValue = constrain(nStatusValue, 0, PWMRANGE);



  if (gnStatusValueCurrent != nStatusValue)

  {

    gnStatusValueCurrent = nStatusValue;



    long pwm = nStatusValue * nStatusValue;

    pwm >>= 10;

    if (Settings.Pin_status_led_Inversed)

      pwm = PWMRANGE-pwm;



    #if defined(ESP8266)

      analogWrite(Settings.Pin_status_led, pwm);

    #endif

  }

}
# 733 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void delayBackground(unsigned long delay)

{

  unsigned long timer = millis() + delay;

  while (!timeOutReached(timer))

    backgroundtasks();

}
# 755 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void parseCommandString(struct EventStruct *event, const String& string)

{

  checkRAM(F("parseCommandString"));

  char command[80];

  command[0] = 0;

  char TmpStr1[80];

  TmpStr1[0] = 0;



  string.toCharArray(command, 80);

  event->Par1 = 0;

  event->Par2 = 0;

  event->Par3 = 0;

  event->Par4 = 0;

  event->Par5 = 0;



  if (GetArgv(command, TmpStr1, 2)) event->Par1 = str2int(TmpStr1);

  if (GetArgv(command, TmpStr1, 3)) event->Par2 = str2int(TmpStr1);

  if (GetArgv(command, TmpStr1, 4)) event->Par3 = str2int(TmpStr1);

  if (GetArgv(command, TmpStr1, 5)) event->Par4 = str2int(TmpStr1);

  if (GetArgv(command, TmpStr1, 6)) event->Par5 = str2int(TmpStr1);

}
# 805 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void taskClear(byte taskIndex, boolean save)

{

  checkRAM(F("taskClear"));

  Settings.TaskDeviceNumber[taskIndex] = 0;

  ExtraTaskSettings.TaskDeviceName[0] = 0;

  Settings.TaskDeviceDataFeed[taskIndex] = 0;

  Settings.TaskDevicePin1[taskIndex] = -1;

  Settings.TaskDevicePin2[taskIndex] = -1;

  Settings.TaskDevicePin3[taskIndex] = -1;

  Settings.TaskDevicePort[taskIndex] = 0;

  Settings.TaskDeviceGlobalSync[taskIndex] = false;

  Settings.TaskDeviceTimer[taskIndex] = 0;

  Settings.TaskDeviceEnabled[taskIndex] = false;



  for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

  {

    Settings.TaskDeviceID[controllerNr][taskIndex] = 0;

    Settings.TaskDeviceSendData[controllerNr][taskIndex] = true;

  }



  for (byte x = 0; x < PLUGIN_CONFIGVAR_MAX; x++)

    Settings.TaskDevicePluginConfig[taskIndex][x] = 0;



  for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

  {

    ExtraTaskSettings.TaskDeviceFormula[varNr][0] = 0;

    ExtraTaskSettings.TaskDeviceValueNames[varNr][0] = 0;

    ExtraTaskSettings.TaskDeviceValueDecimals[varNr] = 2;

  }



  for (byte varNr = 0; varNr < PLUGIN_EXTRACONFIGVAR_MAX; varNr++)

  {

    ExtraTaskSettings.TaskDevicePluginConfigLong[varNr] = 0;

    ExtraTaskSettings.TaskDevicePluginConfig[varNr] = 0;

  }



  if (save)

  {

    SaveTaskSettings(taskIndex);

    SaveSettings();

  }

}
# 899 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#define SPIFFS_CHECK(result,fname) if (!(result)) { return(FileError(__LINE__, fname)); }

String FileError(int line, const char * fname)

{

   String err = F("FS   : Error while reading/writing ");

   err += fname;

   err += F(" in ");

   err += line;

   addLog(LOG_LEVEL_ERROR, err);

   return(err);

}
# 929 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String BuildFixes()

{

  checkRAM(F("BuildFixes"));

  Serial.println(F("\nBuild changed!"));



  if (Settings.Build < 145)

  {

    String fname=F(FILE_NOTIFICATION);

    fs::File f = SPIFFS.open(fname, "w");

    SPIFFS_CHECK(f, fname.c_str());



    if (f)

    {

      for (int x = 0; x < 4096; x++)

      {

        SPIFFS_CHECK(f.write(0), fname.c_str());

      }

      f.close();

    }

  }



  if (Settings.Build < 20101)

  {

    Serial.println(F("Fix reset Pin"));

    Settings.Pin_Reset = -1;

  }

  if (Settings.Build < 20102) {





    Serial.println(F("Fix settings with uninitalized data or corrupted by switching between versions"));

    Settings.UseRTOSMultitasking = false;

    Settings.Pin_Reset = -1;

    Settings.SyslogFacility = DEFAULT_SYSLOG_FACILITY;

    Settings.StructSize = sizeof(Settings);

  }



  Settings.Build = BUILD;

  return(SaveSettings());

}
# 1017 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void fileSystemCheck()

{

  checkRAM(F("fileSystemCheck"));

  addLog(LOG_LEVEL_INFO, F("FS   : Mounting..."));

  if (SPIFFS.begin())

  {

    #if defined(ESP8266)

      fs::FSInfo fs_info;

      SPIFFS.info(fs_info);



      String log = F("FS   : Mount successful, used ");

      log=log+fs_info.usedBytes;

      log=log+F(" bytes of ");

      log=log+fs_info.totalBytes;

      addLog(LOG_LEVEL_INFO, log);

    #endif



    fs::File f = SPIFFS.open(FILE_CONFIG, "r");

    if (!f)

    {

      ResetFactory();

    }

    f.close();

  }

  else

  {

    String log = F("FS   : Mount failed");

    Serial.println(log);

    addLog(LOG_LEVEL_ERROR, log);

    ResetFactory();

  }

}
# 1091 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
byte getDeviceIndex(byte Number)

{

  for (byte x = 0; x <= deviceCount ; x++) {

    if (Device[x].Number == Number) {

      return x;

    }

  }

  return 0;

}
# 1117 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String getPluginNameFromDeviceIndex(byte deviceIndex) {

  String deviceName = "";

  Plugin_ptr[deviceIndex](PLUGIN_GET_DEVICENAME, 0, deviceName);

  return deviceName;

}
# 1137 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
byte getProtocolIndex(byte Number)

{

  for (byte x = 0; x <= protocolCount ; x++) {

    if (Protocol[x].Number == Number) {

      return x;

    }

  }

  return 0;

}
# 1163 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
byte getNotificationProtocolIndex(byte Number)

{

  for (byte x = 0; x <= notificationCount ; x++) {

    if (Notification[x].Number == Number) {

      return(x);

    }

  }

  return(NPLUGIN_NOT_FOUND);

}
# 1189 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean GetArgv(const char *string, char *argv, unsigned int argc)

{

  unsigned int string_pos = 0, argv_pos = 0, argc_pos = 0;

  char c, d;

  boolean parenthesis = false;



  while (string_pos < strlen(string))

  {

    c = string[string_pos];

    d = string[string_pos + 1];



    if (!parenthesis && c == ' ' && d == ' ') {}

    else if (!parenthesis && c == ' ' && d == ',') {}

    else if (!parenthesis && c == ',' && d == ' ') {}

    else if (!parenthesis && c == ' ' && d >= 33 && d <= 126) {}

    else if (!parenthesis && c == ',' && d >= 33 && d <= 126) {}

    else if (c == '"') {

      parenthesis = true;

    }

    else

    {

      argv[argv_pos++] = c;

      argv[argv_pos] = 0;



      if ((!parenthesis && (d == ' ' || d == ',' || d == 0)) || (parenthesis && d == '"'))

      {

        if (d == '"')

          parenthesis = false;

        argv[argv_pos] = 0;

        argc_pos++;



        if (argc_pos == argc)

        {

          return true;

        }



        argv[0] = 0;

        argv_pos = 0;

        string_pos++;

      }

    }

    string_pos++;

  }

  return false;

}
# 1313 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#if defined(ARDUINO_ESP8266_RELEASE_2_3_0)

void dump (uint32_t addr) {

  Serial.print (addr, HEX);

  Serial.print(": ");

  for (uint32_t a = addr; a < addr + 16; a++)

  {

    Serial.print ( pgm_read_byte(a), HEX);

    Serial.print (" ");

  }

  Serial.println("");

}

#endif



uint32_t progMemMD5check(){

    checkRAM(F("progMemMD5check"));

    #define BufSize 10

    uint32_t calcBuffer[BufSize];

    CRCValues.numberOfCRCBytes = 0;

    memcpy (calcBuffer,CRCValues.compileTimeMD5,16);

    if( memcmp (calcBuffer, "MD5_MD5_MD5_",12)==0){

        addLog(LOG_LEVEL_INFO, F("CRC  : No program memory checksum found. Check output of crc2.py"));

        return 0;

    }

    MD5Builder md5;

    md5.begin();

    for (int l = 0; l<4; l++){

        uint32_t *ptrStart = (uint32_t *)&CRCValues.compileTimeMD5[16+l*4];

        uint32_t *ptrEnd = (uint32_t *)&CRCValues.compileTimeMD5[16+4*4+l*4];

        if ((*ptrStart) == 0) break;

        for (uint32_t i = *ptrStart; i< (*ptrEnd) ; i=i+sizeof(calcBuffer)){

             for (int buf = 0; buf < BufSize; buf ++){

                calcBuffer[buf] = pgm_read_dword((uint32_t*)i+buf);

                CRCValues.numberOfCRCBytes+=sizeof(calcBuffer[0]);

             }

             md5.add((uint8_t *)&calcBuffer[0],(*ptrEnd-i)<sizeof(calcBuffer) ? (*ptrEnd-i):sizeof(calcBuffer) );

        }

   }

   md5.calculate();

   md5.getBytes(CRCValues.runTimeMD5);

   if ( CRCValues.checkPassed()) {

      addLog(LOG_LEVEL_INFO, F("CRC  : program checksum       ...OK"));

      return CRCValues.numberOfCRCBytes;

   }

   addLog(LOG_LEVEL_INFO, F("CRC  : program checksum       ...FAIL"));

   return 0;

}
# 1417 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveSettings(void)

{

  checkRAM(F("SaveSettings"));

  MD5Builder md5;

  uint8_t tmp_md5[16] = {0};

  String err;



  Settings.StructSize = sizeof(struct SettingsStruct);
# 1457 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
    err=SaveToFile((char*)FILE_CONFIG, 0, (byte*)&Settings, sizeof(Settings));

    if (err.length())

     return(err);





  memcpy( SecuritySettings.ProgmemMd5, CRCValues.runTimeMD5, 16);

  md5.begin();

  md5.add((uint8_t *)&SecuritySettings, sizeof(SecuritySettings)-16);

  md5.calculate();

  md5.getBytes(tmp_md5);

  if (memcmp(tmp_md5, SecuritySettings.md5, 16) != 0) {



    memcpy(SecuritySettings.md5, tmp_md5, 16);

    err=SaveToFile((char*)FILE_SECURITY, 0, (byte*)&SecuritySettings, sizeof(SecuritySettings));

    if (WifiIsAP(WiFi.getMode())) {



      wifiSetupConnect = true;

    }

  }

  return (err);

}
# 1507 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadSettings()

{

  checkRAM(F("LoadSettings"));

  String err;

  uint8_t calculatedMd5[16];

  MD5Builder md5;



  err=LoadFromFile((char*)FILE_CONFIG, 0, (byte*)&Settings, sizeof( SettingsStruct));

  if (err.length())

    return(err);
# 1565 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
  err=LoadFromFile((char*)FILE_SECURITY, 0, (byte*)&SecuritySettings, sizeof( SecurityStruct));

  md5.begin();

  md5.add((uint8_t *)&SecuritySettings, sizeof(SecuritySettings)-16);

  md5.calculate();

  md5.getBytes(calculatedMd5);

  if (memcmp (calculatedMd5, SecuritySettings.md5, 16)==0){

    addLog(LOG_LEVEL_INFO, F("CRC  : SecuritySettings CRC   ...OK "));

    if (memcmp(SecuritySettings.ProgmemMd5,CRCValues.runTimeMD5, 16)!=0)

      addLog(LOG_LEVEL_INFO, F("CRC  : binary has changed since last save of Settings"));

 }

  else{

    addLog(LOG_LEVEL_ERROR, F("CRC  : SecuritySettings CRC   ...FAIL"));

  }

  setUseStaticIP(useStaticIP());

  return(err);

}
# 1607 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveTaskSettings(byte TaskIndex)

{

  checkRAM(F("SaveTaskSettings"));

  if (DAT_TASKS_SIZE < sizeof(struct ExtraTaskSettingsStruct))

    return F("SaveTaskSettings too big");

  if (TaskIndex >= TASKS_MAX)

    return F("SaveTaskSettings TaskIndex too big");



  ExtraTaskSettings.TaskIndex = TaskIndex;

  return(SaveToFile((char*)FILE_CONFIG, DAT_OFFSET_TASKS + (TaskIndex * DAT_TASKS_SIZE), (byte*)&ExtraTaskSettings, sizeof(struct ExtraTaskSettingsStruct)));

}
# 1639 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadTaskSettings(byte TaskIndex)

{

  checkRAM(F("LoadTaskSettings"));



  if (ExtraTaskSettings.TaskIndex == TaskIndex)

    return(String());

  if (TaskIndex >= TASKS_MAX)

    return F("LoadTaskSettings TaskIndex too big");



  String result = "";

  result = LoadFromFile((char*)FILE_CONFIG, DAT_OFFSET_TASKS + (TaskIndex * DAT_TASKS_SIZE), (byte*)&ExtraTaskSettings, sizeof(struct ExtraTaskSettingsStruct));

  ExtraTaskSettings.TaskIndex = TaskIndex;

  return result;

}
# 1677 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize)

{

  checkRAM(F("SaveCustomTaskSettings"));

  if (datasize > DAT_TASKS_SIZE)

    return F("SaveCustomTaskSettings too big");

  if (TaskIndex >= TASKS_MAX)

    return F("SaveCustomTaskSettings TaskIndex too big");



  return(SaveToFile((char*)FILE_CONFIG, DAT_OFFSET_TASKS + (TaskIndex * DAT_TASKS_SIZE) + DAT_TASKS_CUSTOM_OFFSET, memAddress, datasize));

}
# 1707 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String ClearCustomTaskSettings(int TaskIndex)

{



  if (TaskIndex >= TASKS_MAX)

    return F("ClearCustomTaskSettings TaskIndex too big");

  return(ClearInFile((char*)FILE_CONFIG, DAT_OFFSET_TASKS + (TaskIndex * DAT_TASKS_SIZE) + DAT_TASKS_CUSTOM_OFFSET, DAT_TASKS_CUSTOM_SIZE));

}
# 1729 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize)

{

  checkRAM(F("LoadCustomTaskSettings"));

  if (datasize > DAT_TASKS_SIZE)

    return (String(F("LoadCustomTaskSettings too big")));

  if (TaskIndex >= TASKS_MAX)

    return F("LoadCustomTaskSettings TaskIndex too big");



  return(LoadFromFile((char*)FILE_CONFIG, DAT_OFFSET_TASKS + (TaskIndex * DAT_TASKS_SIZE) + DAT_TASKS_CUSTOM_OFFSET, memAddress, datasize));

}
# 1757 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveControllerSettings(int ControllerIndex, byte* memAddress, int datasize)

{

  checkRAM(F("SaveControllerSettings"));

  if (datasize > DAT_CONTROLLER_SIZE)

    return F("SaveControllerSettings too big");

  return SaveToFile((char*)FILE_CONFIG, DAT_OFFSET_CONTROLLER + (ControllerIndex * DAT_CONTROLLER_SIZE), memAddress, datasize);

}
# 1781 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadControllerSettings(int ControllerIndex, byte* memAddress, int datasize)

{

  checkRAM(F("LoadControllerSettings"));

  if (datasize > DAT_CONTROLLER_SIZE)

    return F("LoadControllerSettings too big");



  return(LoadFromFile((char*)FILE_CONFIG, DAT_OFFSET_CONTROLLER + (ControllerIndex * DAT_CONTROLLER_SIZE), memAddress, datasize));

}
# 1807 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String ClearCustomControllerSettings(int ControllerIndex)

{

  checkRAM(F("ClearCustomControllerSettings"));



  return(ClearInFile((char*)FILE_CONFIG, DAT_OFFSET_CUSTOM_CONTROLLER + (ControllerIndex * DAT_CUSTOM_CONTROLLER_SIZE), DAT_CUSTOM_CONTROLLER_SIZE));

}
# 1829 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize)

{

  checkRAM(F("SaveCustomControllerSettings"));

  if (datasize > DAT_CUSTOM_CONTROLLER_SIZE)

    return F("SaveCustomControllerSettings too big");

  return SaveToFile((char*)FILE_CONFIG, DAT_OFFSET_CUSTOM_CONTROLLER + (ControllerIndex * DAT_CUSTOM_CONTROLLER_SIZE), memAddress, datasize);

}
# 1853 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize)

{

  checkRAM(F("LoadCustomControllerSettings"));

  if (datasize > DAT_CUSTOM_CONTROLLER_SIZE)

    return(F("LoadCustomControllerSettings too big"));

  return(LoadFromFile((char*)FILE_CONFIG, DAT_OFFSET_CUSTOM_CONTROLLER + (ControllerIndex * DAT_CUSTOM_CONTROLLER_SIZE), memAddress, datasize));

}
# 1875 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveNotificationSettings(int NotificationIndex, byte* memAddress, int datasize)

{

  checkRAM(F("SaveNotificationSettings"));

  if (datasize > DAT_NOTIFICATION_SIZE)

    return F("SaveNotificationSettings too big");

  return SaveToFile((char*)FILE_NOTIFICATION, NotificationIndex * DAT_NOTIFICATION_SIZE, memAddress, datasize);

}
# 1899 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadNotificationSettings(int NotificationIndex, byte* memAddress, int datasize)

{

  checkRAM(F("LoadNotificationSettings"));

  if (datasize > DAT_NOTIFICATION_SIZE)

    return(F("LoadNotificationSettings too big"));

  return(LoadFromFile((char*)FILE_NOTIFICATION, NotificationIndex * DAT_NOTIFICATION_SIZE, memAddress, datasize));

}
# 1927 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String InitFile(const char* fname, int datasize)

{

  checkRAM(F("InitFile"));

  FLASH_GUARD();



  fs::File f = SPIFFS.open(fname, "w");

  SPIFFS_CHECK(f, fname);



  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(0), fname);

  }

  f.close();





  return String();

}
# 1969 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String SaveToFile(char* fname, int index, byte* memAddress, int datasize)

{

  checkRAM(F("SaveToFile"));

  FLASH_GUARD();

  String log = F("SaveToFile: ");

  log += fname;

  log += F(" index: ");

  log += index;

  log += F(" datasize: ");

  log += datasize;

  addLog(LOG_LEVEL_DEBUG, log);



  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);



  SPIFFS_CHECK(f.seek(index, fs::SeekSet), fname);

  byte *pointerToByteToSave = memAddress;

  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(*pointerToByteToSave), fname);

    pointerToByteToSave++;

  }

  f.close();

  log = F("FILE : Saved ");

  log=log+fname;

  addLog(LOG_LEVEL_INFO, log);





  return String();

}
# 2037 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String ClearInFile(char* fname, int index, int datasize)

{

  checkRAM(F("ClearInFile"));

  FLASH_GUARD();



  String log = F("ClearInFile: ");

  log += fname;

  log += F(" index: ");

  log += index;

  log += F(" datasize: ");

  log += datasize;

  addLog(LOG_LEVEL_DEBUG, log);





  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);



  SPIFFS_CHECK(f.seek(index, fs::SeekSet), fname);

  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(0), fname);

  }

  f.close();





  return String();



}
# 2101 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String LoadFromFile(char* fname, int index, byte* memAddress, int datasize)

{

  checkRAM(F("LoadFromFile"));

  String log = F("LoadFromFile: ");

  log += fname;

  log += F(" index: ");

  log += index;

  log += F(" datasize: ");

  log += datasize;

  addLog(LOG_LEVEL_DEBUG, log);



  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);

  SPIFFS_CHECK(f.seek(index, fs::SeekSet), fname);

  SPIFFS_CHECK(f.read(memAddress,datasize), fname);

  f.close();



  return(String());

}
# 2149 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
int SpiffsSectors()

{

  checkRAM(F("SpiffsSectors"));

  #if defined(ESP8266)

    uint32_t _sectorStart = ((uint32_t)&_SPIFFS_start - 0x40200000) / SPI_FLASH_SEC_SIZE;

    uint32_t _sectorEnd = ((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE;

    return _sectorEnd - _sectorStart;

  #endif

  #if defined(ESP32)

    return 32;

  #endif

}
# 2183 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void ResetFactory(void)

{



  checkRAM(F("ResetFactory"));



  Serial.println(F("RESET: Resetting factory defaults..."));

  delay(1000);

  if (readFromRTC())

  {

    Serial.print(F("RESET: Warm boot, reset count: "));

    Serial.println(RTC.factoryResetCounter);

    if (RTC.factoryResetCounter >= 3)

    {

      Serial.println(F("RESET: Too many resets, protecting your flash memory (powercycle to solve this)"));

      return;

    }

  }

  else

  {

    Serial.println(F("RESET: Cold boot"));

    initRTC();

  }



  RTC.flashCounter=0;

  RTC.factoryResetCounter++;

  saveToRTC();





  SPIFFS.end();

  Serial.println(F("RESET: formatting..."));

  SPIFFS.format();

  Serial.println(F("RESET: formatting done..."));

  if (!SPIFFS.begin())

  {

    Serial.println(F("RESET: FORMAT SPIFFS FAILED!"));

    return;

  }







  String fname;



  fname=FILE_CONFIG;

  InitFile(fname.c_str(), CONFIG_FILE_SIZE);



  fname=FILE_SECURITY;

  InitFile(fname.c_str(), 4096);



  fname=FILE_NOTIFICATION;

  InitFile(fname.c_str(), 4096);



  fname=FILE_RULES;

  InitFile(fname.c_str(), 0);



  LoadSettings();





#if DEFAULT_USE_STATIC_IP

  str2ip((char*)DEFAULT_IP, Settings.IP);

  str2ip((char*)DEFAULT_DNS, Settings.DNS);

  str2ip((char*)DEFAULT_GW, Settings.Gateway);

  str2ip((char*)DEFAULT_SUBNET, Settings.Subnet);

#endif



  Settings.PID = ESP_PROJECT_PID;

  Settings.Version = VERSION;

  Settings.Unit = UNIT;

  strcpy_P(SecuritySettings.WifiSSID, PSTR(DEFAULT_SSID));

  strcpy_P(SecuritySettings.WifiKey, PSTR(DEFAULT_KEY));

  strcpy_P(SecuritySettings.WifiAPKey, PSTR(DEFAULT_AP_KEY));

  SecuritySettings.Password[0] = 0;



  str2ip((char*)DEFAULT_IPRANGE_LOW, SecuritySettings.AllowedIPrangeLow);

  str2ip((char*)DEFAULT_IPRANGE_HIGH, SecuritySettings.AllowedIPrangeHigh);

  SecuritySettings.IPblockLevel = DEFAULT_IP_BLOCK_LEVEL;



  Settings.Delay = DEFAULT_DELAY;

  Settings.Pin_i2c_sda = DEFAULT_PIN_I2C_SDA;

  Settings.Pin_i2c_scl = DEFAULT_PIN_I2C_SCL;

  Settings.Pin_status_led = DEFAULT_PIN_STATUS_LED;

  Settings.Pin_status_led_Inversed = DEFAULT_PIN_STATUS_LED_INVERSED;

  Settings.Pin_sd_cs = -1;

  Settings.Pin_Reset = -1;

  Settings.Protocol[0] = DEFAULT_PROTOCOL;

  strcpy_P(Settings.Name, PSTR(DEFAULT_NAME));

  Settings.deepSleep = false;

  Settings.CustomCSS = false;

  Settings.InitSPI = false;

  for (byte x = 0; x < TASKS_MAX; x++)

  {

    Settings.TaskDevicePin1[x] = -1;

    Settings.TaskDevicePin2[x] = -1;

    Settings.TaskDevicePin3[x] = -1;

    Settings.TaskDevicePin1PullUp[x] = true;

    Settings.TaskDevicePin1Inversed[x] = false;

    for (byte y = 0; y < CONTROLLER_MAX; y++)

      Settings.TaskDeviceSendData[y][x] = true;

    Settings.TaskDeviceTimer[x] = Settings.Delay;

  }

  Settings.Build = BUILD;





 Settings.UseRules = DEFAULT_USE_RULES;



 Settings.MQTTRetainFlag = DEFAULT_MQTT_RETAIN;

 Settings.MessageDelay = DEFAULT_MQTT_DELAY;



    Settings.UseNTP = DEFAULT_USE_NTP;

 strcpy_P(Settings.NTPHost, PSTR(DEFAULT_NTP_HOST));

 Settings.TimeZone = DEFAULT_TIME_ZONE;

    Settings.DST = DEFAULT_USE_DST;



 str2ip((char*)DEFAULT_SYSLOG_IP, Settings.Syslog_IP);



 Settings.SyslogLevel = DEFAULT_SYSLOG_LEVEL;

 Settings.SerialLogLevel = DEFAULT_SERIAL_LOG_LEVEL;

 Settings.SyslogFacility = DEFAULT_SYSLOG_FACILITY;

 Settings.WebLogLevel = DEFAULT_WEB_LOG_LEVEL;

 Settings.SDLogLevel = DEFAULT_SD_LOG_LEVEL;

 Settings.UseValueLogger = DEFAULT_USE_SD_LOG;



 Settings.UseSerial = DEFAULT_USE_SERIAL;

 Settings.BaudRate = DEFAULT_SERIAL_BAUD;
# 2463 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
  SaveSettings();



#if DEFAULT_CONTROLLER

  ControllerSettingsStruct ControllerSettings;

  strcpy_P(ControllerSettings.Subscribe, PSTR(DEFAULT_SUB));

  strcpy_P(ControllerSettings.Publish, PSTR(DEFAULT_PUB));

  str2ip((char*)DEFAULT_SERVER, ControllerSettings.IP);

  ControllerSettings.HostName[0]=0;

  ControllerSettings.Port = DEFAULT_PORT;

  SaveControllerSettings(0, (byte*)&ControllerSettings, sizeof(ControllerSettings));

#endif

  checkRAM(F("ResetFactory2"));

  Serial.println(F("RESET: Succesful, rebooting. (you might need to press the reset button if you've justed flashed the firmware)"));



  delay(1000);

  WiFi.persistent(true);

  intent_to_reboot = true;

  WifiDisconnect();

  WiFi.persistent(false);

  #if defined(ESP8266)

    ESP.reset();

  #endif

  #if defined(ESP32)

    ESP.restart();

  #endif

}
# 2527 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void emergencyReset()

{



  Serial.begin(115200);

  Serial.write(0xAA);

  Serial.write(0x55);

  delay(1);

  if (Serial.available() == 2)

    if (Serial.read() == 0xAA && Serial.read() == 0x55)

    {

      Serial.println(F("\n\n\rSystem will reset to factory defaults in 10 seconds..."));

      delay(10000);

      ResetFactory();

    }

}
# 2567 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
unsigned long FreeMem(void)

{

  #if defined(ESP8266)

    return system_get_free_heap_size();

  #endif

  #if defined(ESP32)

    return ESP.getFreeHeap();

  #endif

}
# 2593 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String getLastBootCauseString() {

  switch (lastBootCause)

  {

    case BOOT_CAUSE_MANUAL_REBOOT: return F("Manual reboot");

    case BOOT_CAUSE_DEEP_SLEEP:

       return F("Deep sleep");

    case BOOT_CAUSE_COLD_BOOT:

       return F("Cold boot");

    case BOOT_CAUSE_EXT_WD:

       return F("External Watchdog");

  }

  return F("Unknown");

}



String getSystemBuildString() {

  String result;

  result += BUILD;

  result += F(" ");

  result += F(BUILD_NOTES);

  return result;

}



String getPluginDescriptionString() {

  String result;

  #ifdef PLUGIN_BUILD_NORMAL

    result += F(" [Normal]");

  #endif

  #ifdef PLUGIN_BUILD_TESTING

    result += F(" [Testing]");

  #endif

  #ifdef PLUGIN_BUILD_DEV

    result += F(" [Development]");

  #endif

  return result;

}



String getSystemLibraryString() {

  String result;

  #if defined(ESP32)

    result += F("ESP32 SDK ");

    result += ESP.getSdkVersion();

  #else

    result += F("ESP82xx Core ");

    result += ESP.getCoreVersion();

    result += F(", NONOS SDK ");

    result += system_get_sdk_version();

    result += F(", LWIP: ");

    result += getLWIPversion();

  #endif

  return result;

}



#ifndef ESP32

String getLWIPversion() {

  String result;

  result += LWIP_VERSION_MAJOR;

  result += F(".");

  result += LWIP_VERSION_MINOR;

  result += F(".");

  result += LWIP_VERSION_REVISION;

  if (LWIP_VERSION_IS_RC) {

    result += F("-RC");

    result += LWIP_VERSION_RC;

  } else if (LWIP_VERSION_IS_DEVELOPMENT) {

    result += F("-dev");

  }

  return result;

}

#endif
# 2739 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean isFloat(const String& tBuf) {

  return isNumerical(tBuf, false);

}



boolean isValidFloat(float f) {

  if (f == NAN) return false;

  if (f == INFINITY) return false;

  if (-f == INFINITY)return false;

  if (isnan(f)) return false;

  if (isinf(f)) return false;

  return true;

}



boolean isInt(const String& tBuf) {

  return isNumerical(tBuf, true);

}



boolean isNumerical(const String& tBuf, bool mustBeInteger) {

  boolean decPt = false;

  int firstDec = 0;

  if(tBuf.charAt(0) == '+' || tBuf.charAt(0) == '-')

    firstDec = 1;

  for(unsigned int x=firstDec; x < tBuf.length(); ++x) {

    if(tBuf.charAt(x) == '.') {

      if (mustBeInteger) return false;



      if(decPt) return false;

      else decPt = true;

    }

    else if(tBuf.charAt(x) < '0' || tBuf.charAt(x) > '9') return false;

  }

  return true;

}





float timeStringToSeconds(String tBuf) {

 float sec = 0;

 int split = tBuf.indexOf(':');

 if (split < 0) {

  sec += tBuf.toFloat() * 60 * 60;

 } else {

  sec += tBuf.substring(0, split).toFloat() * 60 * 60;

  tBuf = tBuf.substring(split +1);

  split = tBuf.indexOf(':');

  if (split < 0) {

   sec += tBuf.toFloat() * 60;

  } else {

   sec += tBuf.substring(0, split).toFloat() * 60;

   sec += tBuf.substring(split +1).toFloat();

  }

 }

 return sec;

}
# 2853 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void initLog()

{



  Settings.UseSerial=true;

  Settings.SyslogLevel=0;

  Settings.SyslogFacility=0;

  Settings.SerialLogLevel=2;

  Settings.WebLogLevel=2;

  Settings.SDLogLevel=0;

}
# 2881 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String getLogLevelDisplayString(byte index, int& logLevel) {

  switch (index) {

    case 0: logLevel = LOG_LEVEL_ERROR; return F("Error");

    case 1: logLevel = LOG_LEVEL_INFO; return F("Info");

    case 2: logLevel = LOG_LEVEL_DEBUG; return F("Debug");

    case 3: logLevel = LOG_LEVEL_DEBUG_MORE; return F("Debug More");

    case 4: logLevel = LOG_LEVEL_DEBUG_DEV; return F("Debug dev");



    default: logLevel = -1; return "";

  }

}





void addLog(byte loglevel, String& string)

{

  addLog(loglevel, string.c_str());

}



void addLog(byte logLevel, const __FlashStringHelper* flashString)

{

    checkRAM(F("addLog"));

    String s(flashString);

    addLog(logLevel, s.c_str());

}



bool SerialAvailableForWrite() {

  if (!Settings.UseSerial) return false;

  #if defined(ESP8266)

    if (!Serial.availableForWrite()) return false;

  #endif

  return true;

}



boolean loglevelActiveFor(byte destination, byte logLevel) {

  byte logLevelSettings = 0;

  switch (destination) {

    case LOG_TO_SERIAL: {

      if (!SerialAvailableForWrite()) return false;

      logLevelSettings = Settings.SerialLogLevel;

      if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED)

        logLevelSettings = 2;

      break;

    }

    case LOG_TO_SYSLOG: {

      logLevelSettings = Settings.SyslogLevel;

      break;

    }

    case LOG_TO_WEBLOG: {

      logLevelSettings = Settings.WebLogLevel;

      break;

    }

    case LOG_TO_SDCARD: {

      logLevelSettings = Settings.SDLogLevel;

      break;

    }

    default:

      return false;

  }

  return loglevelActive(logLevel, logLevelSettings);

}





boolean loglevelActive(byte logLevel, byte logLevelSettings) {

  return (logLevel <= logLevelSettings);

}



void addLog(byte logLevel, const char *line)

{

  if (loglevelActiveFor(LOG_TO_SERIAL, logLevel)) {

    Serial.print(millis());

    Serial.print(F(" : "));

    Serial.println(line);

  }

  if (loglevelActiveFor(LOG_TO_SYSLOG, logLevel)) {

    syslog(logLevel, line);

  }

  if (loglevelActiveFor(LOG_TO_WEBLOG, logLevel)) {

    Logging.add(logLevel, line);

  }



#ifdef FEATURE_SD

  if (loglevelActiveFor(LOG_TO_SDCARD, logLevel)) {

    File logFile = SD.open("log.dat", FILE_WRITE);

    if (logFile)

      logFile.println(line);

    logFile.close();

  }

#endif

}
# 3069 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void delayedReboot(int rebootDelay)

{



  while (rebootDelay != 0 )

  {

    Serial.print(F("Delayed Reset "));

    Serial.println(rebootDelay);

    rebootDelay--;

    delay(1000);

  }

   #if defined(ESP8266)

     ESP.reset();

   #endif

   #if defined(ESP32)

     ESP.restart();

   #endif

}
# 3113 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean saveToRTC()

{

  #if defined(ESP32)

    return false;

  #else

    if (!system_rtc_mem_write(RTC_BASE_STRUCT, (byte*)&RTC, sizeof(RTC)) || !readFromRTC())

    {

      addLog(LOG_LEVEL_ERROR, F("RTC  : Error while writing to RTC"));

      return(false);

    }

    else

    {

      return(true);

    }

  #endif

}
# 3155 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void initRTC()

{

  memset(&RTC, 0, sizeof(RTC));

  RTC.ID1 = 0xAA;

  RTC.ID2 = 0x55;

  saveToRTC();



  memset(&UserVar, 0, sizeof(UserVar));

  saveUserVarToRTC();

}
# 3183 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean readFromRTC()

{

  #if defined(ESP32)

    return false;

  #else

    if (!system_rtc_mem_read(RTC_BASE_STRUCT, (byte*)&RTC, sizeof(RTC)))

      return(false);

    return (RTC.ID1 == 0xAA && RTC.ID2 == 0x55);

  #endif

}
# 3213 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean saveUserVarToRTC()

{

  #if defined(ESP32)

    return false;

  #else



    byte* buffer = (byte*)&UserVar;

    size_t size = sizeof(UserVar);

    uint32_t sum = getChecksum(buffer, size);

    boolean ret = system_rtc_mem_write(RTC_BASE_USERVAR, buffer, size);

    ret &= system_rtc_mem_write(RTC_BASE_USERVAR+(size>>2), (byte*)&sum, 4);

    return ret;

  #endif

}
# 3251 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean readUserVarFromRTC()

{

  #if defined(ESP32)

    return false;

  #else



    byte* buffer = (byte*)&UserVar;

    size_t size = sizeof(UserVar);

    boolean ret = system_rtc_mem_read(RTC_BASE_USERVAR, buffer, size);

    uint32_t sumRAM = getChecksum(buffer, size);

    uint32_t sumRTC = 0;

    ret &= system_rtc_mem_read(RTC_BASE_USERVAR+(size>>2), (byte*)&sumRTC, 4);

    if (!ret || sumRTC != sumRAM)

    {

      addLog(LOG_LEVEL_ERROR, F("RTC  : Checksum error on reading RTC user var"));

      memset(buffer, 0, size);

    }

    return ret;

  #endif

}





uint32_t getChecksum(byte* buffer, size_t size)

{

  uint32_t sum = 0x82662342;

  for (size_t i=0; i<size; i++)

    sum += buffer[i];

  return sum;

}
# 3319 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String parseTemplate(String &tmpString, byte lineSize)

{

  checkRAM(F("parseTemplate"));

  String newString = "";

  String tmpStringMid = "";

  newString.reserve(lineSize);





  int leftBracketIndex = tmpString.indexOf('[');

  if (leftBracketIndex == -1)

    newString = tmpString;

  else

  {

    byte count = 0;

    byte currentTaskIndex = ExtraTaskSettings.TaskIndex;



    while (leftBracketIndex >= 0 && count < 10 - 1)

    {

      newString += tmpString.substring(0, leftBracketIndex);

      tmpString = tmpString.substring(leftBracketIndex + 1);

      int rightBracketIndex = tmpString.indexOf(']');

      if (rightBracketIndex >= 0)

      {

        tmpStringMid = tmpString.substring(0, rightBracketIndex);

        tmpString = tmpString.substring(rightBracketIndex + 1);

        int hashtagIndex = tmpStringMid.indexOf('#');

        if (hashtagIndex >= 0) {

          String deviceName = tmpStringMid.substring(0, hashtagIndex);

          String valueName = tmpStringMid.substring(hashtagIndex + 1);

          String valueFormat = "";

          hashtagIndex = valueName.indexOf('#');

          if (hashtagIndex >= 0)

          {

            valueFormat = valueName.substring(hashtagIndex + 1);

            valueName = valueName.substring(0, hashtagIndex);

          }



          if (deviceName.equalsIgnoreCase(F("Plugin")))

          {

            String tmpString = tmpStringMid.substring(7);

            tmpString.replace('#', ',');

            if (PluginCall(PLUGIN_REQUEST, 0, tmpString))

              newString += tmpString;

          }

          else

            for (byte y = 0; y < TASKS_MAX; y++)

            {

              if (Settings.TaskDeviceEnabled[y])

              {

                LoadTaskSettings(y);

                if (ExtraTaskSettings.TaskDeviceName[0] != 0)

                {

                  if (deviceName.equalsIgnoreCase(ExtraTaskSettings.TaskDeviceName))

                  {

                    boolean match = false;

                    for (byte z = 0; z < VARS_PER_TASK; z++)

                      if (valueName.equalsIgnoreCase(ExtraTaskSettings.TaskDeviceValueNames[z]))

                      {



                        match = true;

                        bool isvalid;

                        String value = formatUserVar(y, z, isvalid);

                        if (isvalid) {







                          if (valueFormat.length() > 0)

                          {

                            String valueJust = "";



                            hashtagIndex = valueFormat.indexOf('#');

                            if (hashtagIndex >= 0)

                            {

                              valueJust = valueFormat.substring(hashtagIndex + 1);

                              valueFormat = valueFormat.substring(0, hashtagIndex);

                            }







                            if (valueFormat.length() > 0)

                            {

                              const int val = value == "0" ? 0 : 1;

                              const float valFloat = value.toFloat();



                              String tempValueFormat = valueFormat;

                              int tempValueFormatLength = tempValueFormat.length();

                              const int invertedIndex = tempValueFormat.indexOf('!');

                              const bool inverted = invertedIndex >= 0 ? 1 : 0;

                              if (inverted)

                                tempValueFormat.remove(invertedIndex,1);



                              const int rightJustifyIndex = tempValueFormat.indexOf('R');

                              const bool rightJustify = rightJustifyIndex >= 0 ? 1 : 0;

                              if (rightJustify)

                                tempValueFormat.remove(rightJustifyIndex,1);



                              tempValueFormatLength = tempValueFormat.length();





                              if (tempValueFormatLength > 0)

                              {

                                switch (tempValueFormat[0])

                                  {

                                  case 'V':

                                    break;

                                  case 'O':

                                    value = val == inverted ? F("OFF") : F(" ON");

                                    break;

                                  case 'C':

                                    value = val == inverted ? F("CLOSE") : F(" OPEN");

                                    break;

                                  case 'M':

                                    value = val == inverted ? F("AUTO") : F(" MAN");

                                    break;

                                  case 'm':

                                    value = val == inverted ? F("A") : F("M");

                                    break;

                                  case 'H':

                                    value = val == inverted ? F("COLD") : F(" HOT");

                                    break;

                                  case 'U':

                                    value = val == inverted ? F("DOWN") : F("  UP");

                                    break;

                                  case 'u':

                                    value = val == inverted ? F("D") : F("U");

                                    break;

                                  case 'Y':

                                    value = val == inverted ? F(" NO") : F("YES");

                                    break;

                                  case 'y':

                                    value = val == inverted ? F("N") : F("Y");

                                    break;

                                  case 'X':

                                    value = val == inverted ? F("O") : F("X");

                                    break;

                                  case 'I':

                                    value = val == inverted ? F("OUT") : F(" IN");

                                    break;

                                  case 'Z' :

                                    value = val == inverted ? F("0") : F("1");

                                    break;

                                  case 'D' :

                                    {

                                      int x;

                                      int y;

                                      x = 0;

                                      y = 0;



                                      switch (tempValueFormatLength)

                                      {

                                        case 2:

                                          if (isDigit(tempValueFormat[1]))

                                          {

                                            x = (int)tempValueFormat[1]-'0';

                                          }

                                          break;

                                        case 3:

                                          if (tempValueFormat[1]=='.' && isDigit(tempValueFormat[2]))

                                          {

                                            y = (int)tempValueFormat[2]-'0';

                                          }

                                          break;

                                        case 4:

                                          if (isDigit(tempValueFormat[1]) && tempValueFormat[2]=='.' && isDigit(tempValueFormat[3]))

                                          {

                                            x = (int)tempValueFormat[1]-'0';

                                            y = (int)tempValueFormat[3]-'0';

                                          }

                                          break;

                                        case 1:

                                        default:

                                          break;

                                      }

                                      value = toString(valFloat,y);

                                      int indexDot;

                                      indexDot = value.indexOf('.') > 0 ? value.indexOf('.') : value.length();

                                      for (byte f = 0; f < (x - indexDot); f++)

                                        value = "0" + value;

                                      break;

                                    }

                                  case 'F' :

                                    value = (int)floorf(valFloat);

                                    break;

                                  case 'E' :

                                    value = (int)ceilf(valFloat);

                                    break;

                                  default:

                                    value = F("ERR");

                                    break;

                                  }





                                  const int valueJustLength = valueJust.length();

                                  if (valueJustLength > 0)

                                  {

                                    value.trim();

                                    switch (valueJust[0])

                                    {

                                    case 'P' :

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          int filler = valueJust[1] - value.length() - '0' ;

                                          for (byte f = 0; f < filler; f++)

                                            newString += " ";

                                        }

                                      }

                                      break;

                                    case 'S' :

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          int filler = valueJust[1] - value.length() - '0' ;

                                          for (byte f = 0; f < filler; f++)

                                            value += " ";

                                        }

                                      }

                                      break;

                                    case 'L':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          value = value.substring(0,(int)valueJust[1]-'0');

                                        }

                                      }

                                      break;

                                    case 'R':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          value = value.substring(std::max(0,(int)value.length()-((int)valueJust[1]-'0')));

                                         }

                                      }

                                      break;

                                    case 'U':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]) && valueJust[2]=='.' && isDigit(valueJust[3]) && valueJust[1] > '0' && valueJust[3] > '0')

                                        {

                                          value = value.substring(std::min((int)value.length(),(int)valueJust[1]-'0'-1),(int)valueJust[1]-'0'-1+(int)valueJust[3]-'0');

                                        }

                                        else

                                        {

                                          newString += F("ERR");

                                        }

                                      }

                                      break;

                                    default:

                                      newString += F("ERR");

                                      break;

                                  }

                                }

                              }

                              if (rightJustify)

                              {

                                int filler = lineSize - newString.length() - value.length() - tmpString.length() ;

                                for (byte f = 0; f < filler; f++)

                                  newString += " ";

                              }

                              {

                                String logFormatted = F("DEBUG: Formatted String='");

                                logFormatted += newString;

                                logFormatted += value;

                                logFormatted += "'";

                                addLog(LOG_LEVEL_DEBUG, logFormatted);

                              }

                            }

                          }





                          newString += String(value);

                          {

                            String logParsed = F("DEBUG DEV: Parsed String='");

                            logParsed += newString;

                            logParsed += "'";

                            addLog(LOG_LEVEL_DEBUG_DEV, logParsed);

                          }

                          break;

                        }

                      }

                    if (!match)

                    {

                      struct EventStruct TempEvent;

                      TempEvent.TaskIndex = y;

                      String tmpName = valueName;

                      if (PluginCall(PLUGIN_GET_CONFIG, &TempEvent, tmpName))

                        newString += tmpName;

                    }

                    break;

                  }

                }

              }

            }

        }

      }

      leftBracketIndex = tmpString.indexOf('[');

      count++;

    }

    checkRAM(F("parseTemplate2"));

    newString += tmpString;



    if (currentTaskIndex != 255)

      LoadTaskSettings(currentTaskIndex);

  }



  parseSystemVariables(newString, false);

  parseStandardConversions(newString, false);





  while (newString.length() < lineSize)

    newString += " ";

  checkRAM(F("parseTemplate3"));

  return newString;

}
# 3963 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#define CALCULATE_OK 0

#define CALCULATE_ERROR_STACK_OVERFLOW 1

#define CALCULATE_ERROR_BAD_OPERATOR 2

#define CALCULATE_ERROR_PARENTHESES_MISMATCHED 3

#define CALCULATE_ERROR_UNKNOWN_TOKEN 4

#define STACK_SIZE 10

#define TOKEN_MAX 20



float globalstack[STACK_SIZE];

float *sp = globalstack - 1;

float *sp_max = &globalstack[STACK_SIZE - 1];



#define is_operator(c) (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')



int push(float value)

{

  if (sp != sp_max)

  {

    *(++sp) = value;

    return 0;

  }

  else

    return CALCULATE_ERROR_STACK_OVERFLOW;

}



float pop()

{

  if (sp != (globalstack - 1))

    return *(sp--);

  else

    return 0.0;

}



float apply_operator(char op, float first, float second)

{

  switch (op)

  {

    case '+':

      return first + second;

    case '-':

      return first - second;

    case '*':

      return first * second;

    case '/':

      return first / second;

    case '^':

      return pow(first, second);

    default:

      return 0;

  }

}



char *next_token(char *linep)

{

  while (isspace(*(linep++)));

  while (*linep && !isspace(*(linep++)));

  return linep;

}



int RPNCalculate(char* token)

{

  if (token[0] == 0)

    return 0;



  if (is_operator(token[0]) && token[1] == 0)

  {

    float second = pop();

    float first = pop();



    if (push(apply_operator(token[0], first, second)))

      return CALCULATE_ERROR_STACK_OVERFLOW;

  }

  else

    if (push(atof(token)))

      return CALCULATE_ERROR_STACK_OVERFLOW;



  return 0;

}
# 4131 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
int op_preced(const char c)

{

  switch (c)

  {

    case '^':

      return 3;

    case '*':

    case '/':

      return 2;

    case '+':

    case '-':

      return 1;

  }

  return 0;

}



bool op_left_assoc(const char c)

{

  switch (c)

  {

    case '^':

    case '*':

    case '/':

    case '+':

    case '-':

      return true;



  }

  return false;

}



unsigned int op_arg_count(const char c)

{

  switch (c)

  {

    case '^':

    case '*':

    case '/':

    case '+':

    case '-':

      return 2;



  }

  return 0;

}





int Calculate(const char *input, float* result)

{

  checkRAM(F("Calculate"));

  const char *strpos = input, *strend = input + strlen(input);

  char token[25];

  char c, oc, *TokenPos = token;

  char stack[32];

  unsigned int sl = 0;

  char sc;

  int error = 0;





  sp = globalstack - 1;

  oc=c=0;

  while (strpos < strend)

  {



    oc = c;

    c = *strpos;

    if (c != ' ')

    {



      if ((c >= '0' && c <= '9') || c == '.' || (c == '-' && is_operator(oc)))

      {

        *TokenPos = c;

        ++TokenPos;

      }





      else if (is_operator(c))

      {

        *(TokenPos) = 0;

        error = RPNCalculate(token);

        TokenPos = token;

        if (error)return error;

        while (sl > 0)

        {

          sc = stack[sl - 1];
# 4311 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
          if (is_operator(sc) && ((op_left_assoc(c) && (op_preced(c) <= op_preced(sc))) || (op_preced(c) < op_preced(sc))))

          {



            *TokenPos = sc;

            ++TokenPos;

            *(TokenPos) = 0;

            error = RPNCalculate(token);

            TokenPos = token;

            if (error)return error;

            sl--;

          }

          else

            break;

        }



        stack[sl] = c;

        ++sl;

      }



      else if (c == '(')

      {

        stack[sl] = c;

        ++sl;

      }



      else if (c == ')')

      {

        bool pe = false;





        while (sl > 0)

        {

          *(TokenPos) = 0;

          error = RPNCalculate(token);

          TokenPos = token;

          if (error)return error;

          sc = stack[sl - 1];

          if (sc == '(')

          {

            pe = true;

            break;

          }

          else

          {

            *TokenPos = sc;

            ++TokenPos;

            sl--;

          }

        }



        if (!pe)

          return CALCULATE_ERROR_PARENTHESES_MISMATCHED;





        sl--;





        if (sl > 0)

          sc = stack[sl - 1];



      }

      else

        return CALCULATE_ERROR_UNKNOWN_TOKEN;

    }

    ++strpos;

  }





  while (sl > 0)

  {

    sc = stack[sl - 1];

    if (sc == '(' || sc == ')')

      return CALCULATE_ERROR_PARENTHESES_MISMATCHED;



    *(TokenPos) = 0;

    error = RPNCalculate(token);

    TokenPos = token;

    if (error)return error;

    *TokenPos = sc;

    ++TokenPos;

    --sl;

  }



  *(TokenPos) = 0;

  error = RPNCalculate(token);

  TokenPos = token;

  if (error)

  {

    *result = 0;

    return error;

  }

  *result = *sp;

  checkRAM(F("Calculate2"));

  return CALCULATE_OK;

}





void checkRuleSets(){

for (byte x=0; x < RULESETS_MAX; x++){

  #if defined(ESP8266)

    String fileName = F("rules");

  #endif

  #if defined(ESP32)

    String fileName = F("/rules");

  #endif

  fileName += x+1;

  fileName += F(".txt");

  if (SPIFFS.exists(fileName))

    activeRuleSets[x] = true;

  else

    activeRuleSets[x] = false;



  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

    Serial.print(fileName);

    Serial.print(" ");

    Serial.println(activeRuleSets[x]);

    }

  }

}
# 4559 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void rulesProcessing(String& event)

{

  checkRAM(F("rulesProcessing"));

  unsigned long timer = millis();

  String log = "";



  log = F("EVENT: ");

  log += event;

  addLog(LOG_LEVEL_INFO, log);



  for (byte x = 0; x < RULESETS_MAX; x++)

  {

    #if defined(ESP8266)

      String fileName = F("rules");

    #endif

    #if defined(ESP32)

      String fileName = F("/rules");

    #endif

    fileName += x+1;

    fileName += F(".txt");

    if(activeRuleSets[x])

      rulesProcessingFile(fileName, event);

  }



  log += F(" Processing time:");

  log += timePassedSince(timer);

  log += F(" milliSeconds");

  addLog(LOG_LEVEL_DEBUG, log);



}
# 4627 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
String rulesProcessingFile(String fileName, String& event)

{

  checkRAM(F("rulesProcessingFile"));

  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

    Serial.print(F("RuleDebug Processing:"));

    Serial.println(fileName);

    Serial.println(F("     flags CMI  parse output:"));

    }



  static byte nestingLevel = 0;

  int data = 0;

  String log = "";



  nestingLevel++;

  if (nestingLevel > RULES_MAX_NESTING_LEVEL)

  {

    log = F("EVENT: Error: Nesting level exceeded!");

    addLog(LOG_LEVEL_ERROR, log);

    nestingLevel--;

    return (log);

  }



  fs::File f = SPIFFS.open(fileName, "r+");

  SPIFFS_CHECK(f, fileName.c_str());



  String line = "";

  boolean match = false;

  boolean codeBlock = false;

  boolean isCommand = false;

  boolean conditional = false;

  boolean condition = false;

  boolean ifBranche = false;

  boolean ifBrancheJustMatch = false;



  byte buf[RULES_BUFFER_SIZE];

  int len = 0;

  while (f.available())

  {

    len = f.read((byte*)buf, RULES_BUFFER_SIZE);

    for (int x = 0; x < len; x++) {

      data = buf[x];



      SPIFFS_CHECK(data >= 0, fileName.c_str());



      if (data != 10)

        line += char(data);



      if (data == 10)

      {

        line.replace(F("\r"), "");

        if (line.substring(0, 2) != F("//") && line.length() > 0)

        {

          isCommand = true;



          int comment = line.indexOf(F("//"));

          if (comment > 0)

            line = line.substring(0, comment);



          if (match || !codeBlock) {





            line = parseTemplate(line, line.length());

          }

          line.trim();



          String lineOrg = line;

          line.toLowerCase();





          String eventTrigger = "";

          String action = "";



          if (!codeBlock)

          {

            if (line.startsWith(F("on ")))

            {

              line = line.substring(3);

              int split = line.indexOf(F(" do"));

              if (split != -1)

              {

                eventTrigger = line.substring(0, split);

                action = lineOrg.substring(split + 7);

                action.trim();

              }

              if (eventTrigger == "*")

                match = true;

              else

                match = ruleMatch(event, eventTrigger);

              if (action.length() > 0)

              {

                isCommand = true;

                codeBlock = false;

              }

              else

              {

                isCommand = false;

                codeBlock = true;

              }

            }

          }

          else

          {

            action = lineOrg;

          }



          String lcAction = action;

          lcAction.toLowerCase();

          if (lcAction == F("endon"))

          {

            isCommand = false;

            codeBlock = false;

            match = false;

          }



          if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

            Serial.print(F("RuleDebug: "));

            Serial.print(codeBlock);

            Serial.print(match);

            Serial.print(isCommand);

            Serial.print(F(": "));

            Serial.println(line);

          }



          if (match)

          {

            int split = lcAction.indexOf(F("if "));

            boolean elseif = lcAction.startsWith(F("elseif "));

            if (elseif == false && split != -1)

            {

              conditional = true;

              String check = lcAction.substring(split + 3);

              log = F("[if ");

              log += check;

              log += F("]=");

              condition = ifBrancheJustMatch == false && conditionMatchExtended(check);

              if(condition == true)

              {

                 ifBrancheJustMatch = true;

              }

              ifBranche = true;

              isCommand = false;

              log += condition ? F("true") : F("false");

              addLog(LOG_LEVEL_DEBUG, log);

            }



            if(elseif)

            {

              String check = lcAction.substring(7);

              log = F("[elseif ");

              log += check;

              log += "]=";

              condition = ifBrancheJustMatch == false && conditionMatchExtended(check);

              if(condition == true)

              {

                 ifBrancheJustMatch = true;

              }

              ifBranche = true;

              isCommand = false;

              log += condition ? F("true") : F("false");

              addLog(LOG_LEVEL_DEBUG, log);

            }



            if (lcAction == "else")

            {

              ifBranche = false;

              isCommand = false;

              log = F("else = ");

              log += (conditional && (condition == ifBranche)) ? F("true") : F("false");

              addLog(LOG_LEVEL_DEBUG, log);

            }



            if (lcAction == "endif")

            {

              conditional = false;

              isCommand = false;

              ifBranche = false;

              ifBrancheJustMatch = false;

            }





            if (isCommand && ((!conditional) || (conditional && (condition == ifBranche))))

            {

              if (event.charAt(0) == '!')

              {

                action.replace(F("%eventvalue%"), event);

              }

              else

              {

                int equalsPos = event.indexOf("=");

                if (equalsPos > 0)

                {

                  String tmpString = event.substring(equalsPos + 1);

                  action.replace(F("%eventvalue%"), tmpString);

                }

              }

              log = F("ACT  : ");

              log += action;

              addLog(LOG_LEVEL_INFO, log);



              struct EventStruct TempEvent;

              parseCommandString(&TempEvent, action);

              yield();



              String tmpAction(action);

              if (!PluginCall(PLUGIN_WRITE, &TempEvent, tmpAction)) {

                if (!tmpAction.equals(action)) {

                  String log = F("PLUGIN_WRITE altered the string: ");

                  log += action;

                  log += F(" to: ");

                  log += tmpAction;

                  addLog(LOG_LEVEL_ERROR, log);

                }

                ExecuteCommand(VALUE_SOURCE_SYSTEM, action.c_str());

              }

              yield();

            }

          }

        }



        line = "";

      }

    }

  }



  nestingLevel--;

  checkRAM(F("rulesProcessingFile2"));

  return (F(""));

}
# 5093 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean ruleMatch(String& event, String& rule)

{

  checkRAM(F("ruleMatch"));

  boolean match = false;

  String tmpEvent = event;

  String tmpRule = rule;





  if (event.charAt(0) == '!')

  {

    int pos = rule.indexOf('#');

    if (pos == -1)

      {

        tmpEvent = event.substring(0,rule.length());

        tmpRule = rule;

      }



    pos = rule.indexOf('*');

    if (pos != -1)

      {

        tmpEvent = event.substring(0,pos-1);

        tmpRule = rule.substring(0,pos-1);

      }



    if (tmpEvent.equalsIgnoreCase(tmpRule))

      return true;

    else

      return false;

  }



  if (event.startsWith(F("Clock#Time")))

  {

    int pos1 = event.indexOf("=");

    int pos2 = rule.indexOf("=");

    if (pos1 > 0 && pos2 > 0)

    {

      tmpEvent = event.substring(0, pos1);

      tmpRule = rule.substring(0, pos2);

      if (tmpRule.equalsIgnoreCase(tmpEvent))

      {

        tmpEvent = event.substring(pos1 + 1);

        tmpRule = rule.substring(pos2 + 1);

        unsigned long clockEvent = string2TimeLong(tmpEvent);

        unsigned long clockSet = string2TimeLong(tmpRule);

        if (matchClockEvent(clockEvent, clockSet))

          return true;

        else

          return false;

      }

    }

  }







  float value = 0;

  int pos = event.indexOf("=");

  if (pos)

  {

    tmpEvent = event.substring(pos + 1);

    value = tmpEvent.toFloat();

    tmpEvent = event.substring(0, pos);

  }





  int comparePos = 0;

  char compare = ' ';

  comparePos = rule.indexOf(">");

  if (comparePos > 0)

  {

    compare = '>';

  }

  else

  {

    comparePos = rule.indexOf("<");

    if (comparePos > 0)

    {

      compare = '<';

    }

    else

    {

      comparePos = rule.indexOf("=");

      if (comparePos > 0)

      {

        compare = '=';

      }

    }

  }



  float ruleValue = 0;



  if (comparePos > 0)

  {

    tmpRule = rule.substring(comparePos + 1);

    ruleValue = tmpRule.toFloat();

    tmpRule = rule.substring(0, comparePos);

  }



  switch (compare)

  {

    case '>':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value > ruleValue)

        match = true;

      break;



    case '<':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value < ruleValue)

        match = true;

      break;



    case '=':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value == ruleValue)

        match = true;

      break;



    case ' ':

      if (tmpRule.equalsIgnoreCase(tmpEvent))

        match = true;

      break;

  }

  checkRAM(F("ruleMatch2"));

  return match;

}
# 5349 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
boolean conditionMatchExtended(String& check) {

 int condAnd = -1;

 int condOr = -1;

 boolean rightcond = false;

 boolean leftcond = conditionMatch(check);



 do {

  condAnd = check.indexOf(F(" and "));

  condOr = check.indexOf(F(" or "));



  if (condAnd > 0 || condOr > 0) {

   if (condAnd > 0 && ((condOr < 0 && condOr < condAnd) || (condOr > 0 && condOr > condAnd))) {

    check = check.substring(condAnd + 5);

    rightcond = conditionMatch(check);

    leftcond = (leftcond && rightcond);

   } else {

    check = check.substring(condOr + 4);

    rightcond = conditionMatch(check);

    leftcond = (leftcond || rightcond);

   }

  }

 } while (condAnd > 0 || condOr > 0);

 return leftcond;

}



boolean conditionMatch(const String& check)

{

  boolean match = false;



  char compare = ' ';



  int posStart = check.length();

  int posEnd = posStart;

  int comparePos = 0;



  if ((comparePos = check.indexOf("!="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '!'+'=';

  }

  if ((comparePos = check.indexOf("<>"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '!'+'=';

  }

  if ((comparePos = check.indexOf(">="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '>'+'=';

  }

  if ((comparePos = check.indexOf("<="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '<'+'=';

  }

  if ((comparePos = check.indexOf("<"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '<';

  }

  if ((comparePos = check.indexOf(">"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '>';

  }

  if ((comparePos = check.indexOf("="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '=';

  }



  float Value1 = 0;

  float Value2 = 0;



  if (compare > ' ')

  {

    String tmpCheck1 = check.substring(0, posStart);

    String tmpCheck2 = check.substring(posEnd);

    if (!isFloat(tmpCheck1) || !isFloat(tmpCheck2)) {

        Value1 = timeStringToSeconds(tmpCheck1);

        Value2 = timeStringToSeconds(tmpCheck2);

    } else {

        Value1 = tmpCheck1.toFloat();

        Value2 = tmpCheck2.toFloat();

    }

  }

  else

    return false;



  switch (compare)

  {

  case '>'+'=':

   if (Value1 >= Value2)

    match = true;

   break;



  case '<'+'=':

   if (Value1 <= Value2)

    match = true;

   break;



  case '!'+'=':

   if (Value1 != Value2)

    match = true;

   break;



  case '>':

   if (Value1 > Value2)

    match = true;

   break;



  case '<':

   if (Value1 < Value2)

    match = true;

   break;



  case '=':

   if (Value1 == Value2)

    match = true;

   break;

  }

  return match;

}
# 5605 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void rulesTimers()

{

  for (byte x = 0; x < RULES_TIMER_MAX; x++)

  {

    if (!RulesTimer[x].paused && RulesTimer[x].timestamp != 0L)

    {

      if (timeOutReached(RulesTimer[x].timestamp))

      {

        RulesTimer[x].timestamp = 0L;

        String event = F("Rules#Timer=");

        event += x + 1;

        rulesProcessing(event);

      }

    }

  }

}
# 5649 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void createRuleEvents(byte TaskIndex)

{

  LoadTaskSettings(TaskIndex);

  byte BaseVarIndex = TaskIndex * VARS_PER_TASK;

  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

  byte sensorType = Device[DeviceIndex].VType;

  for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

  {

    String eventString = ExtraTaskSettings.TaskDeviceName;

    eventString += F("#");

    eventString += ExtraTaskSettings.TaskDeviceValueNames[varNr];

    eventString += F("=");



    if (sensorType == SENSOR_TYPE_LONG)

      eventString += (unsigned long)UserVar[BaseVarIndex] + ((unsigned long)UserVar[BaseVarIndex + 1] << 16);

    else

      eventString += UserVar[BaseVarIndex + varNr];



    rulesProcessing(eventString);

  }

}





void SendValueLogger(byte TaskIndex)

{

  String logger;



  LoadTaskSettings(TaskIndex);

  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

  for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

  {

    logger += getDateString('-');

    logger += F(" ");

    logger += getTimeString(':');

    logger += F(",");

    logger += Settings.Unit;

    logger += F(",");

    logger += ExtraTaskSettings.TaskDeviceName;

    logger += F(",");

    logger += ExtraTaskSettings.TaskDeviceValueNames[varNr];

    logger += F(",");

    logger += formatUserVarNoCheck(TaskIndex, varNr);

    logger += F("\r\n");

  }



  addLog(LOG_LEVEL_DEBUG, logger);



#ifdef FEATURE_SD

  String filename = F("VALUES.CSV");

  File logFile = SD.open(filename, FILE_WRITE);

  if (logFile)

    logFile.print(logger);

  logFile.close();

#endif

}





#define TRACES 3

#define TRACEENTRIES 15



class RamTracker{

  private:

    String traces[TRACES] ;

    unsigned int tracesMemory[TRACES] ;

    unsigned int readPtr, writePtr;

    String nextAction[TRACEENTRIES];

    unsigned int nextActionStartMemory[TRACEENTRIES];



    unsigned int bestCaseTrace (void){

       unsigned int lowestMemoryInTrace = 0;

       unsigned int lowestMemoryInTraceIndex=0;

       for (int i = 0; i<TRACES; i++) {

          if (tracesMemory[i] > lowestMemoryInTrace){

            lowestMemoryInTrace= tracesMemory[i];

            lowestMemoryInTraceIndex=i;

            }

          }



      return lowestMemoryInTraceIndex;

      }



  public:

    RamTracker(void){

        readPtr=0;

        writePtr=0;

        for (int i = 0; i< TRACES; i++) {

          traces[i]="";

          tracesMemory[i]=0xffffffff;

          }

        for (int i = 0; i< TRACEENTRIES; i++) {

          nextAction[i]="startup";

          nextActionStartMemory[i] = ESP.getFreeHeap();

          }

        };



    void registerRamState(String &s){

       nextAction[writePtr]=s;

       nextActionStartMemory[writePtr]=ESP.getFreeHeap();

       int bestCase = bestCaseTrace();

       if ( ESP.getFreeHeap() < tracesMemory[bestCase]){

            traces[bestCase]="";

            readPtr = writePtr+1;

            if (readPtr>=TRACEENTRIES) readPtr=0;

            tracesMemory[bestCase] = ESP.getFreeHeap();



            for (int i = 0; i<TRACEENTRIES; i++) {

              traces[bestCase]+= nextAction[readPtr];

              traces[bestCase]+= "-> ";

              traces[bestCase]+= String(nextActionStartMemory[readPtr]);

              traces[bestCase]+= " ";

              readPtr++;

              if (readPtr >=TRACEENTRIES) readPtr=0;

            }

       }

       writePtr++;

       if (writePtr >= TRACEENTRIES) writePtr=0;

    };

   void getTraceBuffer(){

      String retval="Memtrace\n";

      for (int i = 0; i< TRACES; i++){

        retval += String(i);

        retval += ": lowest: ";

        retval += String(tracesMemory[i]);

        retval += "  ";

        retval += traces[i];

        addLog(LOG_LEVEL_DEBUG_DEV, retval);

        retval="";

      }

    }

}myRamTracker;



void checkRAMtoLog(void){

  myRamTracker.getTraceBuffer();

}



void checkRAM(const __FlashStringHelper* flashString, int a ) {

 String s=String(a);

 checkRAM(flashString,s);

}



void checkRAM(const __FlashStringHelper* flashString, String &a ) {

  String s = flashString;

  checkRAM(s,a);

}



void checkRAM(String &flashString, String &a ) {

  String s = flashString;

  s+=" (";

  s+=a;

  s+=")";

  checkRAM(s);

}



void checkRAM( const __FlashStringHelper* flashString)

{

  String s = flashString;

  myRamTracker.registerRamState(s);



  uint32_t freeRAM = FreeMem();



  if (freeRAM < lowestRAM)

  {

    lowestRAM = freeRAM;

    lowestRAMfunction = flashString;

  }

}



void checkRAM( String &a ) {

  myRamTracker.registerRamState(a);

}
# 5997 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#define isdigit(n) (n >= '0' && n <= '9')
# 6007 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void tone(uint8_t _pin, unsigned int frequency, unsigned long duration) {

  #ifdef ESP32

    delay(duration);

  #else

    analogWriteFreq(frequency);



    analogWrite(_pin,100);

    delay(duration);

    analogWrite(_pin,0);

  #endif

}
# 6037 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void play_rtttl(uint8_t _pin, const char *p )

{

  checkRAM(F("play_rtttl"));

  #define OCTAVE_OFFSET 0





  const int notes[] = { 0,

    262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494,

    523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988,

    1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976,

    2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951

  };







  byte default_dur = 4;

  byte default_oct = 6;

  int bpm = 63;

  int num;

  long wholenote;

  long duration;

  byte note;

  byte scale;
# 6091 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
  while(*p != ':') p++;

  p++;





  if(*p == 'd')

  {

    p++; p++;

    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }

    if(num > 0) default_dur = num;

    p++;

  }





  if(*p == 'o')

  {

    p++; p++;

    num = *p++ - '0';

    if(num >= 3 && num <=7) default_oct = num;

    p++;

  }





  if(*p == 'b')

  {

    p++; p++;

    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }

    bpm = num;

    p++;

  }





  wholenote = (60 * 1000L / bpm) * 4;





  while(*p)

  {



    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }



    if (num) duration = wholenote / num;

    else duration = wholenote / default_dur;





    note = 0;



    switch(*p)

    {

      case 'c':

        note = 1;

        break;

      case 'd':

        note = 3;

        break;

      case 'e':

        note = 5;

        break;

      case 'f':

        note = 6;

        break;

      case 'g':

        note = 8;

        break;

      case 'a':

        note = 10;

        break;

      case 'b':

        note = 12;

        break;

      case 'p':

      default:

        note = 0;

    }

    p++;





    if(*p == '#')

    {

      note++;

      p++;

    }





    if(*p == '.')

    {

      duration += duration/2;

      p++;

    }





    if(isdigit(*p))

    {

      scale = *p - '0';

      p++;

    }

    else

    {

      scale = default_oct;

    }



    scale += OCTAVE_OFFSET;



    if(*p == ',')

      p++;





    if(note)

    {

      tone(_pin, notes[(scale - 4) * 12 + note], duration);

    }

    else

    {

      delay(duration/10);

    }

  }

 checkRAM(F("play_rtttl2"));

}
# 6355 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
#ifdef FEATURE_ARDUINO_OTA
# 6365 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
void ArduinoOTAInit()

{

  checkRAM(F("ArduinoOTAInit"));



  #if defined(ESP8266)



  ArduinoOTA.setPort(8266);

  #endif

  #if defined(ESP32)

  ArduinoOTA.setPort(3232);

  #endif



  ArduinoOTA.setHostname(Settings.Name);



  if (SecuritySettings.Password[0]!=0)

    ArduinoOTA.setPassword(SecuritySettings.Password);



  ArduinoOTA.onStart([]() {

      Serial.println(F("OTA  : Start upload"));

      SPIFFS.end();

  });



  ArduinoOTA.onEnd([]() {

      Serial.println(F("\nOTA  : End"));





      Serial.println(F("\nOTA  : DO NOT RESET OR POWER OFF UNTIL BOOT+FLASH IS COMPLETE."));

      delay(100);

      #if defined(ESP8266)

        ESP.reset();

      #endif

      #if defined(ESP32)

        ESP.restart();

      #endif

  });

  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {



      Serial.printf("OTA  : Progress %u%%\r", (progress / (total / 100)));

  });



  ArduinoOTA.onError([](ota_error_t error) {

      Serial.print(F("\nOTA  : Error (will reboot): "));

      if (error == OTA_AUTH_ERROR) Serial.println(F("Auth Failed"));

      else if (error == OTA_BEGIN_ERROR) Serial.println(F("Begin Failed"));

      else if (error == OTA_CONNECT_ERROR) Serial.println(F("Connect Failed"));

      else if (error == OTA_RECEIVE_ERROR) Serial.println(F("Receive Failed"));

      else if (error == OTA_END_ERROR) Serial.println(F("End Failed"));



      delay(100);

      #if defined(ESP8266)

       ESP.reset();

      #endif

      #if defined(ESP32)

        ESP.restart();

      #endif

  });

  ArduinoOTA.begin();



  String log = F("OTA  : Arduino OTA enabled on port 8266");

  addLog(LOG_LEVEL_INFO, log);



}



#endif
# 6503 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
float compute_dew_point_temp(float temperature, float humidity_percentage) {

  return pow(humidity_percentage / 100.0, 0.125) *

         (112.0 + 0.9*temperature) + 0.1*temperature - 112.0;

}
# 6519 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Misc.ino"
float compute_humidity_from_dewpoint(float temperature, float dew_temperature) {

  return 100.0 * pow((112.0 - 0.1 * temperature + dew_temperature) /

                     (112.0 + 0.9 * temperature), 8);

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Modbus.ino"


# ifndef MODBUS_H

#define MODBUS_H 



enum MODBUS_states_t {MODBUS_IDLE, MODBUS_RECEIVE, MODBUS_RECEIVE_PAYLOAD};

enum MODBUS_registerTypes_t {signed16, unsigned16, signed32, unsigned32, signed64, unsigned64};



#define MODBUS_FUNCTION_READ 4



class Modbus

{

  public:

    Modbus(void);

    bool handle();

    bool begin(uint8_t function, uint8_t ModbusID, uint16_t ModbusRegister, MODBUS_registerTypes_t type, char* IPaddress);

    double read() {

      if (resultReceived) {

        resultReceived = false;

        return result;

      }

      else

        return -1;

    };

    bool available() {

      return resultReceived;

    };

    unsigned int getReadErrors() {

      return errcnt;

    };

    void resetReadErrors() {

      errcnt = 0;

    };

    void stop() {

      TXRXstate = MODBUS_IDLE;

      handle();

    };

    bool tryRead (uint8_t ModbusID, uint16_t M_register, MODBUS_registerTypes_t type, char* IPaddress, double &result);



  private:

    WiFiClient *ModbusClient;

    unsigned int errcnt;

    char sendBuffer[12] = {0, 1, 0, 0, 0, 6, 0x7e, 4, 0x9d, 7, 0, 1};

    String LogString = "";

    unsigned long timeout;

    MODBUS_states_t TXRXstate;

    unsigned int RXavailable;

    unsigned int payLoad;

    bool hasTimeout();

    MODBUS_registerTypes_t incomingValue;

    double result;

    bool resultReceived;

    bool isBusy(void) {

      return TXRXstate != MODBUS_IDLE;

    };

    uint16_t currentRegister;

    uint8_t currentFunction;

};

#endif







Modbus::Modbus() : ModbusClient(nullptr), errcnt(0), timeout(0),

                   TXRXstate(MODBUS_IDLE), RXavailable(0), payLoad(0) {}



bool Modbus::begin(uint8_t function, uint8_t ModbusID, uint16_t ModbusRegister, MODBUS_registerTypes_t type, char* IPaddress)

{

  currentRegister = ModbusRegister;

  currentFunction = function;

  incomingValue = type;

  resultReceived = false;

  ModbusClient = new WiFiClient();

  ModbusClient->setNoDelay(true);

  ModbusClient->setTimeout(200);

  timeout = millis();

  ModbusClient->flush();



  if (ModbusClient->connected()) {

    LogString += F(" already connected. ");

  } else {

    LogString += F("connect: "); LogString += IPaddress;

    if ( !ModbusClient->connect(IPaddress, 502)) {

      LogString += F(" fail. ");

      TXRXstate = MODBUS_IDLE;

      errcnt++;

      if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

      return false;

    }

  }

  LogString += F(" OK, sending read request: ");



  sendBuffer[6] = ModbusID ;

  sendBuffer[7] = function;

  sendBuffer[8] = (ModbusRegister >> 8) ;

  sendBuffer[9] = (ModbusRegister & 0x00ff) ;

  if ((incomingValue == signed64) || (incomingValue == unsigned64))

    sendBuffer[11] = 4;

  if ((incomingValue == signed32) || (incomingValue == unsigned32))

    sendBuffer[11] = 2;

  if ((incomingValue == signed16) || (incomingValue == unsigned16))

    sendBuffer[11] = 1;

  ModbusClient->flush();

  ModbusClient->write(&sendBuffer[0], sizeof(sendBuffer));

  for (unsigned int i = 0; i < sizeof(sendBuffer); i++) {

    LogString += ((unsigned int)(sendBuffer[i]));

    LogString += (" ");

  }

  TXRXstate = MODBUS_RECEIVE;

  if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

  return true;

}



bool Modbus::handle() {

  unsigned int RXavailable = 0;

  LogString = "";

  int64_t rxValue = 0;

  switch ( TXRXstate ) {



    case MODBUS_IDLE:



      if (ModbusClient) {

        ModbusClient->flush();

        ModbusClient->stop();

        delete (ModbusClient);

        delay(1);

        ModbusClient = nullptr;

      }

      break;



    case MODBUS_RECEIVE:

      if (hasTimeout()) break;

      if (ModbusClient->available() < 9) break;



      LogString += F("reading bytes: ");

      for (int a = 0; a < 9; a++) {

        payLoad = ModbusClient->read();

        LogString += (payLoad); LogString += F(" ");

      }

      LogString += F("> ");

      if (payLoad > 8) {

        LogString += F("Payload too large !? ");

        errcnt++;

        TXRXstate = MODBUS_IDLE;

      }



    case MODBUS_RECEIVE_PAYLOAD:

      if (hasTimeout()) break;

      RXavailable = ModbusClient->available();

      if (payLoad != RXavailable) {

        TXRXstate = MODBUS_RECEIVE_PAYLOAD;

        break;

      }

      for (unsigned int i = 0; i < RXavailable; i++) {

        rxValue = rxValue << 8;

        char a = ModbusClient->read();

        rxValue = rxValue | a;

        LogString += ((int)a); LogString += (" ");

      }

      switch (incomingValue) {

        case signed16:

          result = (int16_t) rxValue;

          break;

        case unsigned16:

          result = (uint16_t) rxValue;

          break;

        case signed32:

          result = (int32_t) rxValue;

          break;

        case unsigned32:

          result = (uint32_t) rxValue;

          break;

        case signed64:

          result = (int64_t) rxValue;

          break;

        case unsigned64:

          result = (uint64_t) rxValue;

          break;

      }



      LogString += "value: "; LogString += result;





      TXRXstate = MODBUS_IDLE;



      resultReceived = true;

      break;



    default:

      LogString += F("default. ");

      TXRXstate = MODBUS_IDLE;

      break;



  }

  if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

  return true;

}



bool Modbus::hasTimeout()

{

  if ( (millis() - timeout) > 10000) {

    LogString += F("Modbus RX timeout. "); LogString += String(ModbusClient->available());

    errcnt++;

    TXRXstate = MODBUS_IDLE;

    return true;

  }

  return false;

}
# 425 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Modbus.ino"
bool Modbus::tryRead (uint8_t ModbusID, uint16_t M_register, MODBUS_registerTypes_t type, char* IPaddress, double &result) {

  if (isBusy()) return false;

  if (available()) {

    if ((currentFunction == MODBUS_FUNCTION_READ ) && (currentRegister == M_register)) {

      result = read();

      return true;

    }

  } else {

    begin(MODBUS_FUNCTION_READ, ModbusID, M_register, type, IPaddress);

  }

  return false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
#define IPADDR2STR(addr) (uint8_t)((uint32_t)addr & 0xFF), (uint8_t)(((uint32_t)addr >> 8) & 0xFF), (uint8_t)(((uint32_t)addr >> 16) & 0xFF), (uint8_t)(((uint32_t)addr >> 24) & 0xFF)
# 25 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void syslog(byte logLevel, const char *message)

{

  if (Settings.Syslog_IP[0] != 0 && wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

    IPAddress broadcastIP(Settings.Syslog_IP[0], Settings.Syslog_IP[1], Settings.Syslog_IP[2], Settings.Syslog_IP[3]);

    portUDP.beginPacket(broadcastIP, 514);

    char str[256];

    str[0] = 0;

    byte prio = Settings.SyslogFacility * 8;

    if ( logLevel == LOG_LEVEL_ERROR )

      prio += 3;

    else if ( logLevel == LOG_LEVEL_INFO )

      prio += 5;

    else

      prio += 7;
# 63 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
    snprintf_P(str, sizeof(str), PSTR("<%u>%s EspEasy: %s"), prio, Settings.Name, message);







    #if defined(ESP8266)

      portUDP.write(str);

    #endif

    #if defined(ESP32)

      portUDP.write((uint8_t*)str,strlen(str));

    #endif

    portUDP.endPacket();

  }

}
# 99 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
boolean runningUPDCheck = false;

void checkUDP()

{

  if (Settings.UDPPort == 0)

    return;



  if (runningUPDCheck)

    return;



  runningUPDCheck = true;





  int packetSize = portUDP.parsePacket();

  if (packetSize)

  {

    statusLED(true);



    IPAddress remoteIP = portUDP.remoteIP();

    if (portUDP.remotePort() == 123)

    {



      runningUPDCheck = false;

      return;

    }

    char packetBuffer[128];

    int len = portUDP.read(packetBuffer, 128);



    if (packetBuffer[0] != 255)

    {

      packetBuffer[len] = 0;

      addLog(LOG_LEVEL_DEBUG, packetBuffer);

      struct EventStruct TempEvent;

      String request = packetBuffer;

      parseCommandString(&TempEvent, request);

      TempEvent.Source = VALUE_SOURCE_SYSTEM;

      if (!PluginCall(PLUGIN_WRITE, &TempEvent, request))

        ExecuteCommand(VALUE_SOURCE_SYSTEM, packetBuffer);

    }

    else

    {



      switch (packetBuffer[1])

      {



        case 1:

          {

            byte mac[6];

            byte ip[4];

            byte unit = packetBuffer[12];

            for (byte x = 0; x < 6; x++)

              mac[x] = packetBuffer[x + 2];

            for (byte x = 0; x < 4; x++)

              ip[x] = packetBuffer[x + 8];



            if (unit < UNIT_MAX)

            {

              for (byte x = 0; x < 4; x++)

                Nodes[unit].ip[x] = packetBuffer[x + 8];

              Nodes[unit].age = 0;

              if (len >20)

              {

                Nodes[unit].build = packetBuffer[13] + 256*packetBuffer[14];

                if (Nodes[unit].nodeName==0)

                    Nodes[unit].nodeName = (char *)malloc(26);

                memcpy(Nodes[unit].nodeName,(byte*)packetBuffer+15,25);

                Nodes[unit].nodeName[25]=0;

                Nodes[unit].nodeType = packetBuffer[40];

              }

            }



            char macaddress[20];

            formatMAC(mac, macaddress);

            char ipaddress[20];

            formatIP(ip, ipaddress);

            char log[80];

            sprintf_P(log, PSTR("UDP  : %s,%s,%u"), macaddress, ipaddress, unit);

            addLog(LOG_LEVEL_DEBUG_MORE, log);

            break;

          }



        default:

          {

            struct EventStruct TempEvent;

            TempEvent.Data = (byte*)packetBuffer;

            TempEvent.Par1 = remoteIP[3];

            PluginCall(PLUGIN_UDP_IN, &TempEvent, dummyString);

            CPluginCall(CPLUGIN_UDP_IN, &TempEvent);

            break;

          }

      }

    }

  }

  #if defined(ESP32)

    portUDP.flush();

  #endif

  runningUPDCheck = false;

}
# 303 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void SendUDPCommand(byte destUnit, char* data, byte dataLength)

{

  if (!WiFiConnected(100)) {

    return;

  }

  byte firstUnit = 1;

  byte lastUnit = UNIT_MAX - 1;

  if (destUnit != 0)

  {

    firstUnit = destUnit;

    lastUnit = destUnit;

  }

  for (int x = firstUnit; x <= lastUnit; x++)

  {

    sendUDP(x, (byte*)data, dataLength);

    delay(10);

  }

  delay(50);

}
# 351 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void sendUDP(byte unit, byte* data, byte size)

{

  if (!WiFiConnected(100)) {

    return;

  }

  if (unit != 255)

    if (Nodes[unit].ip[0] == 0)

      return;

  String log = F("UDP  : Send UDP message to ");

  log += unit;

  addLog(LOG_LEVEL_DEBUG_MORE, log);



  statusLED(true);



  IPAddress remoteNodeIP;

  if (unit == 255)

    remoteNodeIP = {255,255,255,255};

  else

    remoteNodeIP = Nodes[unit].ip;

  portUDP.beginPacket(remoteNodeIP, Settings.UDPPort);

  portUDP.write(data, size);

  portUDP.endPacket();

}
# 407 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void refreshNodeList()

{

  for (byte counter = 0; counter < UNIT_MAX; counter++)

  {

    if (Nodes[counter].ip[0] != 0)

    {

      Nodes[counter].age++;

      if (Nodes[counter].age > 10)

        for (byte x = 0; x < 4; x++)

          Nodes[counter].ip[x] = 0;

    }

  }

}
# 441 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void sendSysInfoUDP(byte repeats)

{

  char log[80];

  if (Settings.UDPPort == 0 || !WiFiConnected(100))

    return;
# 475 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
  strcpy_P(log, PSTR("UDP  : Send Sysinfo message"));

  addLog(LOG_LEVEL_DEBUG_MORE, log);

  for (byte counter = 0; counter < repeats; counter++)

  {

    uint8_t mac[] = {0, 0, 0, 0, 0, 0};

    uint8_t* macread = WiFi.macAddress(mac);

    byte data[80];

    data[0] = 255;

    data[1] = 1;

    for (byte x = 0; x < 6; x++)

      data[x + 2] = macread[x];

    IPAddress ip = WiFi.localIP();

    for (byte x = 0; x < 4; x++)

      data[x + 8] = ip[x];

    data[12] = Settings.Unit;

    data[13] = Settings.Build & 0xff;

    data[14] = Settings.Build >> 8;

    memcpy((byte*)data+15,Settings.Name,25);

    data[40] = NODE_TYPE_ID;

    statusLED(true);



    IPAddress broadcastIP(255, 255, 255, 255);

    portUDP.beginPacket(broadcastIP, Settings.UDPPort);

    portUDP.write(data, 80);

    portUDP.endPacket();

    if (counter < (repeats - 1))

      delay(500);

  }





  if (Settings.Unit < UNIT_MAX)

  {

    IPAddress ip = WiFi.localIP();

    for (byte x = 0; x < 4; x++)

      Nodes[Settings.Unit].ip[x] = ip[x];

    Nodes[Settings.Unit].age = 0;

    Nodes[Settings.Unit].build = Settings.Build;

    Nodes[Settings.Unit].nodeType = NODE_TYPE_ID;

  }

}



#if defined(ESP8266)







void SSDP_schema(WiFiClient &client) {

  if (!WiFiConnected(100)) {

    return;

  }



  const IPAddress ip = WiFi.localIP();

  const uint32_t chipId = ESP.getChipId();

  char uuid[64];

  sprintf_P(uuid, PSTR("38323636-4558-4dda-9188-cda0e6%02x%02x%02x"),

            (uint16_t) ((chipId >> 16) & 0xff),

            (uint16_t) ((chipId >> 8) & 0xff),

            (uint16_t) chipId & 0xff );



  String ssdp_schema = F(

                         "HTTP/1.1 200 OK\r\n"

                         "Content-Type: text/xml\r\n"

                         "Connection: close\r\n"

                         "Access-Control-Allow-Origin: *\r\n"

                         "\r\n"

                         "<?xml version=\"1.0\"?>"

                         "<root xmlns=\"urn:schemas-upnp-org:device-1-0\">"

                         "<specVersion>"

                         "<major>1</major>"

                         "<minor>0</minor>"

                         "</specVersion>"

                         "<URLBase>http://");

  ssdp_schema += formatIP(ip);

  ssdp_schema += F(":80/</URLBase>"

                   "<device>"

                   "<deviceType>urn:schemas-upnp-org:device:BinaryLight:1</deviceType>"

                   "<friendlyName>");

  ssdp_schema += Settings.Name;

  ssdp_schema += F("</friendlyName>"

                   "<presentationURL>/</presentationURL>"

                   "<serialNumber>");

  ssdp_schema += ESP.getChipId();

  ssdp_schema += F("</serialNumber>"

                   "<modelName>ESP Easy</modelName>"

                   "<modelNumber>");

  ssdp_schema += BUILD_GIT;

  ssdp_schema += F("</modelNumber>"

                   "<modelURL>http://www.letscontrolit.com</modelURL>"

                   "<manufacturer>http://www.letscontrolit.com</manufacturer>"

                   "<manufacturerURL>http://www.letscontrolit.com</manufacturerURL>"

                   "<UDN>uuid:");

  ssdp_schema += uuid;

  ssdp_schema += F("</UDN></device>"

                   "</root>\r\n"

                   "\r\n");



  client.printf(ssdp_schema.c_str());

}
# 679 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
typedef enum {

  NONE,

  SEARCH,

  NOTIFY

} ssdp_method_t;



UdpContext* _server;



IPAddress _respondToAddr;

uint16_t _respondToPort;



bool _pending;

unsigned short _delay;

unsigned long _process_time;

unsigned long _notify_time;



#define SSDP_INTERVAL 1200

#define SSDP_PORT 1900

#define SSDP_METHOD_SIZE 10

#define SSDP_URI_SIZE 2

#define SSDP_BUFFER_SIZE 64

#define SSDP_MULTICAST_TTL 2



static const IPAddress SSDP_MULTICAST_ADDR(239, 255, 255, 250);
# 737 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
bool SSDP_begin() {

  _pending = false;



  if (_server) {

    _server->unref();

    _server = 0;

  }



  _server = new UdpContext;

  _server->ref();



  ip_addr_t ifaddr;

  ifaddr.addr = WiFi.localIP();

  ip_addr_t multicast_addr;

  multicast_addr.addr = (uint32_t) SSDP_MULTICAST_ADDR;

  if (igmp_joingroup(&ifaddr, &multicast_addr) != ERR_OK ) {

    return false;

  }



  if (!_server->listen(*IP_ADDR_ANY, SSDP_PORT)) {

    return false;

  }



  _server->setMulticastInterface(ifaddr);

  _server->setMulticastTTL(SSDP_MULTICAST_TTL);

  _server->onRx(&SSDP_update);

  if (!_server->connect(multicast_addr, SSDP_PORT)) {

    return false;

  }



  SSDP_update();



  return true;

}
# 815 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void SSDP_send(byte method) {

  char buffer[1460];

  uint32_t ip = WiFi.localIP();



  uint32_t chipId = ESP.getChipId();



  char uuid[64];

  sprintf_P(uuid, PSTR("38323636-4558-4dda-9188-cda0e6%02x%02x%02x"),

            (uint16_t) ((chipId >> 16) & 0xff),

            (uint16_t) ((chipId >> 8) & 0xff),

            (uint16_t) chipId & 0xff );



  String _ssdp_response_template = F(

                                     "HTTP/1.1 200 OK\r\n"

                                     "EXT:\r\n"

                                     "ST: upnp:rootdevice\r\n");



  String _ssdp_notify_template = F(

                                   "NOTIFY * HTTP/1.1\r\n"

                                   "HOST: 239.255.255.250:1900\r\n"

                                   "NT: upnp:rootdevice\r\n"

                                   "NTS: ssdp:alive\r\n");



  String _ssdp_packet_template = F(

                                   "%s"

                                   "CACHE-CONTROL: max-age=%u\r\n"

                                   "SERVER: Arduino/1.0 UPNP/1.1 ESPEasy/%u\r\n"

                                   "USN: uuid:%s\r\n"

                                   "LOCATION: http://%u.%u.%u.%u:80/ssdp.xml\r\n"

                                   "\r\n");



  int len = snprintf(buffer, sizeof(buffer),

                     _ssdp_packet_template.c_str(),

                     (method == 0) ? _ssdp_response_template.c_str() : _ssdp_notify_template.c_str(),

                     SSDP_INTERVAL,

                     Settings.Build,

                     uuid,

                     IPADDR2STR(&ip)

                    );



  _server->append(buffer, len);



  ip_addr_t remoteAddr;

  uint16_t remotePort;

  if (method == 0) {

    remoteAddr.addr = _respondToAddr;

    remotePort = _respondToPort;

  } else {

    remoteAddr.addr = SSDP_MULTICAST_ADDR;

    remotePort = SSDP_PORT;

  }

  _server->send(&remoteAddr, remotePort);

  statusLED(true);

}
# 933 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Networking.ino"
void SSDP_update() {



  if (!_pending && _server->next()) {

    ssdp_method_t method = NONE;



    _respondToAddr = _server->getRemoteAddress();

    _respondToPort = _server->getRemotePort();



    typedef enum {METHOD, URI, PROTO, KEY, VALUE, ABORT} states;

    states state = METHOD;



    typedef enum {START, MAN, ST, MX} headers;

    headers header = START;



    uint8_t cursor = 0;

    uint8_t cr = 0;



    char buffer[SSDP_BUFFER_SIZE] = {0};



    while (_server->getSize() > 0) {

      char c = _server->read();



      (c == '\r' || c == '\n') ? cr++ : cr = 0;



      switch (state) {

        case METHOD:

          if (c == ' ') {

            if (strcmp_P(buffer, PSTR("M-SEARCH")) == 0) method = SEARCH;

            else if (strcmp_P(buffer, PSTR("NOTIFY")) == 0) method = NOTIFY;



            if (method == NONE) state = ABORT;

            else state = URI;

            cursor = 0;



          } else if (cursor < SSDP_METHOD_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case URI:

          if (c == ' ') {

            if (strcmp(buffer, "*")) state = ABORT;

            else state = PROTO;

            cursor = 0;

          } else if (cursor < SSDP_URI_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case PROTO:

          if (cr == 2) {

            state = KEY;

            cursor = 0;

          }

          break;

        case KEY:

          if (cr == 4) {

            _pending = true;

            _process_time = millis();

          }

          else if (c == ' ') {

            cursor = 0;

            state = VALUE;

          }

          else if (c != '\r' && c != '\n' && c != ':' && cursor < SSDP_BUFFER_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case VALUE:

          if (cr == 2) {

            switch (header) {

              case START:

                break;

              case MAN:

                break;

              case ST:

                if (strcmp_P(buffer, PSTR("ssdp:all"))) {

                  state = ABORT;

                }



                if (strcmp_P(buffer, PSTR("urn:schemas-upnp-org:device:BinaryLight:1")) == 0) {

                  _pending = true;

                  _process_time = millis();

                  state = KEY;

                }

                break;

              case MX:

                _delay = random(0, atoi(buffer)) * 1000L;

                break;

            }



            if (state != ABORT) {

              state = KEY;

              header = START;

              cursor = 0;

            }

          } else if (c != '\r' && c != '\n') {

            if (header == START) {

              if (strncmp(buffer, "MA", 2) == 0) header = MAN;

              else if (strcmp(buffer, "ST") == 0) header = ST;

              else if (strcmp(buffer, "MX") == 0) header = MX;

            }



            if (cursor < SSDP_BUFFER_SIZE - 1) {

              buffer[cursor++] = c;

              buffer[cursor] = '\0';

            }

          }

          break;

        case ABORT:

          _pending = false; _delay = 0;

          break;

      }

    }

  }



  if (_pending && timeOutReached(_process_time + _delay)) {

    _pending = false; _delay = 0;

    SSDP_send(NONE);

  } else if (_notify_time == 0 || timeOutReached(_notify_time + (SSDP_INTERVAL * 1000L))) {

    _notify_time = millis();

    SSDP_send(NOTIFY);

  }



  if (_pending) {

    while (_server->next())

      _server->flush();

  }

}

#endif





bool WiFiConnected(uint32_t timeout_ms) {

  uint32_t timer = millis() + (timeout_ms > 500 ? 500 : timeout_ms);

  uint32_t min_delay = timeout_ms / 20;

  if (min_delay < 10) {

    yield();

    min_delay = 10;

  }







  while (!WiFiConnected()) {

    if (timeOutReached(timer)) {

      return false;

    }

    delay(min_delay);

  }

  return true;

}



bool hostReachable(const IPAddress& ip) {

  if (!WiFiConnected()) return false;



  byte retry = 3;

  while (retry > 0) {

#if defined(ESP8266)

    if (Ping.ping(ip, 1)) return true;

#endif

#if defined(ESP32)

  if (ping_start(ip, 4, 0, 0, 5)) return true;

#endif

    delay(50);

    --retry;

  }

  String log = F("Host unreachable: ");

  log += formatIP(ip);

  addLog(LOG_LEVEL_ERROR, log);

  if (ip[1] == 0 && ip[2] == 0 && ip[3] == 0) {



    addLog(LOG_LEVEL_ERROR, F("Wifi  : Detected strange behavior, reconnect wifi."));

    WifiDisconnect();

  }

  logConnectionStatus();

  return false;

}



bool hostReachable(const String& hostname) {

  if (!WiFiConnected()) return false;

  IPAddress remote_addr;

  if (WiFi.hostByName(hostname.c_str(), remote_addr)) {

    return hostReachable(remote_addr);

  }

  String log = F("Hostname cannot be resolved: ");

  log += hostname;

  addLog(LOG_LEVEL_ERROR, log);

  return false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/Serial.ino"






#define INPUT_BUFFER_SIZE 128



byte SerialInByte;

int SerialInByteCounter = 0;

char InputBuffer_Serial[INPUT_BUFFER_SIZE + 2];



void serial()

{

  while (Serial.available())

  {

    yield();

    SerialInByte = Serial.read();

    if (SerialInByte == 255)

    {

      Serial.flush();

      return;

    }



    if (isprint(SerialInByte))

    {

      if (SerialInByteCounter < INPUT_BUFFER_SIZE)

        InputBuffer_Serial[SerialInByteCounter++] = SerialInByte;

    }



    if (SerialInByte == '\r' || SerialInByte == '\n')

    {

      if (SerialInByteCounter == 0)

        break;

      InputBuffer_Serial[SerialInByteCounter] = 0;

      Serial.write('>');

      Serial.println(InputBuffer_Serial);

      String action = InputBuffer_Serial;

      struct EventStruct TempEvent;

      parseCommandString(&TempEvent, action);

      TempEvent.Source = VALUE_SOURCE_SERIAL;

      if (!PluginCall(PLUGIN_WRITE, &TempEvent, action))

        ExecuteCommand(VALUE_SOURCE_SERIAL, InputBuffer_Serial);

      SerialInByteCounter = 0;

      InputBuffer_Serial[0] = 0;

    }

  }

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
# 9 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
unsigned long str2int(char *string)

{

  unsigned long temp = atof(string);

  return temp;

}
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
bool string2float(const String& string, float& floatvalue) {

  if (!isFloat(string)) return false;

  floatvalue = atof(string.c_str());

  return true;

}
# 47 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
boolean str2ip(const String& string, byte* IP) {

  return str2ip(string.c_str(), IP);

}



boolean str2ip(const char *string, byte* IP)

{

  IPAddress tmpip;

  if (*string == 0 || tmpip.fromString(string)) {



    for (byte i = 0; i < 4; ++i)

      IP[i] = tmpip[i];

    return true;

  }

  return false;

}
# 85 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
void formatIP(const IPAddress& ip, char (&strIP)[20]) {

  sprintf_P(strIP, PSTR("%u.%u.%u.%u"), ip[0], ip[1], ip[2], ip[3]);

}



String formatIP(const IPAddress& ip) {

  char strIP[20];

  formatIP(ip, strIP);

  return String(strIP);

}



void formatMAC(const uint8_t* mac, char (&strMAC)[20]) {

  sprintf_P(strMAC, PSTR("%02X:%02X:%02X:%02X:%02X:%02X"), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

}



String formatMAC(const uint8_t* mac) {

  char str[20];

  formatMAC(mac, str);

  return String(str);

}
# 131 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
String toString(float value, byte decimals)

{

  String sValue = String(value, decimals);

  sValue.trim();

  return sValue;

}
# 151 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
String doFormatUserVar(byte TaskIndex, byte rel_index, bool mustCheck, bool& isvalid) {

  isvalid = true;

  const byte BaseVarIndex = TaskIndex * VARS_PER_TASK;

  const byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

  if (Device[DeviceIndex].ValueCount <= rel_index) {

    isvalid = false;

    String log = F("No sensor value for TaskIndex: ");

    log += TaskIndex;

    log += F(" varnumber: ");

    log += rel_index;

    addLog(LOG_LEVEL_ERROR, log);

    return "";

  }

  if (Device[DeviceIndex].VType == SENSOR_TYPE_LONG) {

    return String((unsigned long)UserVar[BaseVarIndex] + ((unsigned long)UserVar[BaseVarIndex + 1] << 16));

  }

  float f(UserVar[BaseVarIndex + rel_index]);

  if (mustCheck && !isValidFloat(f)) {

    isvalid = false;

    String log = F("Invalid float value for TaskIndex: ");

    log += TaskIndex;

    log += F(" varnumber: ");

    log += rel_index;

    addLog(LOG_LEVEL_DEBUG, log);

    f = 0;

  }

  return toString(f, ExtraTaskSettings.TaskDeviceValueDecimals[rel_index]);

}



String formatUserVarNoCheck(byte TaskIndex, byte rel_index) {

  bool isvalid;

  return doFormatUserVar(TaskIndex, rel_index, false, isvalid);

}



String formatUserVar(byte TaskIndex, byte rel_index, bool& isvalid) {

  return doFormatUserVar(TaskIndex, rel_index, true, isvalid);

}



String formatUserVarNoCheck(struct EventStruct *event, byte rel_index)

{

  return formatUserVarNoCheck(event->TaskIndex, rel_index);

}



String formatUserVar(struct EventStruct *event, byte rel_index, bool& isvalid)

{

  return formatUserVar(event->TaskIndex, rel_index, isvalid);

}
# 253 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
String wrap_String(const String& string, const String& wrap) {

  String result;

  result.reserve(string.length() + 2* wrap.length());

  result = wrap;

  result += string;

  result += wrap;

  return result;

}
# 277 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
String to_json_object_value(const String& object, const String& value) {

  String result;

  result.reserve(object.length() + value.length() + 6);

  result = wrap_String(object, F("\""));

  result += F(":");

  if (value.length() == 0 || !isFloat(value)) {

    if (value.indexOf('\n') == -1 && value.indexOf('"') == -1 && value.indexOf(F("Pragma")) == -1) {

      result += wrap_String(value, F("\""));

    } else {

      String tmpValue(value);

      tmpValue.replace('\n', '^');

      tmpValue.replace('"', '\'');

      tmpValue.replace(F("Pragma"), F("Bugje!"));

      result += wrap_String(tmpValue, F("\""));

    }

  } else {

    result += value;

  }

  return result;

}
# 327 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
String parseString(String& string, byte indexFind)

{

  String tmpString = string;

  tmpString += ',';

  tmpString.replace(' ', ',');

  String locateString = "";

  byte count = 0;

  int index = tmpString.indexOf(',');

  while (index > 0)

  {

    count++;

    locateString = tmpString.substring(0, index);

    tmpString = tmpString.substring(index + 1);

    index = tmpString.indexOf(',');

    if (count == indexFind)

    {

      locateString.toLowerCase();

      return locateString;

    }

  }

  return "";

}
# 381 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
int getParamStartPos(String& string, byte indexFind)

{

  String tmpString = string;

  byte count = 0;

  tmpString.replace(' ', ',');

  for (unsigned int x = 0; x < tmpString.length(); x++)

  {

    if (tmpString.charAt(x) == ',')

    {

      count++;

      if (count == (indexFind - 1))

        return x + 1;

    }

  }

  return -1;

}





void htmlEscape(String & html)

{

  html.replace("&", F("&amp;"));

  html.replace("\"", F("&quot;"));

  html.replace("'", F("&#039;"));

  html.replace("<", F("&lt;"));

  html.replace(">", F("&gt;"));

}
# 441 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/StringConverter.ino"
void parseControllerVariables(String& s, struct EventStruct *event, boolean useURLencode) {

  parseSystemVariables(s, useURLencode);

  parseEventVariables(s, event, useURLencode);

  parseStandardConversions(s, useURLencode);

}





void repl(const String& key, const String& val, String& s, boolean useURLencode)

{

  if (useURLencode) {

    s.replace(key, URLEncode(val.c_str()));

  } else {

    s.replace(key, val);

  }

}



void parseSpecialCharacters(String& s, boolean useURLencode)

{

  bool no_accolades = s.indexOf('{') == -1 || s.indexOf('}') == -1;

  bool no_html_entity = s.indexOf('&') == -1 || s.indexOf(';') == -1;

  if (no_accolades && no_html_entity)

    return;



  {



    const char degree[3] = {0xc2, 0xb0, 0};

    const char degreeC[4] = {0xe2, 0x84, 0x83, 0};

    const char degree_C[4] = {0xc2, 0xb0, 'C', 0};

    repl(F("{D}"), degree, s, useURLencode);

    repl(F("&deg;"), degree, s, useURLencode);

    repl(degreeC, degree_C, s, useURLencode);

  }

  {



    const char laquo[3] = {0xc2, 0xab, 0};

    const char raquo[3] = {0xc2, 0xbb, 0};

    repl(F("{<<}"), laquo, s, useURLencode);

    repl(F("&laquo;"), laquo, s, useURLencode);

    repl(F("{>>}"), raquo, s, useURLencode);

    repl(F("&raquo;"), raquo, s, useURLencode);

  }

  {



    const char mu[3] = {0xc2, 0xb5, 0};

    repl(F("{u}"), mu, s, useURLencode);

    repl(F("&micro;"), mu, s, useURLencode);

  }

  {



    const char euro[4] = {0xe2, 0x82, 0xac, 0};

    const char yen[3] = {0xc2, 0xa5, 0};

    const char pound[3] = {0xc2, 0xa3, 0};

    const char cent[3] = {0xc2, 0xa2, 0};

    repl(F("{E}"), euro, s, useURLencode);

    repl(F("&euro;"), euro, s, useURLencode);

    repl(F("{Y}"), yen, s, useURLencode);

    repl(F("&yen;"), yen, s, useURLencode);

    repl(F("{P}"), pound, s, useURLencode);

    repl(F("&pound;"), pound, s, useURLencode);

    repl(F("{c}"), cent, s, useURLencode);

    repl(F("&cent;"), cent, s, useURLencode);

  }

  {



    const char sup1[3] = {0xc2, 0xb9, 0};

    const char sup2[3] = {0xc2, 0xb2, 0};

    const char sup3[3] = {0xc2, 0xb3, 0};

    const char frac14[3] = {0xc2, 0xbc, 0};

    const char frac12[3] = {0xc2, 0xbd, 0};

    const char frac34[3] = {0xc2, 0xbe, 0};

    const char plusmn[3] = {0xc2, 0xb1, 0};

    const char times[3] = {0xc3, 0x97, 0};

    const char divide[3] = {0xc3, 0xb7, 0};

    repl(F("{^1}"), sup1, s, useURLencode);

    repl(F("&sup1;"), sup1, s, useURLencode);

    repl(F("{^2}"), sup2, s, useURLencode);

    repl(F("&sup2;"), sup2, s, useURLencode);

    repl(F("{^3}"), sup3, s, useURLencode);

    repl(F("&sup3;"), sup3, s, useURLencode);

    repl(F("{1_4}"), frac14, s, useURLencode);

    repl(F("&frac14;"), frac14, s, useURLencode);

    repl(F("{1_2}"), frac12, s, useURLencode);

    repl(F("&frac12;"), frac12, s, useURLencode);

    repl(F("{3_4}"), frac34, s, useURLencode);

    repl(F("&frac34;"), frac34, s, useURLencode);

    repl(F("{+-}"), plusmn, s, useURLencode);

    repl(F("&plusmn;"), plusmn, s, useURLencode);

    repl(F("{x}"), times, s, useURLencode);

    repl(F("&times;"), times, s, useURLencode);

    repl(F("{..}"), divide, s, useURLencode);

    repl(F("&divide;"), divide, s, useURLencode);

  }

}





#define SMART_REPL(T,S) if (s.indexOf(T) != -1) { repl((T), (S), s, useURLencode);}

void parseSystemVariables(String& s, boolean useURLencode)

{

  parseSpecialCharacters(s, useURLencode);

  if (s.indexOf('%') == -1)

    return;



  #if FEATURE_ADC_VCC

    repl(F("%vcc%"), String(vcc), s, useURLencode);

  #endif

  repl(F("%CR%"), F("\r"), s, useURLencode);

  repl(F("%LF%"), F("\n"), s, useURLencode);

  repl(F("%SP%"), F(" "), s, useURLencode);

  SMART_REPL(F("%ip4%"),WiFi.localIP().toString().substring(WiFi.localIP().toString().lastIndexOf('.')+1))

  SMART_REPL(F("%ip%"),WiFi.localIP().toString())

  SMART_REPL(F("%rssi%"), String((wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? 0 : WiFi.RSSI()))

  SMART_REPL(F("%ssid%"), (wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? F("--") : WiFi.SSID())

  SMART_REPL(F("%bssid%"), (wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? F("00:00:00:00:00:00") : WiFi.BSSIDstr())

  SMART_REPL(F("%wi_ch%"), String((wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? 0 : WiFi.channel()))

  SMART_REPL(F("%unit%"), String(Settings.Unit))

  SMART_REPL(F("%mac%"), String(WiFi.macAddress()))

  #if defined(ESP8266)

    SMART_REPL(F("%mac_int%"), String(ESP.getChipId()))

  #endif



  if (s.indexOf(F("%sys")) != -1) {

    SMART_REPL(F("%sysload%"), String(100 - (100 * loopCounterLast / loopCounterMax)))

    SMART_REPL(F("%sysheap%"), String(ESP.getFreeHeap()));

    SMART_REPL(F("%systm_hm%"), getTimeString(':', false))

    SMART_REPL(F("%systm_hm_am%"), getTimeString_ampm(':', false))

    SMART_REPL(F("%systime%"), getTimeString(':'))

    SMART_REPL(F("%systime_am%"), getTimeString_ampm(':'))

    repl(F("%sysname%"), Settings.Name, s, useURLencode);





    char valueString[5];

    #define SMART_REPL_TIME(T,F,V) if (s.indexOf(T) != -1) { sprintf_P(valueString, (F), (V)); repl((T),valueString, s, useURLencode);}

    SMART_REPL_TIME(F("%syshour%"), PSTR("%02d"), hour())

    SMART_REPL_TIME(F("%sysmin%"), PSTR("%02d"), minute())

    SMART_REPL_TIME(F("%syssec%"),PSTR("%02d"), second())

    SMART_REPL_TIME(F("%syssec_d%"),PSTR("%d"), ((hour()*60) + minute())*60 + second());

    SMART_REPL_TIME(F("%sysday%"), PSTR("%02d"), day())

    SMART_REPL_TIME(F("%sysmonth%"),PSTR("%02d"), month())

    SMART_REPL_TIME(F("%sysyear%"), PSTR("%04d"), year())

    SMART_REPL_TIME(F("%sysyears%"),PSTR("%02d"), year()%100)

    SMART_REPL(F("%sysweekday%"), String(weekday()))

    SMART_REPL(F("%sysweekday_s%"), weekday_str())

    #undef SMART_REPL_TIME

  }

  SMART_REPL(F("%lcltime%"), getDateTimeString('-',':',' '))

  SMART_REPL(F("%lcltime_am%"), getDateTimeString_ampm('-',':',' '))

  SMART_REPL(F("%uptime%"), String(wdcounter / 2))

  SMART_REPL(F("%unixtime%"), String(getUnixTime()))



  repl(F("%tskname%"), ExtraTaskSettings.TaskDeviceName, s, useURLencode);

  if (s.indexOf(F("%vname")) != -1) {

    repl(F("%vname1%"), ExtraTaskSettings.TaskDeviceValueNames[0], s, useURLencode);

    repl(F("%vname2%"), ExtraTaskSettings.TaskDeviceValueNames[1], s, useURLencode);

    repl(F("%vname3%"), ExtraTaskSettings.TaskDeviceValueNames[2], s, useURLencode);

    repl(F("%vname4%"), ExtraTaskSettings.TaskDeviceValueNames[3], s, useURLencode);

  }

}



void parseEventVariables(String& s, struct EventStruct *event, boolean useURLencode)

{

  SMART_REPL(F("%id%"), String(event->idx))

  if (s.indexOf(F("%val")) != -1) {

    if (event->sensorType == SENSOR_TYPE_LONG) {

      SMART_REPL(F("%val1%"), String((unsigned long)UserVar[event->BaseVarIndex] + ((unsigned long)UserVar[event->BaseVarIndex + 1] << 16)))

    } else {

      SMART_REPL(F("%val1%"), formatUserVarNoCheck(event, 0))

      SMART_REPL(F("%val2%"), formatUserVarNoCheck(event, 1))

      SMART_REPL(F("%val3%"), formatUserVarNoCheck(event, 2))

      SMART_REPL(F("%val4%"), formatUserVarNoCheck(event, 3))

    }

  }

}

#undef SMART_REPL



bool getConvertArgument(const String& marker, const String& s, float& argument, int& startIndex, int& endIndex) {

  startIndex = s.indexOf(marker);

  if (startIndex == -1) return false;



  int startIndexArgument = startIndex + marker.length();

  if (s.charAt(startIndexArgument) != '(') {

    return false;

  }

  ++startIndexArgument;

  endIndex = s.indexOf(')', startIndexArgument);

  if (endIndex == -1) return false;



  String argumentString = s.substring(startIndexArgument, endIndex);

  if (argumentString.length() == 0 || !isFloat(argumentString)) return false;



  argument = argumentString.toFloat();

  ++endIndex;

  return true;

}







void parseStandardConversions(String& s, boolean useURLencode) {

  if (s.indexOf(F("%c_")) == -1)

    return;



  float arg = 0.0;

  int startIndex = 0;

  int endIndex = 0;







  #define SMART_CONV(T,FUN) while (getConvertArgument((T), s, arg, startIndex, endIndex)) { repl(s.substring(startIndex, endIndex), (FUN), s, useURLencode); }

  SMART_CONV(F("%c_w_dir%"), getBearing(arg))

  SMART_CONV(F("%c_c2f%"), toString(CelsiusToFahrenheit(arg), 1))

  SMART_CONV(F("%c_ms2Bft%"), String(m_secToBeaufort(arg)))

  SMART_CONV(F("%c_cm2imp%"), centimeterToImperialLength(arg))

  SMART_CONV(F("%c_mm2imp%"), millimeterToImperialLength(arg))

  SMART_CONV(F("%c_m2day%"), toString(minutesToDay(arg), 2))

  SMART_CONV(F("%c_m2dh%"), minutesToDayHour(arg))

  SMART_CONV(F("%c_m2dhm%"), minutesToDayHourMinute(arg))

  SMART_CONV(F("%c_s2dhms%"), secondsToDayHourMinuteSecond(arg))

  #undef SMART_CONV

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
#define SECS_PER_MIN (60UL)

#define SECS_PER_HOUR (3600UL)

#define SECS_PER_DAY (SECS_PER_HOUR * 24UL)

#define DAYS_PER_WEEK (7UL)

#define SECS_PER_WEEK (SECS_PER_DAY * DAYS_PER_WEEK)

#define SECS_PER_YEAR (SECS_PER_WEEK * 52UL)

#define SECS_YR_2000 (946684800UL)

#define LEAP_YEAR(Y) ( ((1970+Y)>0) && !((1970+Y)%4) && ( ((1970+Y)%100) || !((1970+Y)%400) ) )



timeStruct tm;

uint32_t syncInterval = 3600;

uint32_t sysTime = 0;

uint32_t prevMillis = 0;

uint32_t nextSyncTime = 0;



byte PrevMinutes = 0;



void breakTime(unsigned long timeInput, struct timeStruct &tm) {

  uint8_t year;

  uint8_t month, monthLength;

  uint32_t time;

  unsigned long days;

  const uint8_t monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};



  time = (uint32_t)timeInput;

  tm.Second = time % 60;

  time /= 60;

  tm.Minute = time % 60;

  time /= 60;

  tm.Hour = time % 24;

  time /= 24;

  tm.Wday = ((time + 4) % 7) + 1;



  year = 0;

  days = 0;

  while ((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {

    year++;

  }

  tm.Year = year;



  days -= LEAP_YEAR(year) ? 366 : 365;

  time -= days;



  days = 0;

  month = 0;

  monthLength = 0;

  for (month = 0; month < 12; month++) {

    if (month == 1) {

      if (LEAP_YEAR(year)) {

        monthLength = 29;

      } else {

        monthLength = 28;

      }

    } else {

      monthLength = monthDays[month];

    }



    if (time >= monthLength) {

      time -= monthLength;

    } else {

      break;

    }

  }

  tm.Month = month + 1;

  tm.Day = time + 1;

}



void setTime(unsigned long t) {

  sysTime = (uint32_t)t;

  applyTimeZone(t);

  nextSyncTime = (uint32_t)t + syncInterval;

  prevMillis = millis();

  if (Settings.UseRules)

  {

    static bool firstUpdate = true;

    String event = firstUpdate ? F("Time#Initialized") : F("Time#Set");

    firstUpdate = false;

    rulesProcessing(event);

  }

}



uint32_t getUnixTime() {

  return sysTime;

}



unsigned long now() {



  const long msec_passed = timePassedSince(prevMillis);

  const long seconds_passed = msec_passed / 1000;

  sysTime += seconds_passed;

  prevMillis += seconds_passed * 1000;

  if (nextSyncTime <= sysTime) {



    unsigned long t = getNtpTime();

    if (t != 0) {

      setTime(t);

    }

  }

  uint32_t localSystime = toLocal(sysTime);

  breakTime(localSystime, tm);

  return (unsigned long)localSystime;

}



int year(unsigned long t) {

  timeStruct tmp;

  breakTime(t, tmp);

  return 1970 + tmp.Year;

}



int weekday(unsigned long t) {

  timeStruct tmp;

  breakTime(t, tmp);

  return tmp.Wday;

}







int year()

{

  return 1970 + tm.Year;

}



byte month()

{

 return tm.Month;

}



byte day()

{

 return tm.Day;

}



byte hour()

{

  return tm.Hour;

}



byte minute()

{

  return tm.Minute;

}



byte second()

{

 return tm.Second;

}





int weekday()

{

  return tm.Wday;

}



String weekday_str()

{

  const int wday(weekday() - 1);

  const String weekDays = F("SunMonTueWedThuFriSat");

  return weekDays.substring(wday * 3, wday * 3 + 3);

}



void initTime()

{

  nextSyncTime = 0;

  now();

}



void checkTime()

{

  now();

  if (tm.Minute != PrevMinutes)

  {

    PluginCall(PLUGIN_CLOCK_IN, 0, dummyString);

    PrevMinutes = tm.Minute;

    if (Settings.UseRules)

    {

      String event;

      event.reserve(21);

      event = F("Clock#Time=");

      event += weekday_str();

      event += ",";

      if (hour() < 10)

        event += "0";

      event += hour();

      event += ":";

      if (minute() < 10)

        event += "0";

      event += minute();

      rulesProcessing(event);

    }

  }

}





unsigned long getNtpTime()

{

  if (!Settings.UseNTP || !WiFiConnected(10)) {

    return 0;

  }

  IPAddress timeServerIP;

  String log = F("NTP  : NTP host ");

  if (Settings.NTPHost[0] != 0) {

    WiFi.hostByName(Settings.NTPHost, timeServerIP);

    log += Settings.NTPHost;



    nextSyncTime = sysTime + 20;

  }

  else {



    String ntpServerName = String(random(0, 3));

    ntpServerName += F(".pool.ntp.org");

    WiFi.hostByName(ntpServerName.c_str(), timeServerIP);

    log += ntpServerName;



    nextSyncTime = sysTime + 5;

  }



  log += F(" (");

  log += timeServerIP.toString();

  log += F(")");



  if (!hostReachable(timeServerIP)) {

    log += F(" unreachable");

    addLog(LOG_LEVEL_INFO, log);

    return 0;

  }



  WiFiUDP udp;

  udp.begin(123);



  const int NTP_PACKET_SIZE = 48;

  byte packetBuffer[NTP_PACKET_SIZE];



  log += F(" queried");

  addLog(LOG_LEVEL_DEBUG_MORE, log);



  while (udp.parsePacket() > 0) ;



  memset(packetBuffer, 0, NTP_PACKET_SIZE);

  packetBuffer[0] = 0b11100011;

  packetBuffer[1] = 0;

  packetBuffer[2] = 6;

  packetBuffer[3] = 0xEC;

  packetBuffer[12] = 49;

  packetBuffer[13] = 0x4E;

  packetBuffer[14] = 49;

  packetBuffer[15] = 52;

  udp.beginPacket(timeServerIP, 123);

  udp.write(packetBuffer, NTP_PACKET_SIZE);

  udp.endPacket();



  uint32_t beginWait = millis();

  while (!timeOutReached(beginWait + 1000)) {

    int size = udp.parsePacket();

    if (size >= NTP_PACKET_SIZE) {

      udp.read(packetBuffer, NTP_PACKET_SIZE);

      unsigned long secsSince1900;



      secsSince1900 = (unsigned long)packetBuffer[40] << 24;

      secsSince1900 |= (unsigned long)packetBuffer[41] << 16;

      secsSince1900 |= (unsigned long)packetBuffer[42] << 8;

      secsSince1900 |= (unsigned long)packetBuffer[43];

      log = F("NTP  : NTP replied: ");

      log += timePassedSince(beginWait);

      log += F(" mSec");

      addLog(LOG_LEVEL_DEBUG_MORE, log);

      return secsSince1900 - 2208988800UL;

    }

    delay(10);

  }

  log = F("NTP  : No reply");

  addLog(LOG_LEVEL_DEBUG_MORE, log);

  return 0;

}
# 577 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
long timeDiff(const unsigned long prev, const unsigned long next)

{

  long signed_diff = 0;



  const unsigned long half_max_unsigned_long = 2147483647u;

  if (next >= prev) {

    const unsigned long diff = next - prev;

    if (diff <= half_max_unsigned_long) {





      signed_diff = static_cast<long>(diff);

    } else {



      signed_diff = static_cast<long>((ULONG_MAX - next) + prev + 1u);

      signed_diff = -1 * signed_diff;

    }

  } else {



    const unsigned long diff = prev - next;

    if (diff <= half_max_unsigned_long) {



      signed_diff = static_cast<long>(diff);

      signed_diff = -1 * signed_diff;

    } else {



      signed_diff = static_cast<long>((ULONG_MAX - prev) + next + 1u);

    }

  }

  return signed_diff;

}







long timePassedSince(unsigned long timestamp) {

  return timeDiff(timestamp, millis());

}





boolean timeOutReached(unsigned long timer)

{

  const long passed = timePassedSince(timer);

  return passed >= 0;

}



void setNextTimeInterval(unsigned long& timer, const unsigned long step) {

  timer += step;

  const long passed = timePassedSince(timer);

  if (passed < 0) {



    return;

  }

  if (static_cast<unsigned long>(passed) > step) {



    timer = millis() + step;

    return;

  }



  timer = millis() + (step - passed);

}
# 705 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
String timeLong2String(unsigned long lngTime)

{

  unsigned long x = 0;

  String time = "";



  x = (lngTime >> 16) & 0xf;

  if (x == 0x0f)

    x = 0;

  String weekDays = F("AllSunMonTueWedThuFriSatWrkWkd");

  time = weekDays.substring(x * 3, x * 3 + 3);

  time += ",";



  x = (lngTime >> 12) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  x = (lngTime >> 8) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  time += ":";



  x = (lngTime >> 4) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  x = (lngTime) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  return time;

}







String getDateString(const timeStruct& ts, char delimiter) {

  char DateString[20];

  const int year = 1970 + ts.Year;

  sprintf_P(DateString, PSTR("%4d%c%02d%c%02d"), year, delimiter, ts.Month, delimiter, ts.Day);

  return DateString;

}



String getDateString(char delimiter)

{

  return getDateString(tm, delimiter);

}







String getDateString()

{

 return getDateString('\0');

}







String getTimeString(const timeStruct& ts, char delimiter, bool am_pm, bool show_seconds)

{

  char TimeString[20];

  if (am_pm) {

    uint8_t hour(ts.Hour % 12);

    if (hour == 0) { hour = 12; }

    const char a_or_p = ts.Hour < 12 ? 'A' : 'P';

    if (show_seconds) {

      sprintf_P(TimeString, PSTR("%d%c%02d%c%02d %cM"),

        hour, delimiter, ts.Minute, delimiter, ts.Second, a_or_p);

    } else {

      sprintf_P(TimeString, PSTR("%d%c%02d %cM"),

        hour, delimiter, ts.Minute, a_or_p);

    }

  } else {

    if (show_seconds) {

      sprintf_P(TimeString, PSTR("%02d%c%02d%c%02d"),

        ts.Hour, delimiter, ts.Minute, delimiter, ts.Second);

    } else {

      sprintf_P(TimeString, PSTR("%d%c%02d"),

        ts.Hour, delimiter, ts.Minute);

    }

  }

  return TimeString;

}



String getTimeString(char delimiter, bool show_seconds )

{

  return getTimeString(tm, delimiter, false, show_seconds);

}



String getTimeString_ampm(char delimiter, bool show_seconds )

{

  return getTimeString(tm, delimiter, true, show_seconds);

}







String getTimeString()

{

 return getTimeString('\0');

}



String getTimeString_ampm()

{

 return getTimeString_ampm('\0');

}
# 951 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
String getDateTimeString(const timeStruct& ts, char dateDelimiter, char timeDelimiter, char dateTimeDelimiter, bool am_pm)

{

 String ret = getDateString(ts, dateDelimiter);

 if (dateTimeDelimiter != '\0')

  ret += dateTimeDelimiter;

 ret += getTimeString(ts, timeDelimiter, am_pm, true);

 return ret;

}



String getDateTimeString(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter) {

  return getDateTimeString(tm, dateDelimiter, timeDelimiter, dateTimeDelimiter, false);

}



String getDateTimeString_ampm(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter) {

  return getDateTimeString(tm, dateDelimiter, timeDelimiter, dateTimeDelimiter, true);

}
# 991 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
unsigned long string2TimeLong(const String &str)

{







  char command[20];

  char TmpStr1[10];

  int w, x, y;

  unsigned long a;

  {



    String tmpString(str);

    tmpString.toLowerCase();

    tmpString.toCharArray(command, 20);

  }

  unsigned long lngTime = 0;



  if (GetArgv(command, TmpStr1, 1))

  {

    String day = TmpStr1;

    String weekDays = F("allsunmontuewedthufrisatwrkwkd");

    y = weekDays.indexOf(TmpStr1) / 3;

    if (y == 0)

      y = 0xf;

    lngTime |= (unsigned long)y << 16;

  }



  if (GetArgv(command, TmpStr1, 2))

  {

    y = 0;

    for (x = strlen(TmpStr1) - 1; x >= 0; x--)

    {

      w = TmpStr1[x];

      if ( (w >= '0' && w <= '9') || w == '*')

      {

        a = 0xffffffff ^ (0xfUL << y);

        lngTime &= a;

        if (w == '*')

          lngTime |= (0xFUL << y);

        else

          lngTime |= (w - '0') << y;

        y += 4;

      }

      else

        if (w == ':');

      else

      {

        break;

      }

    }

  }

  return lngTime;

}
# 1105 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeESPeasy.ino"
boolean matchClockEvent(unsigned long clockEvent, unsigned long clockSet)

{

  unsigned long Mask;

  for (byte y = 0; y < 8; y++)

  {

    if (((clockSet >> (y * 4)) & 0xf) == 0xf)

    {

      Mask = 0xffffffff ^ (0xFUL << (y * 4));

      clockEvent &= Mask;

      clockEvent |= (0xFUL << (y * 4));

    }

  }



  if (((clockSet >> (16)) & 0xf) == 0x8)

    if (weekday() >= 2 and weekday() <= 6)

    {

      Mask = 0xffffffff ^ (0xFUL << (16));

      clockEvent &= Mask;

      clockEvent |= (0x8UL << (16));

    }



  if (((clockSet >> (16)) & 0xf) == 0x9)

    if (weekday() == 1 or weekday() == 7)

    {

      Mask = 0xffffffff ^ (0xFUL << (16));

      clockEvent &= Mask;

      clockEvent |= (0x9UL << (16));

    }



  if (clockEvent == clockSet)

    return true;

  return false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
TimeChangeRule m_dst;

TimeChangeRule m_std;

uint32_t m_dstUTC = 0;

uint32_t m_stdUTC = 0;

uint32_t m_dstLoc = 0;

uint32_t m_stdLoc = 0;
# 119 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
void getDefaultDst_flash_values(uint16_t& start, uint16_t& end) {





  TimeChangeRule CEST(Last, Sun, Mar, 2, Settings.TimeZone);

  TimeChangeRule CET(Last, Sun, Oct, 3, Settings.TimeZone);

  start = CEST.toFlashStoredValue();

  end = CET.toFlashStoredValue();

}



void applyTimeZone(uint32_t curTime) {

  int dst_offset = Settings.DST ? 60 : 0;

  uint16_t tmpStart(Settings.DST_Start);

  uint16_t tmpEnd(Settings.DST_End);

  for (int i = 0; i < 2; ++i) {

    TimeChangeRule start(tmpStart, Settings.TimeZone + dst_offset);

    TimeChangeRule end(tmpEnd, Settings.TimeZone);

    if (start.isValid() && end.isValid()) {

      setTimeZone(start, end, curTime);

      return;

    }

    getDefaultDst_flash_values(tmpStart, tmpEnd);

  }

}



void setTimeZone(const TimeChangeRule& dstStart, const TimeChangeRule& stdStart, uint32_t curTime) {

  m_dst = dstStart;

  m_std = stdStart;

  if (calcTimeChanges(year(curTime))) {

    logTimeZoneInfo();

  }

}



void logTimeZoneInfo() {

  String log = F("Current Time Zone: ");

  if (m_std.offset != m_dst.offset) {



    log += F(" DST time start: ");

    if (m_dstLoc != 0) {

      timeStruct tmp;

      breakTime(m_dstLoc, tmp);

      log += getDateTimeString(tmp, '-', ':', ' ', false);

    }

    log += F(" offset: ");

    log += m_dst.offset;

    log += F(" min");

  }



  log += F("STD time start: ");

  if (m_stdLoc != 0) {

    timeStruct tmp;

    breakTime(m_stdLoc, tmp);

    log += getDateTimeString(tmp, '-', ':', ' ', false);

  }

  log += F(" offset: ");

  log += m_std.offset;

  log += F(" min");

  addLog(LOG_LEVEL_INFO, log);

}



uint32_t makeTime(const timeStruct &tm) {







  const uint8_t monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

  int i;

  uint32_t seconds;





  seconds= tm.Year*(SECS_PER_DAY * 365);

  for (i = 0; i < tm.Year; i++) {

    if (LEAP_YEAR(i)) {

      seconds += SECS_PER_DAY;

    }

  }





  for (i = 1; i < tm.Month; i++) {

    if ( (i == 2) && LEAP_YEAR(tm.Year)) {

      seconds += SECS_PER_DAY * 29;

    } else {

      seconds += SECS_PER_DAY * monthDays[i-1];

    }

  }

  seconds+= (tm.Day-1) * SECS_PER_DAY;

  seconds+= tm.Hour * SECS_PER_HOUR;

  seconds+= tm.Minute * SECS_PER_MIN;

  seconds+= tm.Second;

  return (uint32_t)seconds;

}
# 309 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
uint32_t calcTimeChangeForRule(const TimeChangeRule& r, int yr)

{

    uint8_t m = r.month;

    uint8_t w = r.week;

    if (w == 0)

    {

        if (++m > 12)

        {

            m = 1;

            ++yr;

        }

        w = 1;

    }





    timeStruct tm;

    tm.Hour = r.hour;

    tm.Minute = 0;

    tm.Second = 0;

    tm.Day = 1;

    tm.Month = m;

    tm.Year = yr - 1970;

    uint32_t t = makeTime(tm);





    t += ( (r.dow - weekday(t) + 7) % 7 + (w - 1) * 7 ) * SECS_PER_DAY;



    if (r.week == 0) t -= 7 * SECS_PER_DAY;

    return t;

}
# 381 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
bool calcTimeChanges(int yr)

{

  uint32_t dstLoc = calcTimeChangeForRule(m_dst, yr);

  uint32_t stdLoc = calcTimeChangeForRule(m_std, yr);

  bool changed = (m_dstLoc != dstLoc) || (m_stdLoc != stdLoc);

  m_dstLoc = dstLoc;

  m_stdLoc = stdLoc;

  m_dstUTC = m_dstLoc - m_std.offset * SECS_PER_MIN;

  m_stdUTC = m_stdLoc - m_dst.offset * SECS_PER_MIN;

  return changed;

}
# 413 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
uint32_t toLocal(uint32_t utc)

{



    if (year(utc) != year(m_dstUTC)) calcTimeChanges(year(utc));



    if (utcIsDST(utc))

        return utc + m_dst.offset * SECS_PER_MIN;

    else

        return utc + m_std.offset * SECS_PER_MIN;

}
# 445 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
bool utcIsDST(uint32_t utc)

{



    if (year(utc) != year(m_dstUTC)) calcTimeChanges(year(utc));



    if (m_stdUTC == m_dstUTC)

        return false;

    else if (m_stdUTC > m_dstUTC)

        return (utc >= m_dstUTC && utc < m_stdUTC);

    else

        return !(utc >= m_stdUTC && utc < m_dstUTC);

}
# 479 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/TimeZoneESPeasy.ino"
bool locIsDST(uint32_t local)

{



    if (year(local) != year(m_dstLoc)) calcTimeChanges(year(local));



    if (m_stdUTC == m_dstUTC)

        return false;

    else if (m_stdLoc > m_dstLoc)

        return (local >= m_dstLoc && local < m_stdLoc);

    else

        return !(local >= m_stdLoc && local < m_dstLoc);

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"






#define ALL_ALLOWED 0

#define LOCAL_SUBNET_ALLOWED 1

#define ONLY_IP_RANGE_ALLOWED 2

#define _HEAD false

#define _TAIL true

#define CHUNKED_BUFFER_SIZE 400



void sendContentBlocking(String& data);

void sendHeaderBlocking(bool json);



class StreamingBuffer {

private:

  bool lowMemorySkip;



public:

  uint32_t initialRam;

  uint32_t beforeTXRam;

  uint32_t duringTXRam;

  uint32_t finalRam;

  uint32_t maxCoreUsage;

  uint32_t maxServerUsage;

  unsigned int sentBytes;

  uint32_t flashStringCalls;

  uint32_t flashStringData;

  String buf;



  StreamingBuffer(void) : lowMemorySkip(false),

    initialRam(0), beforeTXRam(0), duringTXRam(0), finalRam(0), maxCoreUsage(0),

    maxServerUsage(0), sentBytes(0), flashStringCalls(0), flashStringData(0)

  {

    buf.reserve(CHUNKED_BUFFER_SIZE + 50);

    buf = "";

  }

  StreamingBuffer operator= (String& a) { flush(); return addString(a); }

  StreamingBuffer operator= (const String& a) { flush(); return addString(a); }

  StreamingBuffer operator+= (char a) { return addString(String(a)); }

  StreamingBuffer operator+= (long unsigned int a) { return addString(String(a)); }

  StreamingBuffer operator+= (float a) { return addString(String(a)); }

  StreamingBuffer operator+= (int a) { return addString(String(a)); }

  StreamingBuffer operator+= (uint32_t a) { return addString(String(a)); }

  StreamingBuffer operator+= (const String& a) { return addString(a); }



  StreamingBuffer operator+= (PGM_P str) {

    ++flashStringCalls;

    if (!str) return *this;

    if (lowMemorySkip) return *this;

    int flush_step = CHUNKED_BUFFER_SIZE - this->buf.length();

    if (flush_step < 1) flush_step = 0;

    unsigned int pos = 0;

    const unsigned int length = strlen_P((PGM_P)str);

    if (length == 0) return *this;

    flashStringData += length;

    while (pos < length) {

      if (flush_step == 0) {

        sendContentBlocking(this->buf);

        flush_step = CHUNKED_BUFFER_SIZE;

      }

      this->buf += (char)pgm_read_byte(&str[pos]);

      ++pos;

      --flush_step;

    }

    checkFull();

    return *this;

  }





  StreamingBuffer addString(const String& a) {

    if (lowMemorySkip) return *this;

    int flush_step = CHUNKED_BUFFER_SIZE - this->buf.length();

    if (flush_step < 1) flush_step = 0;

    int pos = 0;

    const int length = a.length();

    while (pos < length) {

      if (flush_step == 0) {

        sendContentBlocking(this->buf);

        flush_step = CHUNKED_BUFFER_SIZE;

      }

      this->buf += a[pos];

      ++pos;

      --flush_step;

    }

    checkFull();

    return *this;

  }



  void flush() {

    if (lowMemorySkip) {

      this->buf = "";

    } else {

      sendContentBlocking(this->buf);

    }

  }



  void checkFull(void) {

    if (lowMemorySkip) this->buf = "";

    if (this->buf.length() > CHUNKED_BUFFER_SIZE) {

      trackTotalMem();

      sendContentBlocking(this->buf);

    }

  }



  void startStream() {

    startStream(false);

  }



  void startJsonStream() {

    startStream(true);

  }



private:

  void startStream(bool json) {

    maxCoreUsage = maxServerUsage = 0;

    initialRam = ESP.getFreeHeap();

    beforeTXRam = initialRam;

    sentBytes = 0;

    buf = "";

    if (beforeTXRam < 3000) {

      lowMemorySkip = true;

      WebServer.send(200, "text/plain", "Low memory. Cannot display webpage :-(");

       #if defined(ESP8266)

         tcpCleanup();

       #endif

      return;

    } else

      sendHeaderBlocking(json);

  }



  void trackTotalMem() {

    beforeTXRam = ESP.getFreeHeap();

    if ((initialRam - beforeTXRam) > maxServerUsage)

      maxServerUsage = initialRam - beforeTXRam;

  }



public:



  void trackCoreMem() {

    duringTXRam = ESP.getFreeHeap();

    if ((initialRam - duringTXRam) > maxCoreUsage)

      maxCoreUsage = (initialRam - duringTXRam);

  }



  void endStream(void) {

    if (!lowMemorySkip) {

      if (buf.length() > 0) sendContentBlocking(buf);

      buf = "";

      sendContentBlocking(buf);

      finalRam = ESP.getFreeHeap();

      String log = String("Ram usage: Webserver only: ") + maxServerUsage +

                   " including Core: " + maxCoreUsage +

                   " flashStringCalls: " + flashStringCalls +

                   " flashStringData: " + flashStringData;

      addLog(LOG_LEVEL_DEBUG, log);

    } else {

      String log = String("Webpage skipped: low memory: ") + finalRam;

      addLog(LOG_LEVEL_DEBUG, log);

      lowMemorySkip = false;

    }

  }

} TXBuffer;



void sendContentBlocking(String& data) {

  checkRAM(F("sendContentBlocking"));

  uint32_t freeBeforeSend = ESP.getFreeHeap();

  const uint32_t length = data.length();

  String log = String("sendcontent free: ") + freeBeforeSend + " chunk size:" + length;

  addLog(LOG_LEVEL_DEBUG_DEV, log);

  freeBeforeSend = ESP.getFreeHeap();

  if (TXBuffer.beforeTXRam > freeBeforeSend)

    TXBuffer.beforeTXRam = freeBeforeSend;

  TXBuffer.duringTXRam = freeBeforeSend;

#if defined(ESP8266) && defined(ARDUINO_ESP8266_RELEASE_2_3_0)

  String size = String(length, HEX) + "\r\n";



  WebServer.sendContent(size);

  if (length > 0) WebServer.sendContent(data);

  WebServer.sendContent("\r\n");

#else

  unsigned int timeout = 0;

  if (freeBeforeSend < 5000) timeout = 100;

  if (freeBeforeSend < 4000) timeout = 1000;

  const uint32_t beginWait = millis();

  WebServer.sendContent(data);

  while ((ESP.getFreeHeap() < freeBeforeSend) &&

         !timeOutReached(beginWait + timeout)) {

    if (ESP.getFreeHeap() < TXBuffer.duringTXRam)

      TXBuffer.duringTXRam = ESP.getFreeHeap();

    ;

    TXBuffer.trackCoreMem();

    checkRAM(F("duringDataTX"));

    delay(1);

  }

#endif



  TXBuffer.sentBytes += length;

  data = "";

  yield();

}



void sendHeaderBlocking(bool json) {

  checkRAM(F("sendHeaderBlocking"));

  WebServer.client().flush();

#if defined(ESP8266) && defined(ARDUINO_ESP8266_RELEASE_2_3_0)

  WebServer.setContentLength(CONTENT_LENGTH_UNKNOWN);

  WebServer.sendHeader(F("Content-Type"), json ? F("application/json") : F("text/html"), true);

  WebServer.sendHeader(F("Accept-Ranges"), F("none"));

  WebServer.sendHeader(F("Cache-Control"), F("no-cache"));

  WebServer.sendHeader(F("Transfer-Encoding"), F("chunked"));

  if (json)

    WebServer.sendHeader(F("Access-Control-Allow-Origin"),"*");

  WebServer.send(200);

#else

  unsigned int timeout = 0;

  uint32_t freeBeforeSend = ESP.getFreeHeap();

  if (freeBeforeSend < 5000) timeout = 100;

  if (freeBeforeSend < 4000) timeout = 1000;

  const uint32_t beginWait = millis();

  WebServer.setContentLength(CONTENT_LENGTH_UNKNOWN);

  WebServer.sendHeader(F("Content-Type"), json ? F("application/json") : F("text/html"), true);

  WebServer.sendHeader(F("Cache-Control"), F("no-cache"));

  if (json)

    WebServer.sendHeader(F("Access-Control-Allow-Origin"),"*");

  WebServer.send(200);



  while ((ESP.getFreeHeap() < freeBeforeSend) &&

         !timeOutReached(beginWait + timeout)) {

    checkRAM(F("duringHeaderTX"));

    delay(1);

  }

#endif

  yield();

}



void sendHeadandTail(const String& tmplName, boolean Tail = false) {

  String pageTemplate = "";

  int indexStart, indexEnd;

  String varName;

  String fileName = tmplName;

  fileName += F(".htm");

  fs::File f = SPIFFS.open(fileName, "r+");



  if (f) {

    pageTemplate.reserve(f.size());

    while (f.available()) pageTemplate += (char)f.read();

    f.close();

  } else {

    getWebPageTemplateDefault(tmplName, pageTemplate);

  }

  checkRAM(F("sendWebPage"));



  lastWeb = millis();



  if (Tail) {

    TXBuffer += pageTemplate.substring(

        11 +

        pageTemplate.indexOf(F("{{content}}")));

  } else {

    while ((indexStart = pageTemplate.indexOf(F("{{"))) >= 0) {

      TXBuffer += pageTemplate.substring(0, indexStart);

      pageTemplate = pageTemplate.substring(indexStart);

      if ((indexEnd = pageTemplate.indexOf(F("}}"))) > 0) {

        varName = pageTemplate.substring(2, indexEnd);

        pageTemplate = pageTemplate.substring(indexEnd + 2);

        varName.toLowerCase();



        if (varName == F("content")) {

          break;

        } else if (varName == F("error")) {

          getErrorNotifications();

        } else {

          getWebPageTemplateVar(varName);

        }

      } else {

        pageTemplate = pageTemplate.substring(2);

      }

    }

  }

  if (shouldReboot) {



    TXBuffer += jsReboot;

  }

}







boolean ipLessEqual(const IPAddress& ip, const IPAddress& high)

{

  for (byte i = 0; i < 4; ++i) {

    if (ip[i] > high[i]) return false;

  }

  return true;

}



boolean ipInRange(const IPAddress& ip, const IPAddress& low, const IPAddress& high)

{

  return (ipLessEqual(low, ip) && ipLessEqual(ip, high));

}



String describeAllowedIPrange() {

  String reply;

  switch (SecuritySettings.IPblockLevel) {

    case ALL_ALLOWED:

     reply += F("All Allowed");

      break;

    default:

    {

      IPAddress low, high;

      getIPallowedRange(low, high);

      reply += formatIP(low);

      reply += F(" - ");

      reply += formatIP(high);

    }

  }

  return reply;

}



bool getIPallowedRange(IPAddress& low, IPAddress& high)

{

  switch (SecuritySettings.IPblockLevel) {

    case LOCAL_SUBNET_ALLOWED:

      return getSubnetRange(low, high);

    case ONLY_IP_RANGE_ALLOWED:

      low = SecuritySettings.AllowedIPrangeLow;

      high = SecuritySettings.AllowedIPrangeHigh;

      break;

    default:

      low = IPAddress(0,0,0,0);

      high = IPAddress(255,255,255,255);

      return false;

  }

  return true;

}



boolean clientIPallowed()

{



  IPAddress low, high;

  if (!getIPallowedRange(low, high))

  {



    return true;

  }

  WiFiClient client(WebServer.client());

  if (ipInRange(client.remoteIP(), low, high))

    return true;



  if (WifiIsAP(WiFi.getMode())) {



    return true;

  }

  String response = F("IP blocked: ");

  response += formatIP(client.remoteIP());

  WebServer.send(403, "text/html", response);

  response += F(" Allowed: ");

  response += formatIP(low);

  response += F(" - ");

  response += formatIP(high);

  addLog(LOG_LEVEL_ERROR, response);

  return false;

}



void clearAccessBlock()

{

  SecuritySettings.IPblockLevel = ALL_ALLOWED;

}
# 745 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
#define HTML_SYMBOL_WARNING "&#9888;"



#if defined(ESP8266)

  #define TASKS_PER_PAGE 12

#endif

#if defined(ESP32)

  #define TASKS_PER_PAGE 32

#endif







void addHtmlError(String error){

  if (error.length()>0)

  {

    TXBuffer += F("<div class=\"alert\"><span class=\"closebtn\" onclick=\"this.parentElement.style.display='none';\">&times;</span>");

    TXBuffer += error;

    TXBuffer += F("</div>");

  }

  else

  {

    TXBuffer += jsToastMessageBegin;



    TXBuffer += F("Submitted");

    TXBuffer += jsToastMessageEnd;

  }

}



void addHtml(const String html) {

  TXBuffer += html;

}



void WebServerInit()

{



  WebServer.on(F("/"), handle_root);

  WebServer.on(F("/config"), handle_config);

  WebServer.on(F("/controllers"), handle_controllers);

  WebServer.on(F("/hardware"), handle_hardware);

  WebServer.on(F("/devices"), handle_devices);

  WebServer.on(F("/notifications"), handle_notifications);

  WebServer.on(F("/log"), handle_log);

  WebServer.on(F("/logjson"), handle_log_JSON);

  WebServer.on(F("/tools"), handle_tools);

  WebServer.on(F("/i2cscanner"), handle_i2cscanner);

  WebServer.on(F("/wifiscanner"), handle_wifiscanner);

  WebServer.on(F("/login"), handle_login);

  WebServer.on(F("/control"), handle_control);

  WebServer.on(F("/download"), handle_download);

  WebServer.on(F("/upload"), HTTP_GET, handle_upload);

  WebServer.on(F("/upload"), HTTP_POST, handle_upload_post, handleFileUpload);

  WebServer.onNotFound(handleNotFound);

  WebServer.on(F("/filelist"), handle_filelist);

#ifdef FEATURE_SD

  WebServer.on(F("/SDfilelist"), handle_SDfilelist);

#endif

  WebServer.on(F("/advanced"), handle_advanced);

  WebServer.on(F("/setup"), handle_setup);

  WebServer.on(F("/json"), handle_json);

  WebServer.on(F("/rules"), handle_rules);

  WebServer.on(F("/sysinfo"), handle_sysinfo);

  WebServer.on(F("/pinstates"), handle_pinstates);

  WebServer.on(F("/favicon.ico"), handle_favicon);



  #if defined(ESP8266)

    if (ESP.getFlashChipRealSize() > 524288)

      httpUpdater.setup(&WebServer);

  #endif



  #if defined(ESP8266)

  if (Settings.UseSSDP)

  {

    WebServer.on(F("/ssdp.xml"), HTTP_GET, []() {

      WiFiClient client(WebServer.client());

      SSDP_schema(client);

    });

    SSDP_begin();

  }

  #endif

}



void setWebserverRunning(bool state) {

  if (webserver_state == state)

    return;

  if (state) {

    if (!webserver_init) {

      WebServerInit();

      webserver_init = true;

    }

    WebServer.begin();

    addLog(LOG_LEVEL_INFO, F("Webserver: start"));

  } else {

    WebServer.stop();

    addLog(LOG_LEVEL_INFO, F("Webserver: stop"));

  }

  webserver_state = state;

}





void getWebPageTemplateDefault(const String& tmplName, String& tmpl)

{

  if (tmplName == F("TmplAP"))

  {

    tmpl += F(

              "<!DOCTYPE html><html lang='en'>"

              "<head>"

              "<meta charset='utf-8'/>"

              "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

              "<title>{{name}}</title>"

              "{{css}}"

              "</head>"

              "<body>"

              "<header class='apheader'>"

              "<h1>Welcome to ESP Easy Mega AP</h1>"

              "</header>"

              "<section>"

              "<span class='message error'>"

              "{{error}}"

              "</span>"

              "{{content}}"

              "</section>"

              "<footer>"

                "<br>"

                "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

              "</footer>"

              "</body>" );

  }

  else if (tmplName == F("TmplMsg"))

  {

    tmpl += F(

              "<!DOCTYPE html><html lang='en'>"

              "<head>"

              "<meta charset='utf-8'/>"

              "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

              "<title>{{name}}</title>"

              "{{css}}"

              "</head>"

              "<body>"

              "<header class='headermenu'>"

              "<h1>ESP Easy Mega: {{name}}</h1><div class='menu_button'>&#9776;</div><BR>"

              "</header>"

              "<section>"

              "<span class='message error'>"

              "{{error}}"

              "</span>"

              "{{content}}"

              "</section>"

              "<footer>"

                "<br>"

                "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

              "</footer>"

              "</body>"

            );

  }

  else if (tmplName == F("TmplDsh"))

  {

    tmpl += F(

      "<!DOCTYPE html><html lang='en'>"

      "<head>"

        "<meta charset='utf-8'/>"

        "<title>{{name}}</title>"

        "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

        "{{js}}"

        "{{css}}"

        "</head>"

        "<body>"

        "{{content}}"

        "</body></html>"

            );

  }

  else

  {

    tmpl += F(

      "<!DOCTYPE html><html lang='en'>"

      "<head>"

        "<meta charset='utf-8'/>"

        "<title>{{name}}</title>"

        "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

        "{{js}}"

        "{{css}}"

      "</head>"

      "<body class='bodymenu'>"

        "<span class='message' id='rbtmsg'></span>"

        "<header class='headermenu'>"

          "<h1>ESP Easy Mega: {{name}} {{logo}}</h1><div class='menu_button'>&#9776;</div><BR>"

          "{{menu}}"

        "</header>"

        "<section>"

        "<span class='message error'>"

        "{{error}}"

        "</span>"

        "{{content}}"

        "</section>"

        "<footer>"

          "<br>"

          "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

        "</footer>"

      "</body></html>"

            );

  }

}





void getErrorNotifications() {



  int nrMQTTenabled = 0;

  for (byte x = 0; x < CONTROLLER_MAX; x++) {

    if (Settings.Protocol[x] != 0) {

      byte ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

      if (Settings.ControllerEnabled[x] && Protocol[ProtocolIndex].usesMQTT) {

        ++nrMQTTenabled;

      }

    }

  }

  if (nrMQTTenabled > 1) {



    addHtmlError(F("Only one MQTT controller should be active."));

  }



}





static byte navMenuIndex = 0;



void getWebPageTemplateVar(const String& varName )

{







  if (varName == F("name"))

  {

    TXBuffer += Settings.Name;

  }



  else if (varName == F("unit"))

  {

    TXBuffer += String(Settings.Unit);

  }



  else if (varName == F("menu"))

  {

    static const __FlashStringHelper* gpMenu[8][2] = {

      F("Main"), F("."),

      F("Config"), F("config"),

      F("Controllers"), F("controllers"),

      F("Hardware"), F("hardware"),

      F("Devices"), F("devices"),

      F("Rules"), F("rules"),

      F("Notifications"), F("notifications"),

      F("Tools"), F("tools"),

    };



    TXBuffer += F("<div class='menubar'>");



    for (byte i = 0; i < 8; i++)

    {

      if (i == 5 && !Settings.UseRules)

        continue;



      TXBuffer += F("<a class='menu");

      if (i == navMenuIndex)

        TXBuffer += F(" active");

      TXBuffer += F("' href='");

      TXBuffer += gpMenu[i][1];

      TXBuffer += F("'>");

      TXBuffer += gpMenu[i][0];

      TXBuffer += F("</a>");

    }



    TXBuffer += F("</div>");

  }



  else if (varName == F("logo"))

  {

    if (SPIFFS.exists(F("esp.png")))

    {

      TXBuffer = F("<img src=\"esp.png\" width=48 height=48 align=right>");

    }

  }



  else if (varName == F("css"))

  {

    if (SPIFFS.exists(F("esp.css")))



    {

      TXBuffer = F("<link rel=\"stylesheet\" type=\"text/css\" href=\"esp.css\">");

    }

   else

    {

      TXBuffer += F("<style>");



      TXBuffer += pgDefaultCSS;

      TXBuffer += F("</style>");

    }

  }





  else if (varName == F("js"))

  {

    TXBuffer += F(

                  "<script><!--\n"

                  "function dept_onchange(frmselect) {frmselect.submit();}"

                  "\n//--></script>");

  }



  else if (varName == F("error"))

  {



  }



  else if (varName == F("debug"))

  {



  }



  else

  {

    String log = F("Templ: Unknown Var : ");

    log += varName;

    addLog(LOG_LEVEL_ERROR, log);



  }



 }





void writeDefaultCSS(void)

{

  return;



  if (!SPIFFS.exists(F("esp.css")))

  {

    String defaultCSS;



    fs::File f = SPIFFS.open(F("esp.css"), "w");

    if (f)

    {

      String log = F("CSS  : Writing default CSS file to SPIFFS (");

      log += defaultCSS.length();

      log += F(" bytes)");

      addLog(LOG_LEVEL_INFO, log);

      defaultCSS= PGMT(pgDefaultCSS);

      f.write((const unsigned char*)defaultCSS.c_str(), defaultCSS.length());

      f.close();

    }



  }

}
# 1449 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addHeader(boolean showMenu, String& str)

{



}
# 1467 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFooter(String& str)

{



}
# 1485 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_root() {

  checkRAM(F("handle_root"));



  if (wifiSetup)

  {

    WebServer.send(200, "text/html", F("<meta HTTP-EQUIV='REFRESH' content='0; url=/setup'>"));

    return;

  }

   if (!isLoggedIn()) return;

   navMenuIndex = 0;

   TXBuffer.startStream();

   sendHeadandTail(F("TmplStd"),_HEAD);



  int freeMem = ESP.getFreeHeap();

  String sCommand = WebServer.arg(F("cmd"));



  if ((strcasecmp_P(sCommand.c_str(), PSTR("wifidisconnect")) != 0) && (strcasecmp_P(sCommand.c_str(), PSTR("reboot")) != 0)&& (strcasecmp_P(sCommand.c_str(), PSTR("reset")) != 0))

  {

    if (timerAPoff)

      timerAPoff = millis() + 2000L;







    printToWeb = true;

    printWebString = "";

    if (sCommand.length() > 0) {

      ExecuteCommand(VALUE_SOURCE_HTTP, sCommand.c_str());

    }



    IPAddress ip = WiFi.localIP();





    TXBuffer += printWebString;

    TXBuffer += F("<form>");

    TXBuffer += F("<table class='normal'><TH style='width:150px;' align='left'>System Info<TH align='left'>Value");



    TXBuffer += F("<TR><TD>Unit:<TD>");

    TXBuffer += String(Settings.Unit);



    TXBuffer += F("<TR><TD>GIT version:<TD>");

    TXBuffer += BUILD_GIT;



    TXBuffer += F("<TR><TD>Local Time:<TD>");

    if (Settings.UseNTP)

    {

      TXBuffer += getDateTimeString('-', ':', ' ');

    }

    else

      TXBuffer += F("<font color='red'>NTP disabled</font>");



    TXBuffer += F("<TR><TD>Uptime:<TD>");

    char strUpTime[40];

    int minutes = wdcounter / 2;

    int days = minutes / 1440;

    minutes = minutes % 1440;

    int hrs = minutes / 60;

    minutes = minutes % 60;

    sprintf_P(strUpTime, PSTR("%d days %d hours %d minutes"), days, hrs, minutes);

    TXBuffer += strUpTime;



    TXBuffer += F("<TR><TD>Load:<TD>");

    if (wdcounter > 0)

    {

      TXBuffer += String(100 - (100 * loopCounterLast / loopCounterMax));

      TXBuffer += F("% (LC=");

      TXBuffer += String(int(loopCounterLast / 30));

      TXBuffer += F(")");

    }



    TXBuffer += F("<TR><TD>Free Mem:<TD>");

    TXBuffer += String(freeMem);

    TXBuffer += F(" (");

    TXBuffer += String(lowestRAM);

    TXBuffer += F(" - ");

    TXBuffer += String(lowestRAMfunction);

    TXBuffer += F(")");



    TXBuffer += F("<TR><TD>IP:<TD>");

    TXBuffer += formatIP(ip);



    TXBuffer += F("<TR><TD>Wifi RSSI:<TD>");

    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

    {

      TXBuffer += String(WiFi.RSSI());

      TXBuffer += F(" dB");

    }



    #ifdef FEATURE_MDNS

      TXBuffer += F("<TR><TD>mDNS:<TD><a href='http://");

      TXBuffer += WifiGetHostname();

      TXBuffer += F(".local'>");

      TXBuffer += WifiGetHostname();

      TXBuffer += F(".local</a><TD><TD><TD>");

    #endif

    TXBuffer += F("<TR><TD><TD>");

    addButton(F("sysinfo"), F("More info"));



    TXBuffer += F("</table><BR><BR><table class='multirow'><TR><TH>Node List:<TH>Name<TH>Build<TH>Type<TH>IP<TH>Age");

    for (byte x = 0; x < UNIT_MAX; x++)

    {

      if (Nodes[x].ip[0] != 0)

      {

        char url[80];

        sprintf_P(url, PSTR("<a class='button link' href='http://%u.%u.%u.%u'>%u.%u.%u.%u</a>"), Nodes[x].ip[0], Nodes[x].ip[1], Nodes[x].ip[2], Nodes[x].ip[3], Nodes[x].ip[0], Nodes[x].ip[1], Nodes[x].ip[2], Nodes[x].ip[3]);

        TXBuffer += F("<TR><TD>Unit ");

        TXBuffer += String(x);

        TXBuffer += F("<TD>");

        if (x != Settings.Unit)

          TXBuffer += Nodes[x].nodeName;

        else

          TXBuffer += Settings.Name;

        TXBuffer += F("<TD>");

        if (Nodes[x].build)

          TXBuffer += String(Nodes[x].build);

        TXBuffer += F("<TD>");

        if (Nodes[x].nodeType)

          switch (Nodes[x].nodeType)

          {

            case NODE_TYPE_ID_ESP_EASY_STD:

              TXBuffer += F("ESP Easy");

              break;

            case NODE_TYPE_ID_ESP_EASYM_STD:

              TXBuffer += F("ESP Easy Mega");

              break;

            case NODE_TYPE_ID_ESP_EASY32_STD:

              TXBuffer += F("ESP Easy 32");

              break;

            case NODE_TYPE_ID_ARDUINO_EASY_STD:

              TXBuffer += F("Arduino Easy");

              break;

            case NODE_TYPE_ID_NANO_EASY_STD:

              TXBuffer += F("Nano Easy");

              break;

          }

        TXBuffer += F("<TD>");

        TXBuffer += url;

        TXBuffer += F("<TD>");

        TXBuffer += String( Nodes[x].age);

      }

    }



    TXBuffer += F("</table></form>");



    printWebString = "";

    printToWeb = false;

    sendHeadandTail(F("TmplStd"),_TAIL);

    TXBuffer.endStream();



  }

  else

  {
# 1797 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
    if (strcasecmp_P(sCommand.c_str(), PSTR("wifidisconnect")) == 0)

    {

      String log = F("WIFI : Disconnecting...");

      addLog(LOG_LEVEL_INFO, log);

      cmd_within_mainloop = CMD_WIFI_DISCONNECT;

    }



    if (strcasecmp_P(sCommand.c_str(), PSTR("reboot")) == 0)

    {

      String log = F("     : Rebooting...");

      addLog(LOG_LEVEL_INFO, log);

      cmd_within_mainloop = CMD_REBOOT;

    }

   if (strcasecmp_P(sCommand.c_str(), PSTR("reset")) == 0)

    {

      String log = F("     : factory reset...");

      addLog(LOG_LEVEL_INFO, log);

      cmd_within_mainloop = CMD_REBOOT;

      TXBuffer+= F("OK. Please wait > 1 min and connect to Acces point.<BR><BR>PW=configesp<BR>URL=<a href='http://192.168.4.1'>192.168.4.1</a>");

      TXBuffer.endStream();

      ExecuteCommand(VALUE_SOURCE_HTTP, sCommand.c_str());

    }



    TXBuffer+= "OK";

    TXBuffer.endStream();



  }

}
# 1863 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_config() {



   checkRAM(F("handle_config"));

   if (!isLoggedIn()) return;



   navMenuIndex = 1;

   TXBuffer.startStream();

   sendHeadandTail(F("TmplStd"),_HEAD);



  if (timerAPoff)

    timerAPoff = millis() + 2000L;





  String name = WebServer.arg(F("name"));



  String ssid = WebServer.arg(F("ssid"));



  String ssid2 = WebServer.arg(F("ssid2"));



  String iprangelow = WebServer.arg(F("iprangelow"));

  String iprangehigh = WebServer.arg(F("iprangehigh"));



  String sensordelay = WebServer.arg(F("delay"));

  String deepsleep = WebServer.arg(F("deepsleep"));

  String deepsleeponfail = WebServer.arg(F("deepsleeponfail"));

  String espip = WebServer.arg(F("espip"));

  String espgateway = WebServer.arg(F("espgateway"));

  String espsubnet = WebServer.arg(F("espsubnet"));

  String espdns = WebServer.arg(F("espdns"));

  String unit = WebServer.arg(F("unit"));







  if (ssid[0] != 0)

  {

    if (strcmp(Settings.Name, name.c_str()) != 0) {

      addLog(LOG_LEVEL_INFO, F("Unit Name changed."));

      MQTTclient_should_reconnect = true;

    }

    strncpy(Settings.Name, name.c_str(), sizeof(Settings.Name));



    copyFormPassword(F("password"), SecuritySettings.Password, sizeof(SecuritySettings.Password));

    strncpy(SecuritySettings.WifiSSID, ssid.c_str(), sizeof(SecuritySettings.WifiSSID));



    copyFormPassword(F("key"), SecuritySettings.WifiKey, sizeof(SecuritySettings.WifiKey));

    strncpy(SecuritySettings.WifiSSID2, ssid2.c_str(), sizeof(SecuritySettings.WifiSSID2));



    copyFormPassword(F("key2"), SecuritySettings.WifiKey2, sizeof(SecuritySettings.WifiKey2));



    copyFormPassword(F("apkey"), SecuritySettings.WifiAPKey, sizeof(SecuritySettings.WifiAPKey));







    SecuritySettings.IPblockLevel = getFormItemInt(F("ipblocklevel"));

    switch (SecuritySettings.IPblockLevel) {

      case LOCAL_SUBNET_ALLOWED:

      {

        IPAddress low, high;

        getSubnetRange(low, high);

        for (byte i=0; i < 4; ++i) {

          SecuritySettings.AllowedIPrangeLow[i] = low[i];

          SecuritySettings.AllowedIPrangeHigh[i] = high[i];

        }

        break;

      }

      case ONLY_IP_RANGE_ALLOWED:

      case ALL_ALLOWED:



        str2ip(iprangelow, SecuritySettings.AllowedIPrangeLow);



        str2ip(iprangehigh, SecuritySettings.AllowedIPrangeHigh);

        break;

    }



    Settings.Delay = sensordelay.toInt();

    Settings.deepSleep = deepsleep.toInt();

    Settings.deepSleepOnFail = (deepsleeponfail == F("on"));

    str2ip(espip, Settings.IP);

    str2ip(espgateway, Settings.Gateway);

    str2ip(espsubnet, Settings.Subnet);

    str2ip(espdns, Settings.DNS);

    Settings.Unit = unit.toInt();

    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form name='frmselect' method='post'><table class='normal'>");



  addFormHeader(F("Main Settings"));



  Settings.Name[25] = 0;

  SecuritySettings.Password[25] = 0;

  addFormTextBox( F("Unit Name"), F("name"), Settings.Name, 25);

  addFormNumericBox( F("Unit Number"), F("unit"), Settings.Unit, 0, 9999);

  addFormPasswordBox(F("Admin Password"), F("password"), SecuritySettings.Password, 25);



  addFormSubHeader(F("Wifi Settings"));



  addFormTextBox( F("SSID"), F("ssid"), SecuritySettings.WifiSSID, 31);

  addFormPasswordBox(F("WPA Key"), F("key"), SecuritySettings.WifiKey, 63);

  addFormTextBox( F("Fallback SSID"), F("ssid2"), SecuritySettings.WifiSSID2, 31);

  addFormPasswordBox( F("Fallback WPA Key"), F("key2"), SecuritySettings.WifiKey2, 63);

  addFormSeparator(2);

  addFormPasswordBox(F("WPA AP Mode Key"), F("apkey"), SecuritySettings.WifiAPKey, 63);





  addFormSubHeader(F("Client IP filtering"));

  {

    IPAddress low, high;

    getIPallowedRange(low, high);

    byte iplow[4];

    byte iphigh[4];

    for (byte i = 0; i < 4; ++i) {

      iplow[i] = low[i];

      iphigh[i] = high[i];

    }

    addFormIPaccessControlSelect(F("Client IP block level"), F("ipblocklevel"), SecuritySettings.IPblockLevel);

    addFormIPBox(F("Access IP lower range"), F("iprangelow"), iplow);

    addFormIPBox(F("Access IP upper range"), F("iprangehigh"), iphigh);

  }



  addFormSubHeader(F("IP Settings"));



  addFormIPBox(F("ESP IP"), F("espip"), Settings.IP);

  addFormIPBox(F("ESP GW"), F("espgateway"), Settings.Gateway);

  addFormIPBox(F("ESP Subnet"), F("espsubnet"), Settings.Subnet);

  addFormIPBox(F("ESP DNS"), F("espdns"), Settings.DNS);

  addFormNote(F("Leave empty for DHCP"));





  addFormSubHeader(F("Sleep Mode"));



  addFormNumericBox( F("Sleep awake time"), F("deepsleep"), Settings.deepSleep, 0, 255);

  addUnit(F("sec"));

  addHelpButton(F("SleepMode"));

  addFormNote(F("0 = Sleep Disabled, else time awake from sleep"));



  addFormNumericBox( F("Sleep time"), F("delay"), Settings.Delay, 0, 4294);

  addUnit(F("sec"));



  addFormCheckBox(F("Sleep on connection failure"), F("deepsleeponfail"), Settings.deepSleepOnFail);



  addFormSeparator(2);



  TXBuffer += F("<TR><TD style='width:150px;' align='left'><TD>");

  addSubmitButton();

  TXBuffer += F("</table></form>");



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 2173 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_controllers() {

  checkRAM(F("handle_controllers"));

  if (!isLoggedIn()) return;

  navMenuIndex = 2;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  struct EventStruct TempEvent;



  byte controllerindex = WebServer.arg(F("index")).toInt();

  boolean controllerNotSet = controllerindex == 0;

  --controllerindex;



  String usedns = WebServer.arg(F("usedns"));

  String controllerip = WebServer.arg(F("controllerip"));

  String controllerhostname = WebServer.arg(F("controllerhostname"));

  String controllerport = WebServer.arg(F("controllerport"));

  String protocol = WebServer.arg(F("protocol"));

  String controlleruser = WebServer.arg(F("controlleruser"));

  String controllerpassword = WebServer.arg(F("controllerpassword"));

  String controllersubscribe = WebServer.arg(F("controllersubscribe"));

  String controllerpublish = WebServer.arg(F("controllerpublish"));

  String controllerenabled = WebServer.arg(F("controllerenabled"));
# 2227 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  if (protocol.length() != 0 && !controllerNotSet)

  {

    ControllerSettingsStruct ControllerSettings;



    if (Settings.Protocol[controllerindex] != protocol.toInt())

    {



      Settings.Protocol[controllerindex] = protocol.toInt();





      if (Settings.Protocol[controllerindex]!=0)

      {



        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

        ControllerSettings.Port = Protocol[ProtocolIndex].defaultPort;

        if (Protocol[ProtocolIndex].usesTemplate)

          CPlugin_ptr[ProtocolIndex](CPLUGIN_PROTOCOL_TEMPLATE, &TempEvent, dummyString);

        strncpy(ControllerSettings.Subscribe, TempEvent.String1.c_str(), sizeof(ControllerSettings.Subscribe));

        strncpy(ControllerSettings.Publish, TempEvent.String2.c_str(), sizeof(ControllerSettings.Publish));

        TempEvent.String1 = "";

        TempEvent.String2 = "";
# 2281 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
        ClearCustomControllerSettings(controllerindex);

      }



    }





    else

    {



      if (Settings.Protocol != 0)

      {



        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

        TempEvent.ControllerIndex = controllerindex;

        TempEvent.ProtocolIndex = ProtocolIndex;

        CPlugin_ptr[ProtocolIndex](CPLUGIN_WEBFORM_SAVE, &TempEvent, dummyString);

        ControllerSettings.UseDNS = usedns.toInt();

        if (ControllerSettings.UseDNS)

        {

          strncpy(ControllerSettings.HostName, controllerhostname.c_str(), sizeof(ControllerSettings.HostName));

          IPAddress IP;

          WiFi.hostByName(ControllerSettings.HostName, IP);

          for (byte x = 0; x < 4; x++)

            ControllerSettings.IP[x] = IP[x];

        }



        else

        {

          str2ip(controllerip, ControllerSettings.IP);

        }



        Settings.ControllerEnabled[controllerindex] = (controllerenabled == F("on"));

        ControllerSettings.Port = controllerport.toInt();

        strncpy(SecuritySettings.ControllerUser[controllerindex], controlleruser.c_str(), sizeof(SecuritySettings.ControllerUser[0]));



        copyFormPassword(F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0]));

        strncpy(ControllerSettings.Subscribe, controllersubscribe.c_str(), sizeof(ControllerSettings.Subscribe));

        strncpy(ControllerSettings.Publish, controllerpublish.c_str(), sizeof(ControllerSettings.Publish));

        CPlugin_ptr[ProtocolIndex](CPLUGIN_INIT, &TempEvent, dummyString);

      }

    }

    addHtmlError(SaveControllerSettings(controllerindex, (byte*)&ControllerSettings, sizeof(ControllerSettings)));

    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form name='frmselect' method='post'>");



  if (controllerNotSet)

  {

    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");

    TXBuffer += F("<TH style='width:50px;'>Nr<TH style='width:100px;'>Enabled<TH>Protocol<TH>Host<TH>Port");



    ControllerSettingsStruct ControllerSettings;

    for (byte x = 0; x < CONTROLLER_MAX; x++)

    {

      LoadControllerSettings(x, (byte*)&ControllerSettings, sizeof(ControllerSettings));

      TXBuffer += F("<TR><TD>");

      TXBuffer += F("<a class='button link' href=\"controllers?index=");

      TXBuffer += x + 1;

      TXBuffer += F("\">Edit</a>");

      TXBuffer += F("<TD>");

      TXBuffer += getControllerSymbol(x);

      TXBuffer += F("<TD>");

      if (Settings.Protocol[x] != 0)

      {

        addEnabled(Settings.ControllerEnabled[x]);



        TXBuffer += F("<TD>");

        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

        String ProtocolName = "";

        CPlugin_ptr[ProtocolIndex](CPLUGIN_GET_DEVICENAME, 0, ProtocolName);

        TXBuffer += ProtocolName;



        TXBuffer += F("<TD>");

        TXBuffer += ControllerSettings.getHost();

        TXBuffer += F("<TD>");

        TXBuffer += ControllerSettings.Port;

      }

      else

        TXBuffer += F("<TD><TD><TD>");

    }

    TXBuffer += F("</table></form>");

  }

  else

  {

    TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>Controller Settings<TH>");

    TXBuffer += F("<TR><TD>Protocol:");

    byte choice = Settings.Protocol[controllerindex];

    TXBuffer += F("<TD>");

    addSelector_Head(F("protocol"), true);

    addSelector_Item(F("- Standalone -"), 0, false, false, F(""));

    for (byte x = 0; x <= protocolCount; x++)

    {

      String ProtocolName = "";

      CPlugin_ptr[x](CPLUGIN_GET_DEVICENAME, 0, ProtocolName);

      boolean disabled = false;

      addSelector_Item(ProtocolName,

                       Protocol[x].Number,

                       choice == Protocol[x].Number,

                       disabled,

                       F(""));

    }

    addSelector_Foot();



    addHelpButton(F("EasyProtocols"));





    if (Settings.Protocol[controllerindex])

    {

      ControllerSettingsStruct ControllerSettings;

      LoadControllerSettings(controllerindex, (byte*)&ControllerSettings, sizeof(ControllerSettings));

      byte choice = ControllerSettings.UseDNS;

      String options[2];

      options[0] = F("Use IP address");

      options[1] = F("Use Hostname");



      byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

      if (!Protocol[ProtocolIndex].Custom){



        addFormSelector(F("Locate Controller"), F("usedns"), 2, options, NULL, NULL, choice, true);



        if (ControllerSettings.UseDNS)

        {

          addFormTextBox( F("Controller Hostname"), F("controllerhostname"), ControllerSettings.HostName, sizeof(ControllerSettings.HostName)-1);

        }

        else

        {

          addFormIPBox(F("Controller IP"), F("controllerip"), ControllerSettings.IP);

        }



        addFormNumericBox( F("Controller Port"), F("controllerport"), ControllerSettings.Port, 1, 65535);



        if (Protocol[ProtocolIndex].usesAccount)

        {

           String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_USER, protoDisplayName)) {

            protoDisplayName = F("Controller User");

          }

          addFormTextBox(protoDisplayName, F("controlleruser"), SecuritySettings.ControllerUser[controllerindex], sizeof(SecuritySettings.ControllerUser[0])-1);

         }

        if (Protocol[ProtocolIndex].usesPassword)

        {

          String protoDisplayName;

          if (getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_PASS, protoDisplayName)) {



            addFormTextBox(protoDisplayName, F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0])-1);

          } else {

            addFormPasswordBox(F("Controller Password"), F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0])-1);

          }

        }



        if (Protocol[ProtocolIndex].usesTemplate || Protocol[ProtocolIndex].usesMQTT)

        {

           String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_SUBSCRIBE, protoDisplayName)) {

            protoDisplayName = F("Controller Subscribe");

          }

          addFormTextBox(protoDisplayName, F("controllersubscribe"), ControllerSettings.Subscribe, sizeof(ControllerSettings.Subscribe)-1);

         }



        if (Protocol[ProtocolIndex].usesTemplate || Protocol[ProtocolIndex].usesMQTT)

        {

           String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_PUBLISH, protoDisplayName)) {

            protoDisplayName = F("Controller Publish");

          }

          addFormTextBox(protoDisplayName, F("controllerpublish"), ControllerSettings.Publish, sizeof(ControllerSettings.Publish)-1);

         }



      }



      addFormCheckBox(F("Enabled"), F("controllerenabled"), Settings.ControllerEnabled[controllerindex]);



      TempEvent.ControllerIndex = controllerindex;

      TempEvent.ProtocolIndex = ProtocolIndex;

      CPlugin_ptr[ProtocolIndex](CPLUGIN_WEBFORM_LOAD, &TempEvent,TXBuffer.buf);



    }



    addFormSeparator(2);



    TXBuffer += F("<TR><TD><TD><a class='button link' href=\"controllers\">Close</a>");

    addSubmitButton();

    TXBuffer += F("</table></form>");

  }



    sendHeadandTail(F("TmplStd"),_TAIL);

    TXBuffer.endStream();

}
# 2669 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_notifications() {

  checkRAM(F("handle_notifications"));

  if (!isLoggedIn()) return;

  navMenuIndex = 6;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  struct EventStruct TempEvent;







  byte notificationindex = WebServer.arg(F("index")).toInt();

  boolean notificationindexNotSet = notificationindex == 0;

  --notificationindex;



  String notification = WebServer.arg(F("notification"));

  String domain = WebServer.arg(F("domain"));

  String server = WebServer.arg(F("server"));

  String port = WebServer.arg(F("port"));

  String sender = WebServer.arg(F("sender"));

  String receiver = WebServer.arg(F("receiver"));

  String subject = WebServer.arg(F("subject"));

  String user = WebServer.arg(F("user"));

  String pass = WebServer.arg(F("pass"));

  String body = WebServer.arg(F("body"));

  String pin1 = WebServer.arg(F("pin1"));

  String pin2 = WebServer.arg(F("pin2"));

  String notificationenabled = WebServer.arg(F("notificationenabled"));
# 2733 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  if (notification.length() != 0 && !notificationindexNotSet)

  {

    NotificationSettingsStruct NotificationSettings;

    if (Settings.Notification[notificationindex] != notification.toInt())

    {

      Settings.Notification[notificationindex] = notification.toInt();

    }

    else

    {

      if (Settings.Notification != 0)

      {

        byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

        if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

          NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_WEBFORM_SAVE, 0, dummyString);

        NotificationSettings.Port = port.toInt();

        NotificationSettings.Pin1 = pin1.toInt();

        NotificationSettings.Pin2 = pin2.toInt();

        Settings.NotificationEnabled[notificationindex] = (notificationenabled == F("on"));

        strncpy(NotificationSettings.Domain, domain.c_str(), sizeof(NotificationSettings.Domain));

        strncpy(NotificationSettings.Server, server.c_str(), sizeof(NotificationSettings.Server));

        strncpy(NotificationSettings.Sender, sender.c_str(), sizeof(NotificationSettings.Sender));

        strncpy(NotificationSettings.Receiver, receiver.c_str(), sizeof(NotificationSettings.Receiver));

        strncpy(NotificationSettings.Subject, subject.c_str(), sizeof(NotificationSettings.Subject));

        strncpy(NotificationSettings.User, user.c_str(), sizeof(NotificationSettings.User));

        strncpy(NotificationSettings.Pass, pass.c_str(), sizeof(NotificationSettings.Pass));

        strncpy(NotificationSettings.Body, body.c_str(), sizeof(NotificationSettings.Body));

      }

    }



    addHtmlError(SaveNotificationSettings(notificationindex, (byte*)&NotificationSettings, sizeof(NotificationSettings)));

    addHtmlError(SaveSettings());

    if (WebServer.hasArg(F("test"))) {



      byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

      if (NotificationProtocolIndex != NPLUGIN_NOT_FOUND)

      {



        TempEvent.NotificationIndex = notificationindex;

        NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_NOTIFY, &TempEvent, dummyString);

      }

    }

  }



  TXBuffer += F("<form name='frmselect' method='post'>");



  if (notificationindexNotSet)

  {

    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");

    TXBuffer += F("<TH style='width:50px;'>Nr<TH style='width:100px;'>Enabled<TH>Service<TH>Server<TH>Port");



    NotificationSettingsStruct NotificationSettings;

    for (byte x = 0; x < NOTIFICATION_MAX; x++)

    {

      LoadNotificationSettings(x, (byte*)&NotificationSettings, sizeof(NotificationSettings));

      TXBuffer += F("<TR><TD>");

      TXBuffer += F("<a class='button link' href=\"notifications?index=");

      TXBuffer += x + 1;

      TXBuffer += F("\">Edit</a>");

      TXBuffer += F("<TD>");

      TXBuffer += x + 1;

      TXBuffer += F("<TD>");

      if (Settings.Notification[x] != 0)

      {

        addEnabled(Settings.NotificationEnabled[x]);



        TXBuffer += F("<TD>");

        byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[x]);

        String NotificationName = F("(plugin not found?)");

        if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

        {

          NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_GET_DEVICENAME, 0, NotificationName);

        }

        TXBuffer += NotificationName;

        TXBuffer += F("<TD>");

        TXBuffer += NotificationSettings.Server;

        TXBuffer += F("<TD>");

        TXBuffer += NotificationSettings.Port;

      }

      else

        TXBuffer += F("<TD><TD><TD>");

    }

    TXBuffer += F("</table></form>");

  }

  else

  {

    TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>Notification Settings<TH>");

    TXBuffer += F("<TR><TD>Notification:");

    byte choice = Settings.Notification[notificationindex];

    TXBuffer += F("<TD>");

    addSelector_Head(F("notification"), true);

    addSelector_Item(F("- None -"), 0, false, false, F(""));

    for (byte x = 0; x <= notificationCount; x++)

    {

      String NotificationName = "";

      NPlugin_ptr[x](NPLUGIN_GET_DEVICENAME, 0, NotificationName);

      addSelector_Item(NotificationName,

                       Notification[x].Number,

                       choice == Notification[x].Number,

                       false,

                       F(""));

    }

    addSelector_Foot();



    addHelpButton(F("EasyNotifications"));
# 2949 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
    if (Settings.Notification[notificationindex])

    {

      NotificationSettingsStruct NotificationSettings;

      LoadNotificationSettings(notificationindex, (byte*)&NotificationSettings, sizeof(NotificationSettings));



      byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

      if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

      {



        if (Notification[NotificationProtocolIndex].usesMessaging)

        {

          TXBuffer += F("<TR><TD>Domain:<TD><input class='wide' type='text' name='domain' size=64 value='");

          TXBuffer += NotificationSettings.Domain;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Server:<TD><input class='wide' type='text' name='server' size=64 value='");

          TXBuffer += NotificationSettings.Server;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Port:<TD><input class='wide' type='text' name='port' value='");

          TXBuffer += NotificationSettings.Port;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Sender:<TD><input class='wide' type='text' name='sender' size=64 value='");

          TXBuffer += NotificationSettings.Sender;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Receiver:<TD><input class='wide' type='text' name='receiver' size=64 value='");

          TXBuffer += NotificationSettings.Receiver;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Subject:<TD><input class='wide' type='text' name='subject' size=64 value='");

          TXBuffer += NotificationSettings.Subject;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>User:<TD><input class='wide' type='text' name='user' size=48 value='");

          TXBuffer += NotificationSettings.User;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Pass:<TD><input class='wide' type='text' name='pass' size=32 value='");

          TXBuffer += NotificationSettings.Pass;

          TXBuffer += F("'>");



          TXBuffer += F("<TR><TD>Body:<TD><textarea name='body' rows='20' size=512 wrap='off'>");

          TXBuffer += NotificationSettings.Body;

          TXBuffer += F("</textarea>");

        }



        if (Notification[NotificationProtocolIndex].usesGPIO > 0)

        {

          TXBuffer += F("<TR><TD>1st GPIO:<TD>");

          addPinSelect(false, "pin1", NotificationSettings.Pin1);

        }



        TXBuffer += F("<TR><TD>Enabled:<TD>");

        addCheckBox(F("notificationenabled"), Settings.NotificationEnabled[notificationindex]);



        TempEvent.NotificationIndex = notificationindex;

        NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_WEBFORM_LOAD, &TempEvent,TXBuffer.buf);

      }

    }



    addFormSeparator(2);



    TXBuffer += F("<TR><TD><TD><a class='button link' href=\"notifications\">Close</a>");

    addSubmitButton();

    addSubmitButton(F("Test"), F("test"));

    TXBuffer += F("</table></form>");

  }

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 3103 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_hardware() {

  checkRAM(F("handle_hardware"));

  if (!isLoggedIn()) return;

  navMenuIndex = 3;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);

  if (isFormItem(F("psda")))

  {

    Settings.Pin_status_led = getFormItemInt(F("pled"));

    Settings.Pin_status_led_Inversed = isFormItemChecked(F("pledi"));

    Settings.Pin_Reset = getFormItemInt(F("pres"));

    Settings.Pin_i2c_sda = getFormItemInt(F("psda"));

    Settings.Pin_i2c_scl = getFormItemInt(F("pscl"));

    Settings.InitSPI = isFormItemChecked(F("initspi"));

    Settings.Pin_sd_cs = getFormItemInt(F("sd"));

    Settings.PinBootStates[0] = getFormItemInt(F("p0"));

    Settings.PinBootStates[2] = getFormItemInt(F("p2"));

    Settings.PinBootStates[4] = getFormItemInt(F("p4"));

    Settings.PinBootStates[5] = getFormItemInt(F("p5"));

    Settings.PinBootStates[9] = getFormItemInt(F("p9"));

    Settings.PinBootStates[10] = getFormItemInt(F("p10"));

    Settings.PinBootStates[12] = getFormItemInt(F("p12"));

    Settings.PinBootStates[13] = getFormItemInt(F("p13"));

    Settings.PinBootStates[14] = getFormItemInt(F("p14"));

    Settings.PinBootStates[15] = getFormItemInt(F("p15"));

    Settings.PinBootStates[16] = getFormItemInt(F("p16"));



    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form  method='post'><table class='normal'><TR><TH style='width:150px;' align='left'>Hardware Settings<TH align='left'>");

  addHelpButton(F("ESPEasy#Hardware_page"));



  addFormSubHeader(F("Wifi Status LED"));

  addFormPinSelect(F("GPIO &rarr; LED"), "pled", Settings.Pin_status_led);

  addFormCheckBox(F("Inversed LED"), F("pledi"), Settings.Pin_status_led_Inversed);

  addFormNote(F("Use &rsquo;GPIO-2 (D4)&rsquo; with &rsquo;Inversed&rsquo; checked for onboard LED"));



  addFormSubHeader(F("Reset Pin"));

  addFormPinSelect(F("GPIO &larr; Switch"), "pres", Settings.Pin_Reset);

  addFormNote(F("Press about 10s for factory reset"));



  addFormSubHeader(F("I2C Interface"));

  addFormPinSelectI2C(F("GPIO &#8703; SDA"), F("psda"), Settings.Pin_i2c_sda);

  addFormPinSelectI2C(F("GPIO &#8702; SCL"), F("pscl"), Settings.Pin_i2c_scl);





  addFormSubHeader(F("SPI Interface"));

  addFormCheckBox(F("Init SPI"), F("initspi"), Settings.InitSPI);

  addFormNote(F("CLK=GPIO-14 (D5), MISO=GPIO-12 (D6), MOSI=GPIO-13 (D7)"));

  addFormNote(F("Chip Select (CS) config must be done in the plugin"));

#ifdef FEATURE_SD

  addFormPinSelect(F("GPIO &rarr; SD Card CS"), "sd", Settings.Pin_sd_cs);

#endif



  addFormSubHeader(F("GPIO boot states"));

  addFormPinStateSelect(F("Pin mode 0 (D3)"), F("p0"), Settings.PinBootStates[0]);

  addFormPinStateSelect(F("Pin mode 2 (D4)"), F("p2"), Settings.PinBootStates[2]);

  addFormPinStateSelect(F("Pin mode 4 (D2)"), F("p4"), Settings.PinBootStates[4]);

  addFormPinStateSelect(F("Pin mode 5 (D1)"), F("p5"), Settings.PinBootStates[5]);

  addFormPinStateSelect(F("Pin mode 9 (D11)"), F("p9"), Settings.PinBootStates[9]);

  addFormPinStateSelect(F("Pin mode 10 (D12)"), F("p10"), Settings.PinBootStates[10]);

  addFormPinStateSelect(F("Pin mode 12 (D6)"), F("p12"), Settings.PinBootStates[12]);

  addFormPinStateSelect(F("Pin mode 13 (D7)"), F("p13"), Settings.PinBootStates[13]);

  addFormPinStateSelect(F("Pin mode 14 (D5)"), F("p14"), Settings.PinBootStates[14]);

  addFormPinStateSelect(F("Pin mode 15 (D8)"), F("p15"), Settings.PinBootStates[15]);

  addFormPinStateSelect(F("Pin mode 16 (D0)"), F("p16"), Settings.PinBootStates[16]);

  addFormSeparator(2);



  TXBuffer += F("<TR><TD><TD>");

  addSubmitButton();

  TXBuffer += F("<TR><TD></table></form>");



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();



}
# 3265 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormPinStateSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinStateSelect(id, choice);

}



void addPinStateSelect(String name, int choice)

{

  String options[4] = { F("Default"), F("Output Low"), F("Output High"), F("Input") };

  addSelector(name, 4, options, NULL, NULL, choice, false);

}
# 3295 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormIPaccessControlSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addIPaccessControlSelect(id, choice);

}



void addIPaccessControlSelect(String name, int choice)

{

  String options[3] = { F("Allow All"), F("Allow Local Subnet"), F("Allow IP range") };

  addSelector(name, 3, options, NULL, NULL, choice, false);

}
# 3333 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_devices() {

  checkRAM(F("handle_devices"));

  if (!isLoggedIn()) return;

  navMenuIndex = 4;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);







  struct EventStruct TempEvent;







  byte taskdevicenumber;

  if (WebServer.hasArg(F("del")))

    taskdevicenumber=0;

  else

    taskdevicenumber = WebServer.arg(F("TDNUM")).toInt();





  unsigned long taskdevicetimer = WebServer.arg(F("TDT")).toInt();
# 3471 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  String edit = WebServer.arg(F("edit"));







  byte page = WebServer.arg(F("page")).toInt();

  if (page == 0)

    page = 1;

  byte setpage = WebServer.arg(F("setpage")).toInt();

  if (setpage > 0)

  {

    if (setpage <= (TASKS_MAX / TASKS_PER_PAGE))

      page = setpage;

    else

      page = TASKS_MAX / TASKS_PER_PAGE;

  }
# 3509 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  byte taskIndex = WebServer.arg(F("index")).toInt();

  boolean taskIndexNotSet = taskIndex == 0;

  --taskIndex;



  byte DeviceIndex = 0;



  if (edit.toInt() != 0 && !taskIndexNotSet)

  {

    if (Settings.TaskDeviceNumber[taskIndex] != taskdevicenumber)

    {



      TempEvent.TaskIndex = taskIndex;

      PluginCall(PLUGIN_EXIT, &TempEvent, dummyString);



      taskClear(taskIndex, false);



      Settings.TaskDeviceNumber[taskIndex] = taskdevicenumber;

      if (taskdevicenumber != 0)

      {



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummyString);



          ClearCustomTaskSettings(taskIndex);

      }

    }

    else if (taskdevicenumber != 0)

    {

      Settings.TaskDeviceNumber[taskIndex] = taskdevicenumber;

      DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[taskIndex]);



      if (taskdevicetimer > 0)

        Settings.TaskDeviceTimer[taskIndex] = taskdevicetimer;

      else

      {

        if (!Device[DeviceIndex].TimerOptional)

          Settings.TaskDeviceTimer[taskIndex] = Settings.Delay;

        else

          Settings.TaskDeviceTimer[taskIndex] = 0;

      }



      Settings.TaskDeviceEnabled[taskIndex] = (WebServer.arg(F("TDE")) == F("on"));

      strcpy(ExtraTaskSettings.TaskDeviceName, WebServer.arg(F("TDN")).c_str());

      Settings.TaskDevicePort[taskIndex] = WebServer.arg(F("TDP")).toInt();



      for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

      {



        Settings.TaskDeviceID[controllerNr][taskIndex] = WebServer.arg(String(F("TDID")) + (controllerNr + 1)).toInt();

        Settings.TaskDeviceSendData[controllerNr][taskIndex] = (WebServer.arg(String(F("TDSD")) + (controllerNr + 1)) == F("on"));

      }



      if (WebServer.arg(F("taskdevicepin1")).length() != 0)

        Settings.TaskDevicePin1[taskIndex] = WebServer.arg(F("taskdevicepin1")).toInt();



      if (WebServer.arg(F("taskdevicepin2")).length() != 0)

        Settings.TaskDevicePin2[taskIndex] = WebServer.arg(F("taskdevicepin2")).toInt();



      if (WebServer.arg(F("taskdevicepin3")).length() != 0)

        Settings.TaskDevicePin3[taskIndex] = WebServer.arg(F("taskdevicepin3")).toInt();



      if (Device[DeviceIndex].PullUpOption)

        Settings.TaskDevicePin1PullUp[taskIndex] = (WebServer.arg(F("TDPPU")) == F("on"));



      if (Device[DeviceIndex].InverseLogicOption)

        Settings.TaskDevicePin1Inversed[taskIndex] = (WebServer.arg(F("TDPI")) == F("on"));



      for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

      {



        strcpy(ExtraTaskSettings.TaskDeviceFormula[varNr], WebServer.arg(String(F("TDF")) + (varNr + 1)).c_str());

        ExtraTaskSettings.TaskDeviceValueDecimals[varNr] = WebServer.arg(String(F("TDVD")) + (varNr + 1)).toInt();

        strcpy(ExtraTaskSettings.TaskDeviceValueNames[varNr], WebServer.arg(String(F("TDVN")) + (varNr + 1)).c_str());
# 3667 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
      }
# 3685 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
      TempEvent.TaskIndex = taskIndex;

      if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

        PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummyString);





      PluginCall(PLUGIN_WEBFORM_SAVE, &TempEvent, dummyString);





      for (byte x=0; x < CONTROLLER_MAX; x++)

        {

          TempEvent.ControllerIndex = x;

          if (Settings.TaskDeviceSendData[TempEvent.ControllerIndex][TempEvent.TaskIndex] &&

            Settings.ControllerEnabled[TempEvent.ControllerIndex] && Settings.Protocol[TempEvent.ControllerIndex])

            {

              TempEvent.ProtocolIndex = getProtocolIndex(Settings.Protocol[TempEvent.ControllerIndex]);

              CPlugin_ptr[TempEvent.ProtocolIndex](CPLUGIN_TASK_CHANGE_NOTIFICATION, &TempEvent, dummyString);

            }

        }

    }

    addHtmlError(SaveTaskSettings(taskIndex));



    addHtmlError(SaveSettings());



    if (taskdevicenumber != 0 && Settings.TaskDeviceEnabled[taskIndex])

      PluginCall(PLUGIN_INIT, &TempEvent, dummyString);

  }





  if (taskIndexNotSet)

  {

    TXBuffer += jsUpdateSensorValuesDevicePage;



    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");



    if (TASKS_MAX != TASKS_PER_PAGE)

    {

      TXBuffer += F("<a class='button link' href=\"devices?setpage=");

      if (page > 1)

        TXBuffer += page - 1;

      else

        TXBuffer += page;

      TXBuffer += F("\">&lt;</a>");

      TXBuffer += F("<a class='button link' href=\"devices?setpage=");

      if (page < (TASKS_MAX / TASKS_PER_PAGE))

        TXBuffer += page + 1;

      else

        TXBuffer += page;

      TXBuffer += F("\">&gt;</a>");

    }



    TXBuffer += F("<TH style='width:50px;'>Task<TH style='width:100px;'>Enabled<TH>Device<TH>Name<TH>Port<TH style='width:100px;'>Ctr (IDX)<TH style='width:70px;'>GPIO<TH>Values");



    String deviceName;



    for (byte x = (page - 1) * TASKS_PER_PAGE; x < ((page) * TASKS_PER_PAGE); x++)

    {

      TXBuffer += F("<TR><TD>");

      TXBuffer += F("<a class='button link' href=\"devices?index=");

      TXBuffer += x + 1;

      TXBuffer += F("&page=");

      TXBuffer += page;

      TXBuffer += F("\">Edit</a>");

      TXBuffer += F("<TD>");

      TXBuffer += x + 1;

      TXBuffer += F("<TD>");



      if (Settings.TaskDeviceNumber[x] != 0)

      {

        LoadTaskSettings(x);

        DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);

        TempEvent.TaskIndex = x;

        addEnabled( Settings.TaskDeviceEnabled[x]);



        TXBuffer += F("<TD>");

        TXBuffer += getPluginNameFromDeviceIndex(DeviceIndex);

        TXBuffer += F("<TD>");

        TXBuffer += ExtraTaskSettings.TaskDeviceName;

        TXBuffer += F("<TD>");



        byte customConfig = false;

        customConfig = PluginCall(PLUGIN_WEBFORM_SHOW_CONFIG, &TempEvent,TXBuffer.buf);

        if (!customConfig)

          if (Device[DeviceIndex].Ports != 0)

            TXBuffer += Settings.TaskDevicePort[x];



        TXBuffer += F("<TD>");



        if (Device[DeviceIndex].SendDataOption)

        {

          boolean doBR = false;

          for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

          {

            byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerNr]);

            if (Settings.TaskDeviceSendData[controllerNr][x])

            {

              if (doBR)

                TXBuffer += F("<BR>");

              TXBuffer += getControllerSymbol(controllerNr);

              if (Protocol[ProtocolIndex].usesID && Settings.Protocol[controllerNr] != 0)

              {

                TXBuffer += F(" (");

                TXBuffer += Settings.TaskDeviceID[controllerNr][x];

                TXBuffer += F(")");

                if (Settings.TaskDeviceID[controllerNr][x] == 0)

                  TXBuffer += F(" " HTML_SYMBOL_WARNING);

              }

              doBR = true;

            }

          }

        }



        TXBuffer += F("<TD>");



        if (Settings.TaskDeviceDataFeed[x] == 0)

        {

          if (Device[DeviceIndex].Type == DEVICE_TYPE_I2C)

          {

            TXBuffer += F("GPIO-");

            TXBuffer += Settings.Pin_i2c_sda;

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.Pin_i2c_scl;

          }

          if (Device[DeviceIndex].Type == DEVICE_TYPE_ANALOG)

            TXBuffer += F("ADC (TOUT)");



          if (Settings.TaskDevicePin1[x] != -1)

          {

            TXBuffer += F("GPIO-");

            TXBuffer += Settings.TaskDevicePin1[x];

          }



          if (Settings.TaskDevicePin2[x] != -1)

          {

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.TaskDevicePin2[x];

          }



          if (Settings.TaskDevicePin3[x] != -1)

          {

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.TaskDevicePin3[x];

          }

        }



        TXBuffer += F("<TD>");

        byte customValues = false;

        customValues = PluginCall(PLUGIN_WEBFORM_SHOW_VALUES, &TempEvent,TXBuffer.buf);

        if (!customValues)

        {

          for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

          {

            if (Settings.TaskDeviceNumber[x] != 0)

            {

              if (varNr > 0)

                TXBuffer += F("<div class='div_br'></div>");

              TXBuffer += F("<div class='div_l' id='valuename_");

              TXBuffer += x;

              TXBuffer += '_';

              TXBuffer += varNr;

              TXBuffer += F("'>");

              TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[varNr];

              TXBuffer += F(":</div><div class='div_r' id='value_");

              TXBuffer += x;

              TXBuffer += '_';

              TXBuffer += varNr;

              TXBuffer += F("'>");

              TXBuffer += formatUserVarNoCheck(x, varNr);

              TXBuffer += "</div>";

            }

          }

        }

      }

      else

        TXBuffer += F("<TD><TD><TD><TD><TD><TD>");



    }

    TXBuffer += F("</table></form>");



  }



  else

  {

    LoadTaskSettings(taskIndex);

    DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[taskIndex]);

    TempEvent.TaskIndex = taskIndex;



    TXBuffer += F("<form name='frmselect' method='post'><table class='normal'>");

    addFormHeader(F("Task Settings"));





    TXBuffer += F("<TR><TD style='width:150px;' align='left'>Device:<TD>");





    if (Settings.TaskDeviceNumber[taskIndex] == 0 )

    {



      addDeviceSelect("TDNUM", Settings.TaskDeviceNumber[taskIndex]);



    }



    else

    {



      TXBuffer += F("<input type='hidden' name='TDNUM' value='");

      TXBuffer += Settings.TaskDeviceNumber[taskIndex];

      TXBuffer += F("'>");





      TXBuffer += getPluginNameFromDeviceIndex(DeviceIndex);



      addHelpButton(String(F("Plugin")) + Settings.TaskDeviceNumber[taskIndex]);



      addFormTextBox( F("Name"), F("TDN"), ExtraTaskSettings.TaskDeviceName, 40);



      addFormCheckBox(F("Enabled"), F("TDE"), Settings.TaskDeviceEnabled[taskIndex]);





      if (!Device[DeviceIndex].Custom && Settings.TaskDeviceDataFeed[taskIndex] == 0 &&

          ((Device[DeviceIndex].Ports != 0) || (Device[DeviceIndex].PullUpOption) || (Device[DeviceIndex].InverseLogicOption) || (Device[DeviceIndex].Type >= DEVICE_TYPE_SINGLE && Device[DeviceIndex].Type <= DEVICE_TYPE_TRIPLE)) )

      {

        addFormSubHeader((Device[DeviceIndex].SendDataOption) ? F("Sensor") : F("Actuator"));



        if (Device[DeviceIndex].Ports != 0)

          addFormNumericBox(F("Port"), F("TDP"), Settings.TaskDevicePort[taskIndex]);



        if (Device[DeviceIndex].PullUpOption)

        {

          addFormCheckBox(F("Internal PullUp"), F("TDPPU"), Settings.TaskDevicePin1PullUp[taskIndex]);

          if ((Settings.TaskDevicePin1[taskIndex] == 16) || (Settings.TaskDevicePin2[taskIndex] == 16) || (Settings.TaskDevicePin3[taskIndex] == 16))

            addFormNote(F("GPIO-16 (D0) does not support PullUp"));

        }



        if (Device[DeviceIndex].InverseLogicOption)

        {

          addFormCheckBox(F("Inversed Logic"), F("TDPI"), Settings.TaskDevicePin1Inversed[taskIndex]);

          addFormNote(F("Will go into effect on next input change."));

        }





        TempEvent.String1 = F("1st GPIO");

        TempEvent.String2 = F("2nd GPIO");

        TempEvent.String3 = F("3rd GPIO");

        PluginCall(PLUGIN_GET_DEVICEGPIONAMES, &TempEvent, dummyString);



        if (Device[DeviceIndex].Type >= DEVICE_TYPE_SINGLE && Device[DeviceIndex].Type <= DEVICE_TYPE_TRIPLE)

          addFormPinSelect(TempEvent.String1, F("taskdevicepin1"), Settings.TaskDevicePin1[taskIndex]);

        if (Device[DeviceIndex].Type >= DEVICE_TYPE_DUAL && Device[DeviceIndex].Type <= DEVICE_TYPE_TRIPLE)

          addFormPinSelect( TempEvent.String2, F("taskdevicepin2"), Settings.TaskDevicePin2[taskIndex]);

        if (Device[DeviceIndex].Type == DEVICE_TYPE_TRIPLE)

          addFormPinSelect(TempEvent.String3, F("taskdevicepin3"), Settings.TaskDevicePin3[taskIndex]);

      }





      if (Settings.TaskDeviceDataFeed[taskIndex] == 0) {

        String webformLoadString;

        PluginCall(PLUGIN_WEBFORM_LOAD, &TempEvent,webformLoadString);

        if (webformLoadString.length() > 0) {

          String errorMessage;

          PluginCall(PLUGIN_GET_DEVICENAME, &TempEvent, errorMessage);

          errorMessage += F(": Bug in PLUGIN_WEBFORM_LOAD, should not append to string, use addHtml() instead");

          addHtmlError(errorMessage);

        }

      }





      if (Device[DeviceIndex].SendDataOption)

      {

        addFormSubHeader(F("Data Acquisition"));



        for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

        {

          if (Settings.Protocol[controllerNr] != 0)

          {

            String id = F("TDSD");

            id += controllerNr + 1;



            TXBuffer += F("<TR><TD>Send to Controller ");

            TXBuffer += getControllerSymbol(controllerNr);

            TXBuffer += F("<TD>");

            addCheckBox(id, Settings.TaskDeviceSendData[controllerNr][taskIndex]);



            byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerNr]);

            if (Protocol[ProtocolIndex].usesID && Settings.Protocol[controllerNr] != 0)

            {

              TXBuffer += F("<TR><TD>IDX:<TD>");

              id = F("TDID");

              id += controllerNr + 1;

              addNumericBox(id, Settings.TaskDeviceID[controllerNr][taskIndex], 0, 9999);

            }

          }

        }

      }



      addFormSeparator(2);



      if (Device[DeviceIndex].TimerOption)

      {



        addFormNumericBox( F("Interval"), F("TDT"), Settings.TaskDeviceTimer[taskIndex], 0, 65535);

        addUnit(F("sec"));

        if (Device[DeviceIndex].TimerOptional)

          TXBuffer += F(" (Optional for this Device)");

      }





      if (!Device[DeviceIndex].Custom && Device[DeviceIndex].ValueCount > 0)

      {

        addFormSubHeader(F("Values"));

        TXBuffer += F("</table><table class='normal'>");





        TXBuffer += F("<TR><TH style='width:30px;' align='center'>#");

        TXBuffer += F("<TH align='left'>Name");



        if (Device[DeviceIndex].FormulaOption)

        {

          TXBuffer += F("<TH align='left'>Formula");

          addHelpButton(F("EasyFormula"));

        }



        if (Device[DeviceIndex].FormulaOption || Device[DeviceIndex].DecimalsOnly)

        {

          TXBuffer += F("<TH style='width:30px;' align='left'>Decimals");

        }





        for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

        {

          TXBuffer += F("<TR><TD>");

          TXBuffer += varNr + 1;

          TXBuffer += F("<TD>");

          String id = F("TDVN");

          id += (varNr + 1);

          addTextBox(id, ExtraTaskSettings.TaskDeviceValueNames[varNr], 40);



          if (Device[DeviceIndex].FormulaOption)

          {

            TXBuffer += F("<TD>");

            String id = F("TDF");

            id += (varNr + 1);

            addTextBox(id, ExtraTaskSettings.TaskDeviceFormula[varNr], 40);

          }



          if (Device[DeviceIndex].FormulaOption || Device[DeviceIndex].DecimalsOnly)

          {

            TXBuffer += F("<TD>");

            String id = F("TDVD");

            id += (varNr + 1);

            addNumericBox(id, ExtraTaskSettings.TaskDeviceValueDecimals[varNr], 0, 6);

          }

        }

      }

    }



    addFormSeparator(4);



    TXBuffer += F("<TR><TD><TD colspan='3'><a class='button link' href=\"devices?setpage=");

    TXBuffer += page;

    TXBuffer += F("\">Close</a>");

    addSubmitButton();

    TXBuffer += F("<input type='hidden' name='edit' value='1'>");

    TXBuffer += F("<input type='hidden' name='page' value='1'>");





    if (Settings.TaskDeviceNumber[taskIndex] != 0 )

      addSubmitButton(F("Delete"), F("del"));







    TXBuffer += F("</table></form>");

  }





  checkRAM(F("handle_devices"));

  String log = F("DEBUG: String size:");

  log += String(TXBuffer.sentBytes);

  addLog(LOG_LEVEL_DEBUG_DEV, log);

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}





byte sortedIndex[DEVICES_MAX + 1];







void addDeviceSelect(String name, int choice)

{



  for (byte x = 0; x <= deviceCount; x++)

    sortedIndex[x] = x;

  sortDeviceArray();



  String deviceName;



  addSelector_Head(name, true);

  addSelector_Item(F("- None -"), 0, false, false, F(""));

  for (byte x = 0; x <= deviceCount; x++)

  {

    byte deviceIndex = sortedIndex[x];

    if (Plugin_id[deviceIndex] != 0)

      deviceName = getPluginNameFromDeviceIndex(deviceIndex);



#ifdef PLUGIN_BUILD_DEV

    int num = Plugin_id[deviceIndex];

    String plugin = F("P");

    if (num < 10) plugin += F("0");

    if (num < 100) plugin += F("0");

    plugin += num;

    plugin += F(" - ");

    deviceName = plugin + deviceName;

#endif



    addSelector_Item(deviceName,

                     Device[deviceIndex].Number,

                     choice == Device[deviceIndex].Number,

                     false,

                     F(""));

  }

  addSelector_Foot();

}
# 4535 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void switchArray(byte value)

{

  byte temp;

  temp = sortedIndex[value - 1];

  sortedIndex[value - 1] = sortedIndex[value];

  sortedIndex[value] = temp;

}
# 4559 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
boolean arrayLessThan(const String& ptr_1, const String& ptr_2)

{

  unsigned int i = 0;

  while (i < ptr_1.length())

  {

    if (ptr_2.length() < i)

    {

      return true;

    }

    else

    {

      const char check1 = (char)ptr_1[i];

      const char check2 = (char)ptr_2[i];

      if (check1 == check2) {



        i++;

      } else {

        return (check2 > check1);

      }

    }

  }

  return false;

}
# 4615 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void sortDeviceArray()

{

  int innerLoop ;

  int mainLoop ;

  for ( mainLoop = 1; mainLoop <= deviceCount; mainLoop++)

  {

    innerLoop = mainLoop;

    while (innerLoop >= 1)

    {

      if (arrayLessThan(

        getPluginNameFromDeviceIndex(sortedIndex[innerLoop]),

        getPluginNameFromDeviceIndex(sortedIndex[innerLoop - 1])))

      {

        switchArray(innerLoop);

      }

      innerLoop--;

    }

  }

}



void addFormPinSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinSelect(false, id, choice);

}





void addFormPinSelectI2C(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinSelect(true, id, choice);

}
# 4689 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
#if defined(ESP8285)
# 4701 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addPinSelect(boolean forI2C, String name, int choice)

{

  String options[18];

  options[0] = F("- None -");

  options[1] = F("GPIO-0 (D3)");

  options[2] = F("GPIO-1 (D10)");

  options[3] = F("GPIO-2 (D4)");

  options[4] = F("GPIO-3 (D9)");

  options[5] = F("GPIO-4 (D2)");

  options[6] = F("GPIO-5 (D1)");

  options[7] = F("GPIO-6");

  options[8] = F("GPIO-7");

  options[9] = F("GPIO-8");

  options[10] = F("GPIO-9 (D11)");

  options[11] = F("GPIO-10 (D12)");

  options[12] = F("GPIO-11");

  options[13] = F("GPIO-12 (D6)");

  options[14] = F("GPIO-13 (D7)");

  options[15] = F("GPIO-14 (D5)");

  options[16] = F("GPIO-15 (D8)");

  options[17] = F("GPIO-16 (D0)");

  int optionValues[18];

  optionValues[0] = -1;

  optionValues[1] = 0;

  optionValues[2] = 1;

  optionValues[3] = 2;

  optionValues[4] = 3;

  optionValues[5] = 4;

  optionValues[6] = 5;

  optionValues[7] = 6;

  optionValues[8] = 7;

  optionValues[9] = 8;

  optionValues[10] = 9;

  optionValues[11] = 10;

  optionValues[12] = 11;

  optionValues[13] = 12;

  optionValues[14] = 13;

  optionValues[15] = 14;

  optionValues[16] = 15;

  optionValues[17] = 16;

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, 18);



}



#else

#if defined(ESP8266)
# 4803 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addPinSelect(boolean forI2C, String name, int choice)

{

  String options[14];

  options[0] = F("- None -");

  options[1] = F("GPIO-0 (D3)");

  options[2] = F("GPIO-1 (D10)");

  options[3] = F("GPIO-2 (D4)");

  options[4] = F("GPIO-3 (D9)");

  options[5] = F("GPIO-4 (D2)");

  options[6] = F("GPIO-5 (D1)");

  options[7] = F("GPIO-9 (D11) " HTML_SYMBOL_WARNING);

  options[8] = F("GPIO-10 (D12)");

  options[9] = F("GPIO-12 (D6)");

  options[10] = F("GPIO-13 (D7)");

  options[11] = F("GPIO-14 (D5)");

  options[12] = F("GPIO-15 (D8)");

  options[13] = F("GPIO-16 (D0)");

  int optionValues[14];

  optionValues[0] = -1;

  optionValues[1] = 0;

  optionValues[2] = 1;

  optionValues[3] = 2;

  optionValues[4] = 3;

  optionValues[5] = 4;

  optionValues[6] = 5;

  optionValues[7] = 9;

  optionValues[8] = 10;

  optionValues[9] = 12;

  optionValues[10] = 13;

  optionValues[11] = 14;

  optionValues[12] = 15;

  optionValues[13] = 16;

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, 14);

}

#endif



#if defined(ESP32)







void addPinSelect(boolean forI2C, String name, int choice)

{

  String options[PIN_D_MAX+1];

  int optionValues[PIN_D_MAX+1];

  options[0] = F("- None -");

  optionValues[0] = -1;

  for(byte x=1; x < PIN_D_MAX+1; x++)

  {

    options[x] = F("GPIO-");

    options[x] += x;

    optionValues[x] = x;

  }

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, PIN_D_MAX+1);

}

#endif





#endif
# 4927 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void renderHTMLForPinSelect(String options[], int optionValues[], boolean forI2C, String name, int choice, int count) {

  addSelector_Head(name, false);

  for (byte x = 0; x < count; x++)

  {

    boolean disabled = false;



    if (optionValues[x] != -1)

    {

      if (!forI2C && ((optionValues[x] == Settings.Pin_i2c_sda) || (optionValues[x] == Settings.Pin_i2c_scl)))

        disabled = true;

      if (Settings.UseSerial && ((optionValues[x] == 1) || (optionValues[x] == 3)))

        disabled = true;

    }

    addSelector_Item(options[x],

                     optionValues[x],

                     choice == optionValues[x],

                     disabled,

                     F(""));

  }

  addSelector_Foot();

}





void addFormSelectorI2C(const String& id, int addressCount, const int addresses[], int selectedIndex)

{

  String options[addressCount];

  for (byte x = 0; x < addressCount; x++)

  {

    options[x] = F("0x");

    options[x] += String(addresses[x], HEX);

    if (x == 0)

      options[x] += F(" - (default)");

  }

  addFormSelector(F("I2C Address"), id, addressCount, options, addresses, NULL, selectedIndex, false);

}



void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], int selectedIndex)

{

  addFormSelector(label, id, optionCount, options, indices, NULL, selectedIndex, false);

}



void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange)

{

  addRowLabel(label);

  addSelector(id, optionCount, options, indices, attr, selectedIndex, reloadonchange);

}



void addSelector(const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange)

{

  int index;



  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (reloadonchange)

    TXBuffer += F(" onchange='return dept_onchange(frmselect)'>");

  TXBuffer += F(">");

  for (byte x = 0; x < optionCount; x++)

  {

    if (indices)

      index = indices[x];

    else

      index = x;

    TXBuffer += F("<option value=");

    TXBuffer += index;

    if (selectedIndex == index)

      TXBuffer += F(" selected");

    if (attr)

    {

      TXBuffer += F(" ");

      TXBuffer += attr[x];

    }

    TXBuffer += ">";

    TXBuffer += options[x];

    TXBuffer += F("</option>");

  }

  TXBuffer += F("</select>");

}





void addSelector_Head(const String& id, boolean reloadonchange)

{

  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (reloadonchange)

    TXBuffer += F(" onchange='return dept_onchange(frmselect)'>");

  TXBuffer += F(">");

}



void addSelector_Item(const String& option, int index, boolean selected, boolean disabled, const String& attr)

{

  TXBuffer += F("<option value=");

  TXBuffer += index;

  if (selected)

    TXBuffer += F(" selected");

  if (disabled)

    TXBuffer += F(" disabled");

  if (attr && attr.length() > 0)

  {

    TXBuffer += F(" ");

    TXBuffer += attr;

  }

  TXBuffer += ">";

  TXBuffer += option;

  TXBuffer += F("</option>");

}





void addSelector_Foot()

{

  TXBuffer += F("</select>");

}





void addUnit(const String& unit)

{

  TXBuffer += F(" [");

  TXBuffer += unit;

  TXBuffer += F("]");

}





void addRowLabel(const String& label)

{

  TXBuffer += F("<TR><TD>");

  TXBuffer += label;

  TXBuffer += F(":<TD>");

}



void addButton(const String &url, const String &label)

{

  TXBuffer += F("<a class='button link' href='");

  TXBuffer += url;

  TXBuffer += F("'>");

  TXBuffer += label;

  TXBuffer += F("</a>");

}



void addSubmitButton()

{

  TXBuffer += F("<input class='button link' type='submit' value='Submit'><div id='toastmessage'></div></div><script type='text/javascript'>toasting();</script>");

}





void addSubmitButton(const String &value, const String &name)

{

  TXBuffer += F("<input class='button link' type='submit' value='");

  TXBuffer += value;

  TXBuffer += F("' name='");

  TXBuffer += name;

  TXBuffer += F("'><div id='toastmessage'></div><script type='text/javascript'>toasting();</script>");

}





void addCopyButton(const String &value, const String &delimiter, const String &name)

{

  TXBuffer += jsClipboardCopyPart1;

  TXBuffer += value;

  TXBuffer += jsClipboardCopyPart2;

  TXBuffer += delimiter;

  TXBuffer += jsClipboardCopyPart3;



  TXBuffer += F("<button class='button link' onclick='setClipboard()'>");

  TXBuffer += name;

  TXBuffer += F("</button>");

}
# 5271 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormHeader(const String& header1, const String& header2)

{

  TXBuffer += F("<TR><TH>");

  TXBuffer += header1;

  TXBuffer += F("<TH>");

  TXBuffer += header2;

  TXBuffer += F("");

}



void addFormHeader(const String& header)

{

  TXBuffer += F("<TR><TD colspan='2'><h2>");

  TXBuffer += header;

  TXBuffer += F("</h2>");

}
# 5311 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormSubHeader(const String& header)

{

  TXBuffer += F("<TR><TD colspan='2'><h3>");

  TXBuffer += header;

  TXBuffer += F("</h3>");

}
# 5333 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormNote(const String& text)

{

  TXBuffer += F("<TR><TD><TD><div class='note'>Note: ");

  TXBuffer += text;

  TXBuffer += F("</div>");

}
# 5355 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addFormSeparator(int clspan)

{

 TXBuffer += F("<TR><TD colspan='");

 TXBuffer += clspan;

 TXBuffer += F("'><hr>");

}
# 5375 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addCheckBox(const String& id, boolean checked)

{

  TXBuffer += F("<label class='container'>&nbsp;");

  TXBuffer += F("<input type='checkbox' id='");

  TXBuffer += id;

  TXBuffer += F("' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (checked)

    TXBuffer += F(" checked");

  TXBuffer += F("><span class='checkmark'></span></label>");

}



void addFormCheckBox(const String& label, const String& id, boolean checked)

{

  addRowLabel(label);

  addCheckBox(id, checked);

}
# 5421 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addNumericBox(const String& id, int value, int min, int max)

{

  TXBuffer += F("<input class='widenumber' type='number' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (min != INT_MIN)

  {

    TXBuffer += F(" min=");

    TXBuffer += min;

  }

  if (max != INT_MAX)

  {

    TXBuffer += F(" max=");

    TXBuffer += max;

  }

  TXBuffer += F(" value=");

  TXBuffer += value;

  TXBuffer += F(">");

}



void addNumericBox(const String& id, int value)

{

  addNumericBox(id, value, INT_MIN, INT_MAX);

}



void addFormNumericBox(const String& label, const String& id, int value, int min, int max)

{

  addRowLabel(label);

  addNumericBox(id, value, min, max);

}



void addFormNumericBox(const String& label, const String& id, int value)

{

  addFormNumericBox(label, id, value, INT_MIN, INT_MAX);

}







void addTextBox(const String& id, const String& value, int maxlength)

{

  TXBuffer += F("<input class='wide' type='text' name='");

  TXBuffer += id;

  TXBuffer += F("' maxlength=");

  TXBuffer += maxlength;

  TXBuffer += F(" value='");

  TXBuffer += value;

  TXBuffer += F("'>");

}



void addFormTextBox(const String& label, const String& id, const String& value, int maxlength)

{

  addRowLabel(label);

  addTextBox(id, value, maxlength);

}





void addFormPasswordBox(const String& label, const String& id, const String& password, int maxlength)

{

  addRowLabel(label);

  TXBuffer += F("<input class='wide' type='password' name='");

  TXBuffer += id;

  TXBuffer += F("' maxlength=");

  TXBuffer += maxlength;

  TXBuffer += F(" value='");

  if (password != F(""))

    TXBuffer += F("*****");



  TXBuffer += F("'>");

}



void copyFormPassword(const String& id, char* pPassword, int maxlength)

{

  String password = WebServer.arg(id);

  if (password == F("*****"))

    return;

  strncpy(pPassword, password.c_str(), maxlength);

}



void addFormIPBox(const String& label, const String& id, const byte ip[4])

{

  char strip[20];

  if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0)

    strip[0] = 0;

  else {

    formatIP(ip, strip);

  }



  addRowLabel(label);

  TXBuffer += F("<input class='wide' type='text' name='");

  TXBuffer += id;

  TXBuffer += F("' value='");

  TXBuffer += strip;

  TXBuffer += F("'>");

}





void addHelpButton(const String& url)

{

  TXBuffer += F(" <a class='button help' href='http://www.letscontrolit.com/wiki/index.php/");

  TXBuffer += url;

  TXBuffer += F("' target='_blank'>&#10068;</a>");

}





void addEnabled(boolean enabled)

{

  if (enabled)

    TXBuffer += F("<span class='enabled on'>&#10004;</span>");

  else

    TXBuffer += F("<span class='enabled off'>&#10060;</span>");

}
# 5653 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addTaskSelect(String name, int choice)

{

  struct EventStruct TempEvent;

  String deviceName;



  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += name;

  TXBuffer += F("' onchange='return dept_onchange(frmselect)'>");



  for (byte x = 0; x < TASKS_MAX; x++)

  {

    deviceName = "";

    if (Settings.TaskDeviceNumber[x] != 0 )

    {

      byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);



      if (Plugin_id[DeviceIndex] != 0)

        deviceName = getPluginNameFromDeviceIndex(DeviceIndex);

    }

    LoadTaskSettings(x);

    TXBuffer += F("<option value='");

    TXBuffer += x;

    TXBuffer += "'";

    if (choice == x)

      TXBuffer += F(" selected");

    if (Settings.TaskDeviceNumber[x] == 0)

      TXBuffer += F(" disabled");

    TXBuffer += ">";

    TXBuffer += x + 1;

    TXBuffer += F(" - ");

    TXBuffer += deviceName;

    TXBuffer += F(" - ");

    TXBuffer += ExtraTaskSettings.TaskDeviceName;

    TXBuffer += F("</option>");

  }

}







bool isFormItemChecked(const String& id)

{

  return WebServer.arg(id) == F("on");

}



int getFormItemInt(const String& id)

{

  String val = WebServer.arg(id);

  return val.toInt();

}



float getFormItemFloat(const String& id)

{

  String val = WebServer.arg(id);

  return val.toFloat();

}



bool isFormItem(const String& id)

{

  return (WebServer.arg(id).length() != 0);

}
# 5783 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void addTaskValueSelect(String name, int choice, byte TaskIndex)

{

  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += name;

  TXBuffer += "'>";



  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);



  for (byte x = 0; x < Device[DeviceIndex].ValueCount; x++)

  {

    TXBuffer += F("<option value='");

    TXBuffer += x;

    TXBuffer += "'";

    if (choice == x)

      TXBuffer += F(" selected");

    TXBuffer += ">";

    TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[x];

    TXBuffer += F("</option>");

  }

}
# 5835 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_log() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  TXBuffer += F("<table class=\"normal\"><TR><TH id=\"headline\" align=\"left\">Log");

  addCopyButton(F("copyText"), F(""), F("Copy log to clipboard"));

  TXBuffer += F("</TR></table><div  id='current_loglevel' style='font-weight: bold;'>Logging: </div><div class='logviewer' id='copyText_1'></div>");

  TXBuffer += F("Autoscroll: ");

  addCheckBox(F("autoscroll"), true);

  TXBuffer += F("<BR></body>");



  TXBuffer += jsFetchAndParseLog;



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  }
# 5879 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_log_JSON() {

  TXBuffer.startJsonStream();

  String webrequest = WebServer.arg(F("view"));

  TXBuffer += F("{\"Log\": {");

  if (webrequest == F("legend")) {

    TXBuffer += F("\"Legend\": [");

    for (byte i = 0; i < LOG_LEVEL_NRELEMENTS; ++i) {

      if (i != 0)

        TXBuffer += ',';

      TXBuffer += '{';

      int loglevel;

      stream_next_json_object_value(F("label"), getLogLevelDisplayString(i, loglevel));

      stream_last_json_object_value(F("loglevel"), String(loglevel));

    }

    TXBuffer += F("],\n");

  }

  TXBuffer += F("\"Entries\": [");

  bool logLinesAvailable = true;

  int nrEntries = 0;

  unsigned long firstTimeStamp = 0;

  unsigned long lastTimeStamp = 0;

  while (logLinesAvailable) {

    String reply = Logging.get_logjson_formatted(logLinesAvailable, lastTimeStamp);

    if (reply.length() > 0) {

      TXBuffer += reply;

      if (nrEntries == 0) {

        firstTimeStamp = lastTimeStamp;

      }

      ++nrEntries;

    }



  }

  TXBuffer += F("],\n");

  long logTimeSpan = timeDiff(firstTimeStamp, lastTimeStamp);

  long refreshSuggestion = 1000;

  long newOptimum = 1000;

  if (nrEntries > 2 && logTimeSpan > 1) {





    newOptimum = logTimeSpan * (LOG_STRUCT_MESSAGE_LINES / 2);

    newOptimum = newOptimum / (nrEntries - 1);

  }

  if (newOptimum < refreshSuggestion) refreshSuggestion = newOptimum;

  if (refreshSuggestion < 100) {



    refreshSuggestion = 100;

  }

  stream_next_json_object_value(F("TTL"), String(refreshSuggestion));

  stream_next_json_object_value(F("timeHalfBuffer"), String(newOptimum));

  stream_next_json_object_value(F("nrEntries"), String(nrEntries));

  stream_next_json_object_value(F("SettingsWebLogLevel"), String(Settings.WebLogLevel));

  stream_last_json_object_value(F("logTimeSpan"), String(logTimeSpan));

  TXBuffer += F("}\n");

  TXBuffer.endStream();

}
# 5997 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_tools() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);





  String webrequest = WebServer.arg(F("cmd"));



  TXBuffer += F("<form>");

  TXBuffer += F("<table class='normal'>");



  addFormHeader(F("Tools"));



  addFormSubHeader(F("Command"));

    TXBuffer += F("<TR><TD style='width: 180px'>");

    TXBuffer += F("<input class='wide' type='text' name='cmd' value='");

    TXBuffer += webrequest;

    TXBuffer += F("'>");

    TXBuffer += F("<TD>");

    addSubmitButton();

    addHelpButton(F("ESPEasy_Command_Reference"));

    TXBuffer += F("<TR><TD>");



    printToWeb = true;

    printWebString = "";



    if (webrequest.length() > 0)

    {

      struct EventStruct TempEvent;

      parseCommandString(&TempEvent, webrequest);

      TempEvent.Source = VALUE_SOURCE_HTTP;

      if (!PluginCall(PLUGIN_WRITE, &TempEvent, webrequest))

        ExecuteCommand(VALUE_SOURCE_HTTP, webrequest.c_str());

    }



    if (printWebString.length() > 0)

    {

      TXBuffer += F("<TR><TD colspan='2'>Command Output<BR><textarea readonly rows='10' wrap='on'>");

      TXBuffer += printWebString;

      TXBuffer += F("</textarea>");

    }



  addFormSubHeader(F("System"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("/?cmd=reboot"), F("Reboot"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Reboots ESP");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("log"), F("Log"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Open log output");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("sysinfo"), F("Info"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Open system info page");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("advanced"), F("Advanced"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Open advanced settings");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("json"), F("Show JSON"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Open JSON output");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("pinstates"), F("Pin state buffer"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Show Pin state buffer");



  addFormSubHeader(F("Wifi"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("/?cmd=wificonnect"), F("Connect"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Connects to known Wifi network");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("/?cmd=wifidisconnect"), F("Disconnect"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Disconnect from wifi network");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("wifiscanner"), F("Scan"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Scan for wifi networks");



  addFormSubHeader(F("Interfaces"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("i2cscanner"), F("I2C Scan"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Scan for I2C devices");



  addFormSubHeader(F("Settings"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("upload"), F("Load"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Loads a settings file");

  addFormNote(F("(File MUST be renamed to \"config.dat\" before upload!)"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("download"), F("Save"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Saves a settings file");



#if defined(ESP8266)

  if (ESP.getFlashChipRealSize() > 524288)

  {

    addFormSubHeader(F("Firmware"));

    TXBuffer += F("<TR><TD HEIGHT=\"30\">");

    addButton(F("update"), F("Load"));

    addHelpButton(F("EasyOTA"));

    TXBuffer += F("<TD>");

    TXBuffer += F("Load a new firmware");

  }

#endif



  addFormSubHeader(F("Filesystem"));



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("filelist"), F("Flash"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Show files on internal flash");



  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("/?cmd=reset"), F("Factory Reset"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Erase all settings files");



#ifdef FEATURE_SD

  TXBuffer += F("<TR><TD HEIGHT=\"30\">");

  addButton(F("SDfilelist"), F("SD Card"));

  TXBuffer += F("<TD>");

  TXBuffer += F("Show files on SD-Card");

#endif



  TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 6305 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_pinstates() {

  checkRAM(F("handle_pinstates"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);
# 6331 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH>Plugin");

  addHelpButton(F("Official_plugin_list"));

  TXBuffer += F("<TH>GPIO<TH>Mode<TH>Value/State");

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if (pinStates[x].plugin != 0)

    {

      TXBuffer += F("<TR><TD>P");

      if (pinStates[x].plugin < 100)

      {

        TXBuffer += F("0");

      }

      if (pinStates[x].plugin < 10)

      {

        TXBuffer += F("0");

      }

      TXBuffer += pinStates[x].plugin;

      TXBuffer += F("<TD>");

      TXBuffer += pinStates[x].index;

      TXBuffer += F("<TD>");

      byte mode = pinStates[x].mode;

      switch (mode)

      {

        case PIN_MODE_UNDEFINED:

          TXBuffer += F("undefined");

          break;

        case PIN_MODE_INPUT:

          TXBuffer += F("input");

          break;

        case PIN_MODE_OUTPUT:

          TXBuffer += F("output");

          break;

        case PIN_MODE_PWM:

          TXBuffer += F("PWM");

          break;

        case PIN_MODE_SERVO:

          TXBuffer += F("servo");

          break;

      }

      TXBuffer += F("<TD>");

      TXBuffer += pinStates[x].value;

    }



  TXBuffer += F("</table>");

    sendHeadandTail(F("TmplStd"),_TAIL);

    TXBuffer.endStream();

}
# 6433 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_i2cscanner() {

  checkRAM(F("handle_i2cscanner"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  char *TempString = (char*)malloc(80);







  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH>I2C Addresses in use<TH>Supported devices");



  byte error, address;

  int nDevices;

  nDevices = 0;

  for (address = 1; address <= 127; address++ )

  {

    Wire.beginTransmission(address);

    error = Wire.endTransmission();

    if (error == 0)

    {

      TXBuffer += "<TR><TD>0x";

      TXBuffer += String(address, HEX);

      TXBuffer += "<TD>";

      switch (address)

      {

        case 0x20:

        case 0x21:

        case 0x22:

        case 0x25:

        case 0x26:

        case 0x27:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD");

          break;

        case 0x23:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD<BR>BH1750");

          break;

        case 0x24:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD<BR>PN532");

          break;

        case 0x29:

          TXBuffer += F("TSL2561");

          break;

        case 0x38:

        case 0x3A:

        case 0x3B:

        case 0x3E:

        case 0x3F:

          TXBuffer += F("PCF8574A");

          break;

        case 0x39:

          TXBuffer += F("PCF8574A<BR>TSL2561<BR>APDS9960");

          break;

        case 0x3C:

        case 0x3D:

          TXBuffer += F("PCF8574A<BR>OLED");

          break;

        case 0x40:

          TXBuffer += F("SI7021<BR>HTU21D<BR>INA219<BR>PCA9685");

          break;

        case 0x41:

        case 0x42:

        case 0x43:

          TXBuffer += F("INA219");

          break;

        case 0x44:

        case 0x45:

          TXBuffer += F("SHT30/31/35");

          break;

        case 0x48:

        case 0x4A:

        case 0x4B:

          TXBuffer += F("PCF8591<BR>ADS1115<BR>LM75A");

          break;

        case 0x49:

          TXBuffer += F("PCF8591<BR>ADS1115<BR>TSL2561<BR>LM75A");

          break;

        case 0x4C:

        case 0x4E:

        case 0x4F:

          TXBuffer += F("PCF8591<BR>LM75A");

          break;

        case 0x4D:

          TXBuffer += F("PCF8591<BR>MCP3221<BR>LM75A");

          break;

        case 0x5A:

          TXBuffer += F("MLX90614<BR>MPR121");

          break;

        case 0x5B:

          TXBuffer += F("MPR121");

          break;

        case 0x5C:

          TXBuffer += F("DHT12<BR>AM2320<BR>BH1750<BR>MPR121");

          break;

        case 0x5D:

          TXBuffer += F("MPR121");

          break;

        case 0x60:

          TXBuffer += F("Adafruit Motorshield v2<BR>SI1145");

          break;

        case 0x70:

          TXBuffer += F("Adafruit Motorshield v2 (Catchall)<BR>HT16K33");

          break;

        case 0x71:

        case 0x72:

        case 0x73:

        case 0x74:

        case 0x75:

          TXBuffer += F("HT16K33");

          break;

        case 0x76:

          TXBuffer += F("BME280<BR>BMP280<BR>MS5607<BR>MS5611<BR>HT16K33");

          break;

        case 0x77:

          TXBuffer += F("BMP085<BR>BMP180<BR>BME280<BR>BMP280<BR>MS5607<BR>MS5611<BR>HT16K33");

          break;

        case 0x7f:

          TXBuffer += F("Arduino PME");

          break;

      }

      nDevices++;

    }

    else if (error == 4)

    {

      TXBuffer += F("<TR><TD>Unknown error at address 0x");

      TXBuffer += String(address, HEX);

    }

  }



  if (nDevices == 0)

    TXBuffer += F("<TR>No I2C devices found");



  TXBuffer += F("</table>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  free(TempString);

}
# 6719 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_wifiscanner() {

  checkRAM(F("handle_wifiscanner"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);

  TXBuffer += F("<table class='multirow'><TR><TH>SSID<TH>BSSID<TH>info");



  int n = WiFi.scanNetworks(false, true);

  if (n == 0)

    TXBuffer += F("No Access Points found");

  else

  {

    for (int i = 0; i < n; ++i)

    {

      TXBuffer += F("<TR><TD>");

      TXBuffer += formatScanResult(i, "<TD>");

    }

  }



  TXBuffer += F("</table>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 6777 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_login() {

  checkRAM(F("handle_login"));

  if (!clientIPallowed()) return;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  String webrequest = WebServer.arg(F("password"));

  char command[80];

  command[0] = 0;

  webrequest.toCharArray(command, 80);





  TXBuffer += F("<form method='post'>");

  TXBuffer += F("<table class='normal'><TR><TD>Password<TD>");

  TXBuffer += F("<input class='wide' type='password' name='password' value='");

  TXBuffer += webrequest;

  TXBuffer += F("'><TR><TD><TD>");

  addSubmitButton();

  TXBuffer += F("<TR><TD>");

  TXBuffer += F("</table></form>");



  if (webrequest.length() != 0)

  {



    if ((strcasecmp(command, SecuritySettings.Password) == 0) || (SecuritySettings.Password[0] == 0))

    {

      WebLoggedIn = true;

      WebLoggedInTimer = 0;

      TXBuffer = F("<script>window.location = '.'</script>");

    }

    else

    {

      TXBuffer += F("Invalid password!");

      if (Settings.UseRules)

      {

        String event = F("Login#Failed");

        rulesProcessing(event);

      }

    }

  }



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 6879 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_control() {

  checkRAM(F("handle_control"));

  if (!clientIPallowed()) return;





  String webrequest = WebServer.arg(F("cmd"));





  String command = parseString(webrequest, 1);

  if (command == F("event"))

  {

    eventBuffer = webrequest.substring(6);

    WebServer.send(200, "text/html", "OK");

    return;

  }

  else if (command.equalsIgnoreCase(F("taskrun")) ||

           command.equalsIgnoreCase(F("taskvalueset")) ||

           command.equalsIgnoreCase(F("rules"))) {

    addLog(LOG_LEVEL_INFO,String(F("HTTP : ")) + webrequest);

    ExecuteCommand(VALUE_SOURCE_HTTP,webrequest.c_str());

    WebServer.send(200, "text/html", "OK");

    return;

  }



  struct EventStruct TempEvent;

  parseCommandString(&TempEvent, webrequest);

  TempEvent.Source = VALUE_SOURCE_HTTP;



  printToWeb = true;

  printWebString = "";



  if (printToWebJSON)

    TXBuffer.startJsonStream();

  else

    TXBuffer.startStream();



  if (PluginCall(PLUGIN_WRITE, &TempEvent, webrequest));

  else if (remoteConfig(&TempEvent, webrequest));

  else

    TXBuffer += F("Unknown or restricted command!");



  TXBuffer += printWebString;

  TXBuffer.endStream();



  printWebString = "";

  printToWeb = false;

  printToWebJSON = false;

}
# 6985 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void stream_to_json_object_value(const String& object, const String& value) {

  TXBuffer += F("\"");

  TXBuffer += object;

  TXBuffer += F("\":");

  if (value.length() == 0 || !isFloat(value)) {

    TXBuffer += F("\"");

    TXBuffer += value;

    TXBuffer += F("\"");

  } else {

    TXBuffer += value;

  }

}



String jsonBool(bool value) {

  return value ? F("true") : F("false");

}





void stream_next_json_object_value(const String& object, const String& value) {

  TXBuffer += to_json_object_value(object, value);

  TXBuffer += ",\n";

}





void stream_last_json_object_value(const String& object, const String& value) {

  TXBuffer += to_json_object_value(object, value);

  TXBuffer += "\n}";

}
# 7051 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_json()

{

  String tasknr = WebServer.arg("tasknr");

  bool showSystem = true;

  bool showWifi = true;

  bool showDataAcquisition = true;

  bool showTaskDetails = true;

  {

    String view = WebServer.arg("view");

    if (view.length() != 0) {

      if (view == F("sensorupdate")) {

        showSystem = false;

        showWifi = false;

        showDataAcquisition = false;

        showTaskDetails = false;

      }

    }

  }

  TXBuffer.startJsonStream();

  if (tasknr.length() == 0)

  {

    TXBuffer += '{';

    if (showSystem) {

      TXBuffer += F("\"System\":{\n");

      stream_next_json_object_value(F("Build"), String(BUILD));

      stream_next_json_object_value(F("Git Build"), String(BUILD_GIT));

      stream_next_json_object_value(F("System libraries"), getSystemLibraryString());

      stream_next_json_object_value(F("Plugins"), String(deviceCount + 1));

      stream_next_json_object_value(F("Plugin description"), getPluginDescriptionString());

      stream_next_json_object_value(F("Local time"), getDateTimeString('-',':',' '));

      stream_next_json_object_value(F("Unit"), String(Settings.Unit));

      stream_next_json_object_value(F("Name"), String(Settings.Name));

      stream_next_json_object_value(F("Uptime"), String(wdcounter / 2));

      stream_next_json_object_value(F("Last boot cause"), getLastBootCauseString());

      #ifndef ESP32

      stream_next_json_object_value(F("Reset Reason"), ESP.getResetReason());

      #endif



      if (wdcounter > 0)

      {

          stream_next_json_object_value(F("Load"), String( 100 - (100 * loopCounterLast / loopCounterMax) ));

          stream_next_json_object_value(F("Load LC"), String( int(loopCounterLast / 30) ));

      }



      stream_last_json_object_value(F("Free RAM"), String(ESP.getFreeHeap()));

      TXBuffer += F(",\n");

    }

    if (showWifi) {

      TXBuffer += F("\"WiFi\":{\n");

      #if defined(ESP8266)

        stream_next_json_object_value(F("Hostname"), WiFi.hostname());

      #endif

      stream_next_json_object_value(F("IP config"), useStaticIP() ? F("Static") : F("DHCP"));

      stream_next_json_object_value(F("IP"), WiFi.localIP().toString());

      stream_next_json_object_value(F("Subnet Mask"), WiFi.subnetMask().toString());

      stream_next_json_object_value(F("Gateway IP"), WiFi.gatewayIP().toString());

      stream_next_json_object_value(F("MAC address"), WiFi.macAddress());

      stream_next_json_object_value(F("DNS 1"), WiFi.dnsIP(0).toString());

      stream_next_json_object_value(F("DNS 2"), WiFi.dnsIP(1).toString());

      stream_next_json_object_value(F("SSID"), WiFi.SSID());

      stream_next_json_object_value(F("BSSID"), WiFi.BSSIDstr());

      stream_next_json_object_value(F("Channel"), String(WiFi.channel()));

      stream_next_json_object_value(F("Connected msec"), String(timeDiff(lastConnectMoment, millis())));

      stream_next_json_object_value(F("Last Disconnect Reason"), String(lastDisconnectReason));

      stream_next_json_object_value(F("Last Disconnect Reason str"), getLastDisconnectReason());

      stream_next_json_object_value(F("Number reconnects"), String(wifi_reconnects));

      stream_last_json_object_value(F("RSSI"), String(WiFi.RSSI()));

      TXBuffer += F(",\n");

    }

  }



  byte taskNr = tasknr.toInt();

  byte firstTaskIndex = 0;

  byte lastTaskIndex = TASKS_MAX - 1;

  if (taskNr != 0 )

  {

    firstTaskIndex = taskNr - 1;

    lastTaskIndex = taskNr - 1;

  }

  byte lastActiveTaskIndex = 0;

  for (byte TaskIndex = firstTaskIndex; TaskIndex <= lastTaskIndex; TaskIndex++) {

    if (Settings.TaskDeviceNumber[TaskIndex])

      lastActiveTaskIndex = TaskIndex;

  }



  if (taskNr == 0 ) TXBuffer += F("\"Sensors\":[\n");

  unsigned long ttl_json = 60;

  for (byte TaskIndex = firstTaskIndex; TaskIndex <= lastActiveTaskIndex; TaskIndex++)

  {

    if (Settings.TaskDeviceNumber[TaskIndex])

    {

      byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

      const unsigned long taskInterval = Settings.TaskDeviceTimer[TaskIndex];

      LoadTaskSettings(TaskIndex);

      TXBuffer += F("{\n");



      if (Device[DeviceIndex].ValueCount != 0) {

        if (ttl_json > taskInterval && taskInterval > 0 && Settings.TaskDeviceEnabled[TaskIndex]) {

          ttl_json = taskInterval;

        }

        TXBuffer += F("\"TaskValues\": [\n");

        for (byte x = 0; x < Device[DeviceIndex].ValueCount; x++)

        {

          TXBuffer += F("{");

          stream_next_json_object_value(F("ValueNumber"), String(x + 1));

          stream_next_json_object_value(F("Name"), String(ExtraTaskSettings.TaskDeviceValueNames[x]));

          stream_next_json_object_value(F("NrDecimals"), String(ExtraTaskSettings.TaskDeviceValueDecimals[x]));

          stream_last_json_object_value(F("Value"), formatUserVarNoCheck(TaskIndex, x));

          if (x < (Device[DeviceIndex].ValueCount - 1))

            TXBuffer += F(",\n");

        }

        TXBuffer += F("],\n");

      }

      if (taskNr != 0) {

        stream_next_json_object_value(F("TTL"), String(ttl_json * 1000));

      }

      if (showDataAcquisition) {

        TXBuffer += F("\"DataAcquisition\": [\n");

        for (byte x = 0; x < CONTROLLER_MAX; x++)

        {

          TXBuffer += F("{");

          stream_next_json_object_value(F("Controller"), String(x + 1));

          stream_next_json_object_value(F("IDX"), String(Settings.TaskDeviceID[x][TaskIndex]));

          stream_last_json_object_value(F("Enabled"), jsonBool(Settings.TaskDeviceSendData[x][TaskIndex]));

          if (x < (CONTROLLER_MAX - 1))

            TXBuffer += F(",\n");

        }

        TXBuffer += F("],\n");

      }

      if (showTaskDetails) {

        stream_next_json_object_value(F("TaskInterval"), String(taskInterval));

        stream_next_json_object_value(F("Type"), getPluginNameFromDeviceIndex(DeviceIndex));

        stream_next_json_object_value(F("TaskName"), String(ExtraTaskSettings.TaskDeviceName));

      }

      stream_next_json_object_value(F("TaskEnabled"), jsonBool(Settings.TaskDeviceEnabled[TaskIndex]));

      stream_last_json_object_value(F("TaskNumber"), String(TaskIndex + 1));

      if (TaskIndex != lastActiveTaskIndex)

        TXBuffer += F(",");

      TXBuffer += F("\n");

    }

  }

  if (taskNr == 0) {

    TXBuffer += F("],\n");

    stream_last_json_object_value(F("TTL"), String(ttl_json * 1000));

  }



  TXBuffer.endStream();

}
# 7355 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_advanced() {

  checkRAM(F("handle_advanced"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  char tmpString[81];



  String messagedelay = WebServer.arg(F("messagedelay"));

  String ip = WebServer.arg(F("ip"));

  String syslogip = WebServer.arg(F("syslogip"));

  String ntphost = WebServer.arg(F("ntphost"));

  int timezone = WebServer.arg(F("timezone")).toInt();

  int dststartweek = WebServer.arg(F("dststartweek")).toInt();

  int dststartdow = WebServer.arg(F("dststartdow")).toInt();

  int dststartmonth = WebServer.arg(F("dststartmonth")).toInt();

  int dststarthour = WebServer.arg(F("dststarthour")).toInt();

  int dstendweek = WebServer.arg(F("dstendweek")).toInt();

  int dstenddow = WebServer.arg(F("dstenddow")).toInt();

  int dstendmonth = WebServer.arg(F("dstendmonth")).toInt();

  int dstendhour = WebServer.arg(F("dstendhour")).toInt();

  String dst = WebServer.arg(F("dst"));

  String sysloglevel = WebServer.arg(F("sysloglevel"));

  String syslogfacility = WebServer.arg(F("syslogfacility"));

  String udpport = WebServer.arg(F("udpport"));

  String useserial = WebServer.arg(F("useserial"));

  String serialloglevel = WebServer.arg(F("serialloglevel"));

  String webloglevel = WebServer.arg(F("webloglevel"));

  String sdloglevel = WebServer.arg(F("sdloglevel"));

  String baudrate = WebServer.arg(F("baudrate"));

  String usentp = WebServer.arg(F("usentp"));

  String wdi2caddress = WebServer.arg(F("wdi2caddress"));

  String usessdp = WebServer.arg(F("usessdp"));

  String edit = WebServer.arg(F("edit"));

  String wireclockstretchlimit = WebServer.arg(F("wireclockstretchlimit"));

  String userules = WebServer.arg(F("userules"));

  String cft = WebServer.arg(F("cft"));

  String MQTTRetainFlag = WebServer.arg(F("mqttretainflag"));

  String ArduinoOTAEnable = WebServer.arg(F("arduinootaenable"));

  String UseRTOSMultitasking = WebServer.arg(F("usertosmultitasking"));





  if (edit.length() != 0)

  {

    Settings.MessageDelay = messagedelay.toInt();

    Settings.IP_Octet = ip.toInt();

    ntphost.toCharArray(tmpString, 64);

    strcpy(Settings.NTPHost, tmpString);

    Settings.TimeZone = timezone;

    TimeChangeRule dst_start(dststartweek, dststartdow, dststartmonth, dststarthour, timezone);

    if (dst_start.isValid()) { Settings.DST_Start = dst_start.toFlashStoredValue(); }

    TimeChangeRule dst_end(dstendweek, dstenddow, dstendmonth, dstendhour, timezone);

    if (dst_end.isValid()) { Settings.DST_End = dst_end.toFlashStoredValue(); }

    str2ip(syslogip.c_str(), Settings.Syslog_IP);

    Settings.UDPPort = udpport.toInt();

    Settings.SyslogLevel = sysloglevel.toInt();

    Settings.SyslogFacility = syslogfacility.toInt();

    Settings.UseSerial = (useserial == F("on"));

    Settings.SerialLogLevel = serialloglevel.toInt();

    Settings.WebLogLevel = webloglevel.toInt();

    Settings.SDLogLevel = sdloglevel.toInt();

    Settings.UseValueLogger = isFormItemChecked(F("valuelogger"));

    Settings.BaudRate = baudrate.toInt();

    Settings.UseNTP = (usentp == F("on"));

    Settings.DST = (dst == F("on"));

    Settings.WDI2CAddress = wdi2caddress.toInt();

    Settings.UseSSDP = (usessdp == F("on"));

    Settings.WireClockStretchLimit = wireclockstretchlimit.toInt();

    Settings.UseRules = (userules == F("on"));

    Settings.ConnectionFailuresThreshold = cft.toInt();

    Settings.MQTTRetainFlag = (MQTTRetainFlag == F("on"));

    Settings.ArduinoOTAEnable = (ArduinoOTAEnable == F("on"));

    Settings.UseRTOSMultitasking = (UseRTOSMultitasking == F("on"));



    addHtmlError(SaveSettings());

    if (Settings.UseNTP)

      initTime();

  }







  TXBuffer += F("<form  method='post'><table class='normal'>");



  addFormHeader(F("Advanced Settings"));



  addFormCheckBox(F("Rules"), F("userules"), Settings.UseRules);



  addFormSubHeader(F("Controller Settings"));



  addFormCheckBox(F("MQTT Retain Msg"), F("mqttretainflag"), Settings.MQTTRetainFlag);

  addFormNumericBox( F("Message Interval"), F("messagedelay"), Settings.MessageDelay, 0, INT_MAX);

  addUnit(F("ms"));



  addFormSubHeader(F("NTP Settings"));



  addFormCheckBox(F("Use NTP"), F("usentp"), Settings.UseNTP);

  addFormTextBox( F("NTP Hostname"), F("ntphost"), Settings.NTPHost, 63);



  addFormSubHeader(F("DST Settings"));

  addFormDstSelect(true, Settings.DST_Start);

  addFormDstSelect(false, Settings.DST_End);

  addFormNumericBox(F("Timezone Offset (UTC +)"), F("timezone"), Settings.TimeZone, -720, 840);

  addUnit(F("minutes"));

  addFormCheckBox(F("DST"), F("dst"), Settings.DST);



  addFormSubHeader(F("Log Settings"));



  addFormIPBox(F("Syslog IP"), F("syslogip"), Settings.Syslog_IP);

  addFormLogLevelSelect(F("Syslog Level"), F("sysloglevel"), Settings.SyslogLevel);

  addFormLogFacilitySelect(F("Syslog Facility"),F("syslogfacility"), Settings.SyslogFacility);

  addFormLogLevelSelect(F("Serial log Level"), F("serialloglevel"), Settings.SerialLogLevel);

  addFormLogLevelSelect(F("Web log Level"), F("webloglevel"), Settings.WebLogLevel);



#ifdef FEATURE_SD

  addFormLogLevelSelect(F("SD Card log Level"), F("sdloglevel"), Settings.SDLogLevel);



  addFormCheckBox(F("SD Card Value Logger"), F("valuelogger"), Settings.UseValueLogger);

#endif





  addFormSubHeader(F("Serial Settings"));



  addFormCheckBox(F("Enable Serial port"), F("useserial"), Settings.UseSerial);

  addFormNumericBox(F("Baud Rate"), F("baudrate"), Settings.BaudRate, 0, 1000000);





  addFormSubHeader(F("Inter-ESPEasy Network"));



  addFormNumericBox(F("UDP port"), F("udpport"), Settings.UDPPort, 0, 65535);







  addFormSubHeader(F("Special and Experimental Settings"));



  addFormNumericBox(F("Fixed IP Octet"), F("ip"), Settings.IP_Octet, 0, 255);



  addFormNumericBox(F("WD I2C Address"), F("wdi2caddress"), Settings.WDI2CAddress, 0, 127);

  TXBuffer += F(" (decimal)");



  addFormCheckBox(F("Use SSDP"), F("usessdp"), Settings.UseSSDP);



  addFormNumericBox(F("Connection Failure Threshold"), F("cft"), Settings.ConnectionFailuresThreshold, 0, 100);



  addFormNumericBox(F("I2C ClockStretchLimit"), F("wireclockstretchlimit"), Settings.WireClockStretchLimit);

  #if defined(FEATURE_ARDUINO_OTA)

  addFormCheckBox(F("Enable Arduino OTA"), F("arduinootaenable"), Settings.ArduinoOTAEnable);

  #endif

  #if defined(ESP32)

    addFormCheckBox(F("Enable RTOS Multitasking"), F("usertosmultitasking"), Settings.UseRTOSMultitasking);

  #endif



  addFormSeparator(2);



  TXBuffer += F("<TR><TD style='width:150px;' align='left'><TD>");

  addSubmitButton();

  TXBuffer += F("<input type='hidden' name='edit' value='1'>");

  TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

}



void addFormDstSelect(bool isStart, uint16_t choice) {

  String weekid = isStart ? F("dststartweek") : F("dstendweek");

  String dowid = isStart ? F("dststartdow") : F("dstenddow");

  String monthid = isStart ? F("dststartmonth") : F("dstendmonth");

  String hourid = isStart ? F("dststarthour") : F("dstendhour");



  String weeklabel = isStart ? F("Start (week, dow, month)") : F("End (week, dow, month)");

  String hourlabel = isStart ? F("Start (localtime, e.g. 2h&rarr;3h)") : F("End (localtime, e.g. 3h&rarr;2h)");



  String week[5] = {F("Last"), F("1st"), F("2nd"), F("3rd"), F("4th")};

  int weekValues[5] = {0, 1, 2, 3, 4};

  String dow[7] = {F("Sun"), F("Mon"), F("Tue"), F("Wed"), F("Thu"), F("Fri"), F("Sat")};

  int dowValues[7] = {1, 2, 3, 4, 5, 6, 7};

  String month[12] = {F("Jan"), F("Feb"), F("Mar"), F("Apr"), F("May"), F("Jun"), F("Jul"), F("Aug"), F("Sep"), F("Oct"), F("Nov"), F("Dec")};

  int monthValues[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};



  uint16_t tmpstart(choice);

  uint16_t tmpend(choice);

  if (!TimeChangeRule(choice, 0).isValid()) {

    getDefaultDst_flash_values(tmpstart, tmpend);

  }

  TimeChangeRule rule(isStart ? tmpstart : tmpend, 0);

  addRowLabel(weeklabel);

  addSelector(weekid, 5, week, weekValues, NULL, rule.week, false);

  TXBuffer += F("<BR>");

  addSelector(dowid, 7, dow, dowValues, NULL, rule.dow, false);

  TXBuffer += F("<BR>");

  addSelector(monthid, 12, month, monthValues, NULL, rule.month, false);



  addFormNumericBox(hourlabel, hourid, rule.hour, 0, 23);

  addUnit(isStart ? F("hour &#x21b7;") : F("hour &#x21b6;"));

}



void addFormLogLevelSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addLogLevelSelect(id, choice);

}



void addLogLevelSelect(String name, int choice)

{

  String options[LOG_LEVEL_NRELEMENTS + 1];

  int optionValues[LOG_LEVEL_NRELEMENTS + 1] = {0};

  options[0] = F("None");

  optionValues[0] = 0;

  for (int i = 0; i < LOG_LEVEL_NRELEMENTS; ++i) {

    options[i + 1] = getLogLevelDisplayString(i, optionValues[i + 1]);

  }

  addSelector(name, LOG_LEVEL_NRELEMENTS + 1, options, optionValues, NULL, choice, false);

}



void addFormLogFacilitySelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addLogFacilitySelect(id, choice);

}



void addLogFacilitySelect(String name, int choice)

{

  String options[12] = { F("Kernel"), F("User"), F("Daemon"), F("Message"), F("Local0"), F("Local1"), F("Local2"), F("Local3"), F("Local4"), F("Local5"), F("Local6"), F("Local7")};

  int optionValues[12] = { 0, 1, 3, 5, 16, 17, 18, 19, 20, 21, 22, 23 };

  addSelector(name, 12, options, optionValues, NULL, choice, false);

}
# 7815 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
boolean isLoggedIn()

{

  if (!clientIPallowed()) return false;

  if (SecuritySettings.Password[0] == 0)

    WebLoggedIn = true;



  if (!WebLoggedIn)

  {

    WebServer.sendContent(F("HTTP/1.1 302 \r\nLocation: /login\r\n"));

  }

  else

  {

    WebLoggedInTimer = 0;

  }



  return WebLoggedIn;

}
# 7859 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_download()

{

  checkRAM(F("handle_download"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;
# 7877 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
  fs::File dataFile = SPIFFS.open(F(FILE_CONFIG), "r");

  if (!dataFile)

    return;



  String str = F("attachment; filename=config_");

  str += Settings.Name;

  str += "_U";

  str += Settings.Unit;

  str += F("_Build");

  str += BUILD;

  str += F("_");

  if (Settings.UseNTP)

  {

    str += getDateTimeString('\0', '\0', '\0');

  }

  str += F(".dat");



  WebServer.sendHeader(F("Content-Disposition"), str);

  WebServer.streamFile(dataFile, F("application/octet-stream"));

}
# 7927 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
byte uploadResult = 0;

void handle_upload() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  TXBuffer += F("<form enctype='multipart/form-data' method='post'><p>Upload settings file:<br><input type='file' name='datafile' size='40'></p><div><input class='button link' type='submit' value='Upload'></div><input type='hidden' name='edit' value='1'></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 7963 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_upload_post() {

  checkRAM(F("handle_upload_post"));

  if (!isLoggedIn()) return;



  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));







  if (uploadResult == 1)

  {

    TXBuffer += F("Upload OK!<BR>You may need to reboot to apply all settings...");

    LoadSettings();

  }



  if (uploadResult == 2)

    TXBuffer += F("<font color=\"red\">Upload file invalid!</font>");



  if (uploadResult == 3)

    TXBuffer += F("<font color=\"red\">No filename!</font>");





  TXBuffer += F("Upload finished");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 8031 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
fs::File uploadFile;

void handleFileUpload() {

  checkRAM(F("handleFileUpload"));

  if (!isLoggedIn()) return;



  static boolean valid = false;

  String log = "";



  HTTPUpload& upload = WebServer.upload();



  if (upload.filename.c_str()[0] == 0)

  {

    uploadResult = 3;

    return;

  }



  if (upload.status == UPLOAD_FILE_START)

  {

    log = F("Upload: START, filename: ");

    log += upload.filename;

    addLog(LOG_LEVEL_INFO, log);

    valid = false;

    uploadResult = 0;

  }

  else if (upload.status == UPLOAD_FILE_WRITE)

  {



    if (upload.totalSize == 0)

    {

      if (strcasecmp(upload.filename.c_str(), FILE_CONFIG) == 0)

      {

        struct TempStruct {

          unsigned long PID;

          int Version;

        } Temp;

        for (unsigned int x = 0; x < sizeof(struct TempStruct); x++)

        {

          byte b = upload.buf[x];

          memcpy((byte*)&Temp + x, &b, 1);

        }

        if (Temp.Version == VERSION && Temp.PID == ESP_PROJECT_PID)

          valid = true;

      }

      else

      {



        valid = true;

      }

      if (valid)

      {



        SPIFFS.remove((char *)upload.filename.c_str());

        uploadFile = SPIFFS.open(upload.filename.c_str(), "w");



      }

    }

    if (uploadFile) uploadFile.write(upload.buf, upload.currentSize);

    log = F("Upload: WRITE, Bytes: ");

    log += upload.currentSize;

    addLog(LOG_LEVEL_INFO, log);

  }

  else if (upload.status == UPLOAD_FILE_END)

  {

    if (uploadFile) uploadFile.close();

    log = F("Upload: END, Size: ");

    log += upload.totalSize;

    addLog(LOG_LEVEL_INFO, log);

  }



  if (valid)

    uploadResult = 1;

  else

    uploadResult = 2;



}
# 8191 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
bool loadFromFS(boolean spiffs, String path) {

  checkRAM(F("loadFromFS"));

  if (!isLoggedIn()) return false;



  statusLED(true);



  String dataType = F("text/plain");

  if (path.endsWith(F("/"))) path += F("index.htm");



  if (path.endsWith(F(".src"))) path = path.substring(0, path.lastIndexOf("."));

  else if (path.endsWith(F(".htm"))) dataType = F("text/html");

  else if (path.endsWith(F(".css"))) dataType = F("text/css");

  else if (path.endsWith(F(".js"))) dataType = F("application/javascript");

  else if (path.endsWith(F(".png"))) dataType = F("image/png");

  else if (path.endsWith(F(".gif"))) dataType = F("image/gif");

  else if (path.endsWith(F(".jpg"))) dataType = F("image/jpeg");

  else if (path.endsWith(F(".ico"))) dataType = F("image/x-icon");

  else if (path.endsWith(F(".txt"))) dataType = F("application/octet-stream");

  else if (path.endsWith(F(".dat"))) dataType = F("application/octet-stream");

  else if (path.endsWith(F(".esp"))) return handle_custom(path);

  String log = F("HTML : Request file ");

  log += path;



  path = path.substring(1);

  if (spiffs)

  {

    fs::File dataFile = SPIFFS.open(path.c_str(), "r");

    if (!dataFile)

      return false;





    WebServer.sendHeader(F("Cache-Control"), F("max-age=3600, public"));

    WebServer.sendHeader(F("Vary"),"*");

    WebServer.sendHeader(F("ETag"), F("\"2.0.0\""));



    if (path.endsWith(F(".dat")))

      WebServer.sendHeader(F("Content-Disposition"), F("attachment;"));

    WebServer.streamFile(dataFile, dataType);

    dataFile.close();

  }

  else

  {

#ifdef FEATURE_SD

    File dataFile = SD.open(path.c_str());

    if (!dataFile)

      return false;

    if (path.endsWith(F(".DAT")))

      WebServer.sendHeader(F("Content-Disposition"), F("attachment;"));

    WebServer.streamFile(dataFile, dataType);

    dataFile.close();

#endif

  }

  statusLED(true);



  addLog(LOG_LEVEL_DEBUG, log);

  return true;

}
# 8313 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
boolean handle_custom(String path) {

  checkRAM(F("handle_custom"));

  if (!clientIPallowed()) return false;

  path = path.substring(1);





  fs::File dataFile = SPIFFS.open(path.c_str(), "r");

  const bool dashboardPage = path.startsWith(F("dashboard"));

  if (!dataFile && !dashboardPage) {

    return false;

  }



  if (dashboardPage)

  {



    byte unit = WebServer.arg(F("unit")).toInt();

    byte btnunit = WebServer.arg(F("btnunit")).toInt();

    if(!unit) unit = btnunit;

    if (unit && unit != Settings.Unit)

    {

      TXBuffer.startStream();

      sendHeadandTail(F("TmplDsh"),_HEAD);

      char url[40];

      sprintf_P(url, PSTR("http://%u.%u.%u.%u/dashboard.esp"), Nodes[unit].ip[0], Nodes[unit].ip[1], Nodes[unit].ip[2], Nodes[unit].ip[3]);

      TXBuffer += F("<meta http-equiv=\"refresh\" content=\"0; URL=");

      TXBuffer += url;

      TXBuffer += F("\">");

      sendHeadandTail(F("TmplDsh"),_TAIL);

      TXBuffer.endStream();

      return true;

    }



    TXBuffer.startStream();

    sendHeadandTail(F("TmplDsh"),_HEAD);

    TXBuffer += F("<script><!--\n"

             "function dept_onchange(frmselect) {frmselect.submit();}"

             "\n//--></script>");



    TXBuffer += F("<form name='frmselect' method='post'>");





    addSelector_Head(F("unit"), true);

    byte choice = Settings.Unit;

    for (byte x = 0; x < UNIT_MAX; x++)

    {

      if (Nodes[x].ip[0] != 0 || x == Settings.Unit)

      {

        String name = String(x) + F(" - ");

        if (x != Settings.Unit)

          name += Nodes[x].nodeName;

        else

          name += Settings.Name;

        addSelector_Item(name, x, choice == x, false, F(""));

      }

    }

    addSelector_Foot();





    byte prev=Settings.Unit;

    byte next=Settings.Unit;

    for (byte x = Settings.Unit-1; x > 0; x--)

      if (Nodes[x].ip[0] != 0) {prev = x; break;}

    for (byte x = Settings.Unit+1; x < UNIT_MAX; x++)

      if (Nodes[x].ip[0] != 0) {next = x; break;}



    TXBuffer += F("<a class='button link' href=");

    TXBuffer += path;

    TXBuffer += F("?btnunit=");

    TXBuffer += prev;

    TXBuffer += F(">&lt;</a>");

    TXBuffer += F("<a class='button link' href=");

    TXBuffer += path;

    TXBuffer += F("?btnunit=");

    TXBuffer += next;

    TXBuffer += F(">&gt;</a>");

  }





  String webrequest = WebServer.arg(F("cmd"));

  if (webrequest.length() > 0 ){

    struct EventStruct TempEvent;

    parseCommandString(&TempEvent, webrequest);

    TempEvent.Source = VALUE_SOURCE_HTTP;



    if (PluginCall(PLUGIN_WRITE, &TempEvent, webrequest));

    else if (remoteConfig(&TempEvent, webrequest));

    else if (webrequest.startsWith(F("event")))

      ExecuteCommand(VALUE_SOURCE_HTTP, webrequest.c_str());





    PluginCall(PLUGIN_TEN_PER_SECOND, 0, dummyString);

  }





  if (dataFile)

  {

    String page = "";

    page.reserve(dataFile.size());

    while (dataFile.available())

      page += ((char)dataFile.read());



    TXBuffer += parseTemplate(page,0);

    dataFile.close();

  }

  else

  {

    if (dashboardPage)

    {



      TXBuffer += F("<meta name='viewport' content='width=width=device-width, initial-scale=1'><STYLE>* {font-family:sans-serif; font-size:16pt;}.button {margin:4px; padding:4px 16px; background-color:#07D; color:#FFF; text-decoration:none; border-radius:4px}</STYLE>");

      TXBuffer += F("<table class='normal'>");

      for (byte x = 0; x < TASKS_MAX; x++)

      {

        if (Settings.TaskDeviceNumber[x] != 0)

          {

            LoadTaskSettings(x);

            byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);

            TXBuffer += F("<TR><TD>");

            TXBuffer += ExtraTaskSettings.TaskDeviceName;

            for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

              {

                if ((Settings.TaskDeviceNumber[x] != 0) && (varNr < Device[DeviceIndex].ValueCount) && ExtraTaskSettings.TaskDeviceValueNames[varNr][0] !=0)

                {

                  if (varNr > 0)

                    TXBuffer += F("<TR><TD>");

                  TXBuffer += F("<TD>");

                  TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[varNr];

                  TXBuffer += F("<TD>");

                  TXBuffer += String(UserVar[x * VARS_PER_TASK + varNr], ExtraTaskSettings.TaskDeviceValueDecimals[varNr]);

                }

              }

          }

      }

    }

  }

  sendHeadandTail(F("TmplDsh"),_TAIL);

  TXBuffer.endStream();

  return true;

}
# 8603 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_filelist() {

  checkRAM(F("handle_filelist"));

  if (!clientIPallowed()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



#if defined(ESP8266)



  String fdelete = WebServer.arg(F("delete"));



  if (fdelete.length() > 0)

  {

    SPIFFS.remove(fdelete);

    checkRuleSets();

  }







  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH style='width:50px;'><TH>Filename<TH style='width:80px;'>Size");



  fs::Dir dir = SPIFFS.openDir("");

  while (dir.next())

  {

    TXBuffer += F("<TR><TD>");

    if (dir.fileName() != F(FILE_CONFIG) && dir.fileName() != F(FILE_SECURITY) && dir.fileName() != F(FILE_NOTIFICATION))

    {

      TXBuffer += F("<a class='button link' href=\"filelist?delete=");

      TXBuffer += dir.fileName();

      TXBuffer += F("\">Del</a>");

    }



    TXBuffer += F("<TD><a href=\"");

    TXBuffer += dir.fileName();

    TXBuffer += F("\">");

    TXBuffer += dir.fileName();

    TXBuffer += F("</a>");

    fs::File f = dir.openFile("r");

    TXBuffer += F("<TD>");

    TXBuffer += f.size();

  }

  TXBuffer += F("</table></form>");

  TXBuffer += F("<BR><a class='button link' href=\"/upload\">Upload</a><BR><BR>");

    sendHeadandTail(F("TmplStd"),true);

    TXBuffer.endStream();

#endif

#if defined(ESP32)

  String fdelete = WebServer.arg(F("delete"));



  if (fdelete.length() > 0)

  {

    SPIFFS.remove(fdelete);



  }







  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH><TH>Filename<TH>Size");



  File root = SPIFFS.open("/");

  File file = root.openNextFile();

  while (file)

  {

    if(!file.isDirectory()){

      TXBuffer += F("<TR><TD>");

      if (strcmp(file.name(), FILE_CONFIG) != 0 && strcmp(file.name(), FILE_SECURITY) != 0 && strcmp(file.name(), FILE_NOTIFICATION) != 0)

      {

        TXBuffer += F("<a class='button link' href=\"filelist?delete=");

        TXBuffer += file.name();

        TXBuffer += F("\">Del</a>");

      }



      TXBuffer += F("<TD><a href=\"");

      TXBuffer += file.name();

      TXBuffer += F("\">");

      TXBuffer += file.name();

      TXBuffer += F("</a>");

      TXBuffer += F("<TD>");

      TXBuffer += file.size();

      file = root.openNextFile();

    }

  }

  TXBuffer += F("</table></form>");

  TXBuffer += F("<BR><a class='button link' href=\"/upload\">Upload</a><BR><BR>");

    sendHeadandTail(F("TmplStd"),true);

    TXBuffer.endStream();

#endif

}
# 8789 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
#ifdef FEATURE_SD

void handle_SDfilelist() {

  checkRAM(F("handle_SDfilelist"));

  if (!clientIPallowed()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));





  String fdelete = "";

  String ddelete = "";

  String change_to_dir = "";

  String current_dir = "";

  String parent_dir = "";

  char SDcardDir[80];



  for (uint8_t i = 0; i < WebServer.args(); i++) {

    if (WebServer.argName(i) == F("delete"))

    {

      fdelete = WebServer.arg(i);

    }

    if (WebServer.argName(i) == F("deletedir"))

    {

      ddelete = WebServer.arg(i);

    }

    if (WebServer.argName(i) == F("chgto"))

    {

      change_to_dir = WebServer.arg(i);

    }

  }



  if (fdelete.length() > 0)

  {

    SD.remove((char*)fdelete.c_str());

  }

  if (ddelete.length() > 0)

  {

    SD.rmdir((char*)ddelete.c_str());

  }

  if (change_to_dir.length() > 0)

  {

    current_dir = change_to_dir;

  }

  else

  {

    current_dir = "/";

  }



  current_dir.toCharArray(SDcardDir, current_dir.length()+1);

  File root = SD.open(SDcardDir);

  root.rewindDirectory();

  File entry = root.openNextFile();

  parent_dir = current_dir;

  if (!current_dir.equals("/"))

  {
# 8915 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
    parent_dir.remove(parent_dir.lastIndexOf("/", parent_dir.lastIndexOf("/") - 1) + 1);

  }







  String subheader = "SD Card: " + current_dir;

  addFormSubHeader(subheader);

  TXBuffer += F("<BR>");

  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH style='width:50px;'><TH>Name<TH>Size");

  TXBuffer += F("<TR><TD>");

  TXBuffer += F("<TD><a href=\"SDfilelist?chgto=");

  TXBuffer += parent_dir;

  TXBuffer += F("\">..");

  TXBuffer += F("</a>");

  TXBuffer += F("<TD>");

  while (entry)

  {

    if (entry.isDirectory())

    {

      char SDcardChildDir[80];

      TXBuffer += F("<TR><TD>");



      String child_dir = current_dir + entry.name();

      child_dir.toCharArray(SDcardChildDir, child_dir.length()+1);

      File child = SD.open(SDcardChildDir);

      File dir_has_entry = child.openNextFile();



      if (!dir_has_entry)

      {

        TXBuffer += F("<a class='button link' onclick=\"return confirm('Delete this directory?')\" href=\"SDfilelist?deletedir=");

        TXBuffer += current_dir;

        TXBuffer += entry.name();

        TXBuffer += F("/");

        TXBuffer += F("&chgto=");

        TXBuffer += current_dir;

        TXBuffer += F("\">Del</a>");

      }

      TXBuffer += F("<TD><a href=\"SDfilelist?chgto=");

      TXBuffer += current_dir;

      TXBuffer += entry.name();

      TXBuffer += F("/");

      TXBuffer += F("\">");

      TXBuffer += entry.name();

      TXBuffer += F("</a>");

      TXBuffer += F("<TD>");

      TXBuffer += F("dir");

      dir_has_entry.close();

    }

    else

    {

      TXBuffer += F("<TR><TD>");

      if (entry.name() != String(F(FILE_CONFIG)).c_str() && entry.name() != String(F(FILE_SECURITY)).c_str())

      {

        TXBuffer += F("<a class='button link' onclick=\"return confirm('Delete this file?')\" href=\"SDfilelist?delete=");

        TXBuffer += current_dir;

        TXBuffer += entry.name();

        TXBuffer += F("&chgto=");

        TXBuffer += current_dir;

        TXBuffer += F("\">Del</a>");

      }

      TXBuffer += F("<TD><a href=\"");

      TXBuffer += current_dir;

      TXBuffer += entry.name();

      TXBuffer += F("\">");

      TXBuffer += entry.name();

      TXBuffer += F("</a>");

      TXBuffer += F("<TD>");

      TXBuffer += entry.size();

    }

    entry.close();

    entry = root.openNextFile();

  }

  root.close();

  TXBuffer += F("</table></form>");



     sendHeadandTail(F("TmplStd"),true);

    TXBuffer.endStream();

}

#endif
# 9083 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handleNotFound() {

  checkRAM(F("handleNotFound"));



  if (wifiSetup)

  {

    WebServer.send(200, F("text/html"), F("<meta HTTP-EQUIV='REFRESH' content='0; url=/setup'>"));

    return;

  }



  if (!isLoggedIn()) return;

  if (loadFromFS(true, WebServer.uri())) return;

  if (loadFromFS(false, WebServer.uri())) return;

  String message = F("URI: ");

  message += WebServer.uri();

  message += F("\nMethod: ");

  message += (WebServer.method() == HTTP_GET) ? F("GET") : F("POST");

  message += F("\nArguments: ");

  message += WebServer.args();

  message += "\n";

  for (uint8_t i = 0; i < WebServer.args(); i++) {

    message += F(" NAME:");

    message += WebServer.argName(i);

    message += F("\n VALUE:");

    message += WebServer.arg(i);

    message += F("\n");

  }

  WebServer.send(404, F("text/plain"), message);

}
# 9149 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_setup() {

  checkRAM(F("handle_setup"));



  TXBuffer.startStream();

  sendHeadandTail(F("TmplAP"));



  addHeader(false,TXBuffer.buf);



  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

    addHtmlError(SaveSettings());

    const IPAddress ip = WiFi.localIP();

    char host[20];

    formatIP(ip, host);

    TXBuffer += F("<BR>ESP is connected and using IP Address: <BR><h1>");

    TXBuffer += host;

    TXBuffer += F("</h1><BR><BR>Connect your laptop / tablet / phone<BR>back to your main Wifi network and<BR><BR>");

    TXBuffer += F("<a class='button' href='http://");

    TXBuffer += host;

    TXBuffer += F("/config'>Proceed to main config</a><BR><BR>");



    sendHeadandTail(F("TmplAP"),true);

    TXBuffer.endStream();



    wifiSetup = false;



    timerAPoff = millis() + 60000L;

    return;

  }



  static byte status = 0;

  static int n = 0;

  static byte refreshCount = 0;

  String ssid = WebServer.arg(F("ssid"));

  String other = WebServer.arg(F("other"));

  String password = WebServer.arg(F("pass"));



  if (other.length() != 0)

  {

    ssid = other;

  }





  if (status == 0 && ssid.length() != 0 )

  {

    strncpy(SecuritySettings.WifiKey, password.c_str(), sizeof(SecuritySettings.WifiKey));

    strncpy(SecuritySettings.WifiSSID, ssid.c_str(), sizeof(SecuritySettings.WifiSSID));

    wifiSetupConnect = true;

    String reconnectlog = F("WIFI : Credentials Changed, retry connection. SSID: ");

    reconnectlog += ssid;

    addLog(LOG_LEVEL_INFO, reconnectlog);

    status = 1;

    refreshCount = 0;

  }



  TXBuffer += F("<BR><h1>Wifi Setup wizard</h1>");

  TXBuffer += F("<form name='frmselect' method='post'>");



  if (status == 0)

  {

    WiFiMode_t cur_wifimode = WiFi.getMode();

    if (n == 0)

      n = WiFi.scanNetworks(false, true);

    setWifiMode(cur_wifimode);

    if (n == 0)

      TXBuffer += F("No Access Points found");

    else

    {

      TXBuffer += F("<table class='multirow' border=1px frame='box'><TR><TH style='width:50px;'>Pick<TH>Network info");

      for (int i = 0; i < n; ++i)

      {

        TXBuffer += F("<TR><TD><label class='container2'>");

        TXBuffer += F("<input type='radio' name='ssid' value='");

        TXBuffer += WiFi.SSID(i);

        TXBuffer += F("'");

        if (WiFi.SSID(i) == ssid)

          TXBuffer += F(" checked ");

        TXBuffer += F("><span class='dotmark'></span></label><TD>");

        TXBuffer += formatScanResult(i, "<BR>");

        TXBuffer += F("");

      }

      TXBuffer += F("</table>");

    }



    TXBuffer += F("<BR><label class='container2'>other SSID:<input type='radio' name='ssid' id='other_ssid' value='other' ><span class='dotmark'></span></label>");

    TXBuffer += F("<input class='wide' type ='text' name='other' value='");

    TXBuffer += other;

    TXBuffer += F("'><BR><BR>");



    addFormSeparator (2);



    TXBuffer += F("<BR>Password:<BR><input class='wide' type ='text' name='pass' value='");

    TXBuffer += password;

    TXBuffer += F("'><BR><BR>");



    addSubmitButton(F("Connect"),F(""));

  }



  if (status == 1)

  {

    if (refreshCount > 0)

    {

      status = 0;





      TXBuffer += F("<a class='button' href='setup'>Back to Setup</a><BR><BR>");

    }

    else

    {

      int wait = 20;

      if (refreshCount != 0)

        wait = 3;

      TXBuffer += F("Please wait for <h1 id='countdown'>20..</h1>");

      TXBuffer += F("<script type='text/JavaScript'>");

      TXBuffer += F("function timedRefresh(timeoutPeriod) {");

      TXBuffer += F("   var timer = setInterval(function() {");

      TXBuffer += F("   if (timeoutPeriod > 0) {");

      TXBuffer += F("       timeoutPeriod -= 1;");

      TXBuffer += F("       document.getElementById('countdown').innerHTML = timeoutPeriod + '..' + '<br />';");

      TXBuffer += F("   } else {");

      TXBuffer += F("       clearInterval(timer);");

      TXBuffer += F("            window.location.href = window.location.href;");

      TXBuffer += F("       };");

      TXBuffer += F("   }, 1000);");

      TXBuffer += F("};");

      TXBuffer += F("timedRefresh(");

      TXBuffer += wait;

      TXBuffer += F(");");

      TXBuffer += F("</script>");

      TXBuffer += F("seconds while trying to connect");

    }

    refreshCount++;

  }



  TXBuffer += F("</form>");

   sendHeadandTail(F("TmplAP"),true);

  TXBuffer.endStream();

  delay(10);

}
# 9437 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_rules() {

  checkRAM(F("handle_rules"));

  if (!isLoggedIn()) return;

  navMenuIndex = 5;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));

  static byte currentSet = 1;





  String set = WebServer.arg(F("set"));

  byte rulesSet = 1;

  if (set.length() > 0)

  {

    rulesSet = set.toInt();

  }



  #if defined(ESP8266)

    String fileName = F("rules");

  #endif

  #if defined(ESP32)

    String fileName = F("/rules");

  #endif

  fileName += rulesSet;

  fileName += F(".txt");





  checkRAM(F("handle_rules"));







  if (WebServer.args() > 0)

  {

    String log = F("Rules : Save rulesSet: ");

    log += rulesSet;

    log += F(" currentSet: ");

    log += currentSet;



    if (currentSet == rulesSet)

    {

      String rules = WebServer.arg(F("rules"));

      log += F(" rules.length(): ");

      log += rules.length();

      if (rules.length() > RULES_MAX_SIZE)

        TXBuffer += F("<span style=\"color:red\">Data was not saved, exceeds web editor limit!</span>");

      else

      {
# 9547 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
          fs::File f = SPIFFS.open(fileName, "w");

          if (f)

          {

            log += F(" Write to file: ");

            log += fileName;

            f.print(rules);

            f.close();



          }



      }

    }

    else

    {

      if (!SPIFFS.exists(fileName))

      {

        log += F(" Create new file: ");

        log += fileName;

        fs::File f = SPIFFS.open(fileName, "w");

        f.close();

      }

    }

    addLog(LOG_LEVEL_INFO, log);



    log = F(" Webserver args:");

    for (int i = 0; i < WebServer.args(); ++i) {

      log += F(" ");

      log += i;

      log += F(": '");

      log += WebServer.argName(i);

      log += F("' length: ");

      log += WebServer.arg(i).length();

    }

    addLog(LOG_LEVEL_INFO, log);

  }



  if (rulesSet != currentSet)

    currentSet = rulesSet;



  TXBuffer += F("<form name = 'frmselect' method = 'post'><table class='normal'><TR><TH align='left'>Rules");



  byte choice = rulesSet;

  String options[RULESETS_MAX];

  int optionValues[RULESETS_MAX];

  for (byte x = 0; x < RULESETS_MAX; x++)

  {

    options[x] = F("Rules Set ");

    options[x] += x + 1;

    optionValues[x] = x + 1;

  }



   TXBuffer += F("<TR><TD>");

  addSelector(F("set"), RULESETS_MAX, options, optionValues, NULL, choice, true);

  addHelpButton(F("Tutorial_Rules"));







  int size = 0;

  fs::File f = SPIFFS.open(fileName, "r+");

  if (f)

  {

    size = f.size();

    if (size > RULES_MAX_SIZE)

       TXBuffer += F("<span style=\"color:red\">Filesize exceeds web editor limit!</span>");

    else

    {

       TXBuffer += F("<TR><TD><textarea name='rules' rows='30' wrap='off'>");

      while (f.available())

      {

        String c((char)f.read());

        htmlEscape(c);

         TXBuffer += c;

      }

       TXBuffer += F("</textarea>");

    }

    f.close();

  }



   TXBuffer += F("<TR><TD>Current size: ");

   TXBuffer += size;

   TXBuffer += F(" characters (Max ");

   TXBuffer += RULES_MAX_SIZE;

   TXBuffer += F(")");



  addFormSeparator(2);



   TXBuffer += F("<TR><TD>");

  addSubmitButton();

  addButton(fileName, F("Download to file"));

   TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();



  checkRuleSets();

}
# 9747 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
void handle_sysinfo() {

  checkRAM(F("handle_sysinfo"));

  if (!isLoggedIn()) return;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  int freeMem = ESP.getFreeHeap();



  addHeader(true, TXBuffer.buf);

   TXBuffer += printWebString;

   TXBuffer += F("<form>");





   TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>System Info<TH align='left'>");



   addCopyButton(F("copyText"), F("\\n"), F("Copy info to clipboard") );



   TXBuffer += githublogo;



   TXBuffer += F("<TR><TD>Unit<TD>");

   TXBuffer += Settings.Unit;



  if (Settings.UseNTP)

  {



     TXBuffer += F("<TR><TD>Local Time<TD>");

     TXBuffer += getDateTimeString('-', ':', ' ');

  }



   TXBuffer += F("<TR><TD>Uptime<TD>");

  char strUpTime[40];

  int minutes = wdcounter / 2;

  int days = minutes / 1440;

  minutes = minutes % 1440;

  int hrs = minutes / 60;

  minutes = minutes % 60;

  sprintf_P(strUpTime, PSTR("%d days %d hours %d minutes"), days, hrs, minutes);

   TXBuffer += strUpTime;



   TXBuffer += F("<TR><TD>Load<TD>");

  if (wdcounter > 0)

  {

     TXBuffer += 100 - (100 * loopCounterLast / loopCounterMax);

     TXBuffer += F("% (LC=");

     TXBuffer += int(loopCounterLast / 30);

     TXBuffer += F(")");

  }



   TXBuffer += F("<TR><TD>Free Mem<TD>");

   TXBuffer += freeMem;

   TXBuffer += F(" (");

   TXBuffer += lowestRAM;

   TXBuffer += F(" - ");

   TXBuffer += lowestRAMfunction;

   TXBuffer += F(")");



   TXBuffer += F("<TR><TD>Boot<TD>");

   TXBuffer += getLastBootCauseString();

   TXBuffer += F(" (");

   TXBuffer += RTC.bootCounter;

   TXBuffer += F(")");

#ifndef ESP32

   TXBuffer += F("<TR><TD>Reset Reason<TD>");

   TXBuffer += ESP.getResetReason();

#endif



   TXBuffer += F("<TR><TD colspan=2><H3>Network");

   addHelpButton(F("Wifi"));

   TXBuffer += F("</H3></TD></TR>");



  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

     TXBuffer += F("<TR><TD>Wifi<TD>");

    #if defined(ESP8266)

      byte PHYmode = wifi_get_phy_mode();

    #endif

    #if defined(ESP32)

      byte PHYmode = 3;

    #endif

    switch (PHYmode)

    {

      case 1:

         TXBuffer += F("802.11B");

        break;

      case 2:

         TXBuffer += F("802.11G");

        break;

      case 3:

         TXBuffer += F("802.11N");

        break;

    }

     TXBuffer += F(" (RSSI ");

     TXBuffer += WiFi.RSSI();

     TXBuffer += F(" dB)");

  }

  TXBuffer += F("<TR><TD>IP config<TD>");

  TXBuffer += useStaticIP() ? F("Static") : F("DHCP");



   TXBuffer += F("<TR><TD>IP / subnet<TD>");

   TXBuffer += formatIP(WiFi.localIP());

   TXBuffer += F(" / ");

   TXBuffer += formatIP(WiFi.subnetMask());



   TXBuffer += F("<TR><TD>GW<TD>");

   TXBuffer += formatIP(WiFi.gatewayIP());



  {

    TXBuffer += F("<TR><TD>Client IP<TD>");

    WiFiClient client(WebServer.client());

    TXBuffer += formatIP(client.remoteIP());

  }



  TXBuffer += F("<TR><TD>DNS<TD>");

  TXBuffer += formatIP(WiFi.dnsIP(0));

  TXBuffer += F(" / ");

  TXBuffer += formatIP(WiFi.dnsIP(1));



  TXBuffer += F("<TR><TD>Allowed IP Range<TD>");

  TXBuffer += describeAllowedIPrange();



  TXBuffer += F("<TR><TD>Serial Port available:<TD>");

  TXBuffer += String(SerialAvailableForWrite());

  TXBuffer += F(" (");

  #if defined(ESP8266)

    TXBuffer += Serial.availableForWrite();

  #endif

  TXBuffer += F(" , ");

  TXBuffer += Serial.available();

  TXBuffer += F(")");



  TXBuffer += F("<TR><TD>STA MAC<TD>");



  uint8_t mac[] = {0, 0, 0, 0, 0, 0};

  uint8_t* macread = WiFi.macAddress(mac);

  char macaddress[20];

  formatMAC(macread, macaddress);

  TXBuffer += macaddress;



  TXBuffer += F("<TR><TD>AP MAC<TD>");

  macread = WiFi.softAPmacAddress(mac);

  formatMAC(macread, macaddress);

  TXBuffer += macaddress;



  TXBuffer += F("<TR><TD>SSID<TD>");

  TXBuffer += WiFi.SSID();

  TXBuffer += F(" (");

  TXBuffer += WiFi.BSSIDstr();

  TXBuffer += F(")");



  TXBuffer += F("<TR><TD>Channel<TD>");

  TXBuffer += WiFi.channel();



  TXBuffer += F("<TR><TD>Connected<TD>");

  TXBuffer += format_msec_duration(timeDiff(lastConnectMoment, millis()));



  TXBuffer += F("<TR><TD>Last Disconnect Reason<TD>");

  TXBuffer += getLastDisconnectReason();



  TXBuffer += F("<TR><TD>Number reconnects<TD>");

  TXBuffer += wifi_reconnects;



  TXBuffer += F("<TR><TD colspan=2><H3>Firmware</H3></TD></TR>");



  TXBuffer += F("<TR><TD id='copyText_1'>Build<TD id='copyText_2'>");

  TXBuffer += BUILD;

  TXBuffer += F(" ");

  TXBuffer += F(BUILD_NOTES);



  TXBuffer += F("<TR><TD id='copyText_3'>Libraries<TD id='copyText_4'>");

  TXBuffer += getSystemLibraryString();



  TXBuffer += F("<TR><TD id='copyText_5'>GIT version<TD id='copyText_6'>");

  TXBuffer += BUILD_GIT;



  TXBuffer += F("<TR><TD id='copyText_7'>Plugins<TD id='copyText_8'>");

  TXBuffer += deviceCount + 1;

  TXBuffer += getPluginDescriptionString();



  TXBuffer += F("<TR><TD>Build Md5<TD>");

  for (byte i = 0; i<16; i++) TXBuffer += String(CRCValues.compileTimeMD5[i],HEX);



   TXBuffer += F("<TR><TD>Md5 check<TD>");

  if (! CRCValues.checkPassed())

     TXBuffer += F("<font color = 'red'>fail !</font>");

  else TXBuffer += F("passed.");



   TXBuffer += F("<TR><TD id='copyText_9'>Build time<TD id='copyText_10'>");

   TXBuffer += String(CRCValues.compileDate);

   TXBuffer += " ";

   TXBuffer += String(CRCValues.compileTime);



   TXBuffer += F("<TR><TD id='copyText_11'>Binary filename<TD id='copyText_12'>");

   TXBuffer += String(CRCValues.binaryFilename);



   TXBuffer += F("<TR><TD colspan=2><H3>ESP board</H3></TD></TR>");



   TXBuffer += F("<TR><TD>ESP Chip ID<TD>");

  #if defined(ESP8266)

     TXBuffer += ESP.getChipId();

     TXBuffer += F(" (0x");

    String espChipId(ESP.getChipId(), HEX);

    espChipId.toUpperCase();

     TXBuffer += espChipId;

     TXBuffer += F(")");



     TXBuffer += F("<TR><TD>ESP Chip Freq:<TD>");

     TXBuffer += ESP.getCpuFreqMHz();

     TXBuffer += F(" MHz");

  #endif

  #if defined(ESP32)

     TXBuffer += F(" (0x");

     uint64_t chipid=ESP.getEfuseMac();

     uint32_t ChipId1 = (uint16_t)(chipid>>32);

     String espChipIdS(ChipId1, HEX);

     espChipIdS.toUpperCase();

     TXBuffer += espChipIdS;

     ChipId1 = (uint32_t)chipid;

     String espChipIdS1(ChipId1, HEX);

     espChipIdS1.toUpperCase();

     TXBuffer += espChipIdS1;

     TXBuffer += F(")");



     TXBuffer += F("<TR><TD>ESP Chip Freq:<TD>");

     TXBuffer += ESP.getCpuFreqMHz();

     TXBuffer += F(" MHz");

  #endif







   TXBuffer += F("<TR><TD colspan=2><H3>Storage</H3></TD></TR>");



   TXBuffer += F("<TR><TD>Flash Chip ID<TD>");

  #if defined(ESP8266)

    uint32_t flashChipId = ESP.getFlashChipId();





     TXBuffer += F("Vendor: 0x");

    String flashVendor(flashChipId & 0xFF, HEX);

    flashVendor.toUpperCase();

     TXBuffer += flashVendor;

     TXBuffer += F(" Device: 0x");

    uint32_t flashDevice = (flashChipId & 0xFF00) | ((flashChipId >> 16) & 0xFF);

    String flashDeviceString(flashDevice, HEX);

    flashDeviceString.toUpperCase();

     TXBuffer += flashDeviceString;

  #endif

  uint32_t realSize = 0;

  #if defined(ESP8266)

    realSize = ESP.getFlashChipRealSize();

  #endif

  #if defined(ESP32)

    realSize = ESP.getFlashChipSize();

  #endif

  uint32_t ideSize = ESP.getFlashChipSize();



   TXBuffer += F("<TR><TD>Flash Chip Real Size:<TD>");

   TXBuffer += realSize / 1024;

   TXBuffer += F(" kB");



   TXBuffer += F("<TR><TD>Flash IDE Size:<TD>");

   TXBuffer += ideSize / 1024;

   TXBuffer += F(" kB");





  #if defined(ESP8266)

     TXBuffer += F("<TR><TD>Flash IDE speed:<TD>");

     TXBuffer += ESP.getFlashChipSpeed() / 1000000;

     TXBuffer += F(" MHz");



    FlashMode_t ideMode = ESP.getFlashChipMode();

     TXBuffer += F("<TR><TD>Flash IDE mode:<TD>");

    switch (ideMode) {

      case FM_QIO: TXBuffer += F("QIO"); break;

      case FM_QOUT: TXBuffer += F("QOUT"); break;

      case FM_DIO: TXBuffer += F("DIO"); break;

      case FM_DOUT: TXBuffer += F("DOUT"); break;

      default:

          TXBuffer += F("Unknown"); break;

    }

  #endif



   TXBuffer += F("<TR><TD>Flash Writes<TD>");

   TXBuffer += RTC.flashDayCounter;

   TXBuffer += F(" daily / ");

   TXBuffer += RTC.flashCounter;

   TXBuffer += F(" boot");



   TXBuffer += F("<TR><TD>Sketch Size<TD>");

  #if defined(ESP8266)

   TXBuffer += ESP.getSketchSize() / 1024;

   TXBuffer += F(" kB (");

   TXBuffer += ESP.getFreeSketchSpace() / 1024;

   TXBuffer += F(" kB free)");

  #endif



   TXBuffer += F("</table></form>");

   sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

}
# 10355 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/WebServer.ino"
String URLEncode(const char* msg)

{

  const char *hex = "0123456789abcdef";

  String encodedMsg = "";



  while (*msg != '\0') {

    if ( ('a' <= *msg && *msg <= 'z')

         || ('A' <= *msg && *msg <= 'Z')

         || ('0' <= *msg && *msg <= '9')

         || ('-' == *msg) || ('_' == *msg)

         || ('.' == *msg) || ('~' == *msg) ) {

      encodedMsg += *msg;

    } else {

      encodedMsg += '%';

      encodedMsg += hex[*msg >> 4];

      encodedMsg += hex[*msg & 15];

    }

    msg++;

  }

  return encodedMsg;

}





String getControllerSymbol(byte index)

{

  String ret = F("<p style='font-size:20px'>&#");

  ret += 10102 + index;

  ret += F(";</p>");

  return ret;

}



String getValueSymbol(byte index)

{

  String ret = F("&#");

  ret += 10112 + index;

  ret += F(";");

  return ret;

}





void handle_favicon() {

  checkRAM(F("handle_favicon"));

  WebServer.send_P(200, PSTR("image/x-icon"), favicon_8b_ico, favicon_8b_ico_len);

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C001.ino"
#ifdef USES_C001
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C001.ino"
#define CPLUGIN_001 

#define CPLUGIN_ID_001 1

#define CPLUGIN_NAME_001 "Domoticz HTTP"





boolean CPlugin_001(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_001;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 8080;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_001);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (event->idx != 0)

        {

          if (!WiFiConnected(100)) {

            success = false;

            break;

          }

          ControllerSettingsStruct ControllerSettings;

          LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof (ControllerSettings));



          String authHeader = "";

          if ((SecuritySettings.ControllerUser[event->ControllerIndex][0] != 0) && (SecuritySettings.ControllerPassword[event->ControllerIndex][0] != 0))

          {

            base64 encoder;

            String auth = SecuritySettings.ControllerUser[event->ControllerIndex];

            auth += ":";

            auth += SecuritySettings.ControllerPassword[event->ControllerIndex];

            authHeader = F("Authorization: Basic ");

            authHeader += encoder.encode(auth);

            authHeader += F(" \r\n");

          }





          addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+ControllerSettings.getHostPortString());







          WiFiClient client;

          if (!ControllerSettings.connectToHost(client))

          {

            connectionFailures++;



            addLog(LOG_LEVEL_ERROR, F("HTTP : connection failed"));

            return false;

          }

          statusLED(true);

          if (connectionFailures)

            connectionFailures--;





          String url = F("/json.htm?type=command&param=udevice&idx=");

          url += event->idx;



          switch (event->sensorType)

          {

            case SENSOR_TYPE_SWITCH:

              url = F("/json.htm?type=command&param=switchlight&idx=");

              url += event->idx;

              url += F("&switchcmd=");

              if (UserVar[event->BaseVarIndex] == 0)

                url += F("Off");

              else

                url += F("On");

              break;

            case SENSOR_TYPE_DIMMER:

              url = F("/json.htm?type=command&param=switchlight&idx=");

              url += event->idx;

              url += F("&switchcmd=");

              if (UserVar[event->BaseVarIndex] == 0) {

                url += ("Off");

              } else {

                url += F("Set%20Level&level=");

                url += UserVar[event->BaseVarIndex];

              }

              break;



            case SENSOR_TYPE_SINGLE:

            case SENSOR_TYPE_LONG:

            case SENSOR_TYPE_DUAL:

            case SENSOR_TYPE_TRIPLE:

            case SENSOR_TYPE_QUAD:

            case SENSOR_TYPE_TEMP_HUM:

            case SENSOR_TYPE_TEMP_BARO:

            case SENSOR_TYPE_TEMP_HUM_BARO:

            case SENSOR_TYPE_WIND:

            default:

              url = F("/json.htm?type=command&param=udevice&idx=");

              url += event->idx;

              url += F("&nvalue=0");

              url += F("&svalue=");

              url += formatDomoticzSensorType(event);

              break;

          }





          url += F("&rssi=");

          url += mapRSSItoDomoticz();

          #if FEATURE_ADC_VCC

            url += F("&battery=");

            url += mapVccToDomoticz();

          #endif





          String request = F("GET ");

          request += url;

          request += F(" HTTP/1.1\r\n");

          request += F("Host: ");

          request += ControllerSettings.getHost();

          request += F("\r\n");

          request += authHeader;

          request += F("Connection: close\r\n\r\n");

          client.print(request);



          unsigned long timer = millis() + 200;

          while (!client.available() && !timeOutReached(timer))

            yield();





          while (client.available()) {



            String line;

            safeReadStringUntil(client, line, '\n');

            addLog(LOG_LEVEL_DEBUG_MORE, line);

            if (line.startsWith(F("HTTP/1.1 200 OK")) )

            {

              addLog(LOG_LEVEL_DEBUG, F("HTTP : Success"));

              success = true;

            }

            yield();

          }

          addLog(LOG_LEVEL_DEBUG, F("HTTP : closing connection"));



          client.flush();

          client.stop();

        }

        else

        {

          addLog(LOG_LEVEL_ERROR, F("HTTP : IDX cannot be zero!"));

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C002.ino"
#ifdef USES_C002
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C002.ino"
#define CPLUGIN_002 

#define CPLUGIN_ID_002 2

#define CPLUGIN_NAME_002 "Domoticz MQTT"



#include <ArduinoJson.h>



boolean CPlugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_002;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_002);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("domoticz/out");

        event->String2 = F("domoticz/in");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {
# 97 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C002.ino"
        byte ControllerID = findFirstEnabledControllerWithId(CPLUGIN_ID_002);

        if (ControllerID < CONTROLLER_MAX) {

          StaticJsonBuffer<512> jsonBuffer;

          JsonObject& root = jsonBuffer.parseObject(event->String2.c_str());

          if (root.success())

          {

            unsigned int idx = root[F("idx")];

            float nvalue = root[F("nvalue")];

            long nvaluealt = root[F("nvalue")];





            const char* svalue1 = root[F("svalue1")];





            const char* switchtype = root[F("switchType")];

            if (nvalue == 0)

              nvalue = nvaluealt;

            if ((int)switchtype == 0)

              switchtype = "?";



            for (byte x = 0; x < TASKS_MAX; x++) {



              if (Settings.TaskDeviceEnabled[x] && Settings.TaskDeviceID[ControllerID][x] == idx)

              {

                String action = "";

                switch (Settings.TaskDeviceNumber[x]) {

                  case 1:

                  {

                    action = F("inputSwitchState,");

                    action += x;

                    action += ",";

                    action += nvalue;

                    break;

                  }

                  case 29:

                  {

                    action = "";

                    int baseVar = x * VARS_PER_TASK;

                    struct EventStruct TempEvent;

                    if (strcasecmp_P(switchtype, PSTR("dimmer")) == 0)

                    {

                      int pwmValue = UserVar[baseVar];

                      action = F("pwm,");

                      action += Settings.TaskDevicePin1[x];

                      action += ",";

                      switch ((int)nvalue)

                      {

                        case 0:

                          pwmValue = 0;

                          break;

                        case 1:

                          pwmValue = UserVar[baseVar];

                          break;

                        case 2:

                          pwmValue = 10 * atol(svalue1);

                          UserVar[baseVar] = pwmValue;

                          break;

                      }

                      action += pwmValue;

                    } else {

                      UserVar[baseVar] = nvalue;

                      action = F("gpio,");

                      action += Settings.TaskDevicePin1[x];

                      action += ",";

                      action += nvalue;

                    }

                    break;

                  }

                  default:

                    break;

                }

                if (action.length() > 0) {

                  struct EventStruct TempEvent;

                  parseCommandString(&TempEvent, action);

                  PluginCall(PLUGIN_WRITE, &TempEvent, action);



                  if (Settings.UseRules)

                    createRuleEvents(x);

                }

              }

            }

          }

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (event->idx != 0)

        {

          ControllerSettingsStruct ControllerSettings;

          LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));

          if (!ControllerSettings.checkHostReachable(true)) {

            success = false;

            break;

          }

          StaticJsonBuffer<200> jsonBuffer;



          JsonObject& root = jsonBuffer.createObject();

          root[F("idx")] = event->idx;

          root[F("RSSI")] = mapRSSItoDomoticz();

          #if FEATURE_ADC_VCC

            root[F("Battery")] = mapVccToDomoticz();

          #endif



          switch (event->sensorType)

          {

            case SENSOR_TYPE_SWITCH:

              root[F("command")] = String(F("switchlight"));

              if (UserVar[event->BaseVarIndex] == 0)

                root[F("switchcmd")] = String(F("Off"));

              else

                root[F("switchcmd")] = String(F("On"));

              break;

            case SENSOR_TYPE_DIMMER:

              root[F("command")] = String(F("switchlight"));

              if (UserVar[event->BaseVarIndex] == 0)

                root[F("switchcmd")] = String(F("Off"));

              else

                root[F("Set%20Level")] = UserVar[event->BaseVarIndex];

              break;



            case SENSOR_TYPE_SINGLE:

            case SENSOR_TYPE_LONG:

            case SENSOR_TYPE_DUAL:

            case SENSOR_TYPE_TRIPLE:

            case SENSOR_TYPE_QUAD:

            case SENSOR_TYPE_TEMP_HUM:

            case SENSOR_TYPE_TEMP_BARO:

            case SENSOR_TYPE_TEMP_HUM_BARO:

            case SENSOR_TYPE_WIND:

            default:

              root[F("nvalue")] = 0;

              root[F("svalue")] = formatDomoticzSensorType(event);

              break;

          }



          String json;

          root.printTo(json);

          String log = F("MQTT : ");

          log += json;

          addLog(LOG_LEVEL_DEBUG, log);



          String pubname = ControllerSettings.Publish;

          parseControllerVariables(pubname, event, false);

          if (!MQTTpublish(event->ControllerIndex, pubname.c_str(), json.c_str(), Settings.MQTTRetainFlag))

          {

            connectionFailures++;

          }

          else if (connectionFailures)

            connectionFailures--;



        }

        else

        {

          String log = F("MQTT : IDX cannot be zero!");

          addLog(LOG_LEVEL_ERROR, log);

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C003.ino"
#ifdef USES_C003
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C003.ino"
#define CPLUGIN_003 

#define CPLUGIN_ID_003 3

#define CPLUGIN_NAME_003 "Nodo Telnet"



boolean CPlugin_003(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_003;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 23;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_003);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



        boolean success = false;

        char log[80];

        addLog(LOG_LEVEL_DEBUG, String(F("TELNT : connecting to ")) + ControllerSettings.getHostPortString());



        WiFiClient client;

        if (!ControllerSettings.connectToHost(client))

        {

          connectionFailures++;

          strcpy_P(log, PSTR("TELNT: connection failed"));

          addLog(LOG_LEVEL_ERROR, log);

          return false;

        }

        statusLED(true);

        if (connectionFailures)

          connectionFailures--;





        String url = F("variableset ");

        url += event->idx;

        url += ",";

        url += formatUserVarNoCheck(event, 0);

        url += "\n";







        client.print(" \n");



        unsigned long timer = millis() + 200;

        while (!client.available() && !timeOutReached(timer))

          delay(1);



        timer = millis() + 1000;

        while (client.available() && !timeOutReached(timer) && !success)

        {





          String line;

          safeReadStringUntil(client, line, '\n');



          if (line.startsWith(F("Enter your password:")))

          {

            success = true;

            strcpy_P(log, PSTR("TELNT: Password request ok"));

            addLog(LOG_LEVEL_DEBUG, log);

          }

          delay(1);

        }



        strcpy_P(log, PSTR("TELNT: Sending pw"));

        addLog(LOG_LEVEL_DEBUG, log);

        client.println(SecuritySettings.ControllerPassword[event->ControllerIndex]);

        delay(100);

        while (client.available())

          client.read();



        strcpy_P(log, PSTR("TELNT: Sending cmd"));

        addLog(LOG_LEVEL_DEBUG, log);

        client.print(url);

        delay(10);

        while (client.available())

          client.read();



        strcpy_P(log, PSTR("TELNT: closing connection"));

        addLog(LOG_LEVEL_DEBUG, log);



        client.stop();



        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C004.ino"
#ifdef USES_C004
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C004.ino"
#define CPLUGIN_004 

#define CPLUGIN_ID_004 4

#define CPLUGIN_NAME_004 "ThingSpeak"



boolean CPlugin_004(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_004;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_004);

        break;

      }



    case CPLUGIN_GET_PROTOCOL_DISPLAY_NAME:

      {

        success = true;

        switch (event->idx) {

          case CONTROLLER_USER:

            string = F("ThingHTTP Name");

            break;

          case CONTROLLER_PASS:

            string = F("API Key");

            break;

          default:

            success = false;

            break;

        }

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));





        addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+ControllerSettings.getHostPortString());

        char log[80];



        WiFiClient client;

        if (!ControllerSettings.connectToHost(client))

        {

          connectionFailures++;

          strcpy_P(log, PSTR("HTTP : connection failed"));

          addLog(LOG_LEVEL_ERROR, log);

          return false;

        }

        statusLED(true);

        if (connectionFailures)

          connectionFailures--;



        String postDataStr = F("api_key=");

        postDataStr += SecuritySettings.ControllerPassword[event->ControllerIndex];



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          postDataStr += F("&field");

          postDataStr += event->idx + x;

          postDataStr += "=";

          postDataStr += formatUserVarNoCheck(event, x);

        }

        String hostName = F("api.thingspeak.com");

        if (ControllerSettings.UseDNS)

          hostName = ControllerSettings.HostName;



        String postStr = F("POST /update HTTP/1.1\r\n");

        postStr += F("Host: ");

        postStr += hostName;

        postStr += F("\r\n");

        postStr += F("Connection: close\r\n");



        postStr += F("Content-Type: application/x-www-form-urlencoded\r\n");

        postStr += F("Content-Length: ");

        postStr += postDataStr.length();

        postStr += F("\r\n\r\n");

        postStr += postDataStr;





        client.print(postStr);



        unsigned long timer = millis() + 200;

        while (!client.available() && !timeOutReached(timer))

          delay(1);





        while (client.available()) {



          String line;

          safeReadStringUntil(client, line, '\n');



          line.toCharArray(log, 80);

          addLog(LOG_LEVEL_DEBUG_MORE, log);

          if (line.substring(0, 15) == F("HTTP/1.1 200 OK"))

          {

            strcpy_P(log, PSTR("HTTP : Success!"));

            addLog(LOG_LEVEL_DEBUG, log);

            success = true;

          }

          delay(1);

        }

        strcpy_P(log, PSTR("HTTP : closing connection"));

        addLog(LOG_LEVEL_DEBUG, log);



        client.flush();

        client.stop();

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C005.ino"
#ifdef USES_C005
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C005.ino"
#define CPLUGIN_005 

#define CPLUGIN_ID_005 5

#define CPLUGIN_NAME_005 "OpenHAB MQTT"



boolean CPlugin_005(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_005;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_005);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("/%sysname%/#");

        event->String2 = F("/%sysname%/%tskname%/%valname%");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {

        byte ControllerID = findFirstEnabledControllerWithId(CPLUGIN_ID_005);

        if (ControllerID == CONTROLLER_MAX) {



          break;

        } else {

          String cmd;

          struct EventStruct TempEvent;

          bool validTopic = false;

          const int lastindex = event->String1.lastIndexOf('/');

          const String lastPartTopic = event->String1.substring(lastindex + 1);

          if (lastPartTopic == F("cmd")) {

            cmd = event->String2;

            parseCommandString(&TempEvent, cmd);

            TempEvent.Source = VALUE_SOURCE_MQTT;

            validTopic = true;

          } else {

            if (lastindex > 0) {



              if (isFloat(event->String2) && isInt(lastPartTopic)) {

                int prevLastindex = event->String1.lastIndexOf('/', lastindex - 1);

                cmd = event->String1.substring(prevLastindex + 1, lastindex);

                TempEvent.Par1 = lastPartTopic.toInt();

                TempEvent.Par2 = event->String2.toFloat();

                TempEvent.Par3 = 0;

                validTopic = true;

              }

            }

          }

          if (validTopic) {



            String command = parseString(cmd, 1);

            if (command == F("event")) {

            eventBuffer = cmd.substring(6);

            } else if (!PluginCall(PLUGIN_WRITE, &TempEvent, cmd)) {

              remoteConfig(&TempEvent, cmd);

            }

          }

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



        statusLED(true);



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        String pubname = ControllerSettings.Publish;

        parseControllerVariables(pubname, event, false);



        String value = "";



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          String tmppubname = pubname;

          tmppubname.replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[x]);

          value = formatUserVarNoCheck(event, x);



          MQTTpublish(event->ControllerIndex, tmppubname.c_str(), value.c_str(), Settings.MQTTRetainFlag);

          String log = F("MQTT : ");

          log += tmppubname;

          log += " ";

          log += value;

          addLog(LOG_LEVEL_DEBUG, log);

        }

        break;

      }

  }



  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C006.ino"
#ifdef USES_C006
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C006.ino"
#define CPLUGIN_006 

#define CPLUGIN_ID_006 6

#define CPLUGIN_NAME_006 "PiDome MQTT"



boolean CPlugin_006(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_006;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_006);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("/Home/#");

        event->String2 = F("/hooks/devices/%id%/SensorData/%valname%");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {





        String tmpTopic = event->String1.substring(1);

        String topicSplit[10];

        int SlashIndex = tmpTopic.indexOf('/');

        byte count = 0;

        while (SlashIndex > 0 && count < 10 - 1)

        {

          topicSplit[count] = tmpTopic.substring(0, SlashIndex);

          tmpTopic = tmpTopic.substring(SlashIndex + 1);

          SlashIndex = tmpTopic.indexOf('/');

          count++;

        }

        topicSplit[count] = tmpTopic;



        String name = topicSplit[4];

        String cmd = topicSplit[5];

        struct EventStruct TempEvent;

        TempEvent.Par1 = topicSplit[6].toInt();

        TempEvent.Par2 = 0;

        TempEvent.Par3 = 0;

        if (event->String2 == F("false") || event->String2 == F("true"))

        {

          if (event->String2 == F("true"))

            TempEvent.Par2 = 1;

        }

        else

          TempEvent.Par2 = event->String2.toFloat();

        if (name == Settings.Name)

        {

          PluginCall(PLUGIN_WRITE, &TempEvent, cmd);

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



        statusLED(true);



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        String pubname = ControllerSettings.Publish;

        parseControllerVariables(pubname, event, false);



        String value = "";



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          String tmppubname = pubname;

          tmppubname.replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[x]);

          value = formatUserVarNoCheck(event, x);

          MQTTpublish(event->ControllerIndex, tmppubname.c_str(), value.c_str(), Settings.MQTTRetainFlag);

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C007.ino"
#ifdef USES_C007
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C007.ino"
#define CPLUGIN_007 

#define CPLUGIN_ID_007 7

#define CPLUGIN_NAME_007 "Emoncms"



boolean CPlugin_007(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_007;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_007);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        const byte valueCount = getValueCountFromSensorType(event->sensorType);

        if (valueCount == 0 || valueCount > 3) {

          addLog(LOG_LEVEL_ERROR, F("emoncms : Unknown sensortype or too many sensor values"));

          break;

        }



        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));





        addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+ControllerSettings.getHostPortString());

        char log[80];



        WiFiClient client;

        if (!ControllerSettings.connectToHost(client))

        {

          connectionFailures++;

          strcpy_P(log, PSTR("HTTP : connection failed"));

          addLog(LOG_LEVEL_ERROR, log);

          return false;

        }

        statusLED(true);

        if (connectionFailures)

          connectionFailures--;



        String postDataStr = F("GET /emoncms/input/post.json?node=");



        postDataStr += Settings.Unit;

        postDataStr += F("&json=");



        for (byte i = 0; i < valueCount; ++i) {

          postDataStr += (i == 0) ? F("{") : F(",");

          postDataStr += F("field");

          postDataStr += event->idx + i;

          postDataStr += ":";

          postDataStr += formatUserVarNoCheck(event, i);

        }

        postDataStr += "}";

        postDataStr += F("&apikey=");

        postDataStr += SecuritySettings.ControllerPassword[event->ControllerIndex];



        String postStr = F(" HTTP/1.1\r\n");

        postStr += F("Host: ");

        postStr += ControllerSettings.getHost();

        postStr += F("\r\n");

        postStr += F("Connection: close\r\n");

        postStr += F("\r\n");



        postDataStr += postStr;



        if (Settings.SerialLogLevel >= LOG_LEVEL_DEBUG_MORE)

          Serial.println(postDataStr);





        client.print(postDataStr);



        unsigned long timer = millis() + 200;

        while (!client.available() && !timeOutReached(timer))

          delay(1);





        while (client.available()) {



          String line;

          safeReadStringUntil(client, line, '\n');



          line.toCharArray(log, 80);

          addLog(LOG_LEVEL_DEBUG_MORE, log);

          if (line.substring(0, 15) == F("HTTP/1.1 200 OK"))

          {

            strcpy_P(log, PSTR("HTTP : Success!"));

            addLog(LOG_LEVEL_DEBUG, log);

            success = true;

          }

          delay(1);

        }

        strcpy_P(log, PSTR("HTTP : closing connection"));

        addLog(LOG_LEVEL_DEBUG, log);



        client.flush();

        client.stop();

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C008.ino"
#ifdef USES_C008
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C008.ino"
#define CPLUGIN_008 

#define CPLUGIN_ID_008 8

#define CPLUGIN_NAME_008 "Generic HTTP"

#include <ArduinoJson.h>



boolean CPlugin_008(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_008;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_008);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = F("demo.php?name=%sysname%&task=%tskname%&valuename=%valname%&value=%value%");

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          bool isvalid;

          String formattedValue = formatUserVar(event, x, isvalid);

          if (isvalid)

            HTTPSend(event, x, formattedValue);

          if (valueCount > 1)

          {

            delayBackground(Settings.MessageDelay);







          }

        }

        break;

      }



  }

  return success;

}
# 139 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C008.ino"
boolean HTTPSend(struct EventStruct *event, byte varIndex, const String& formattedValue)

{

  if (!WiFiConnected(100)) {

    return false;

  }

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



  String authHeader = "";

  if ((SecuritySettings.ControllerUser[event->ControllerIndex][0] != 0) && (SecuritySettings.ControllerPassword[event->ControllerIndex][0] != 0))

  {

    base64 encoder;

    String auth = SecuritySettings.ControllerUser[event->ControllerIndex];

    auth += ":";

    auth += SecuritySettings.ControllerPassword[event->ControllerIndex];

    authHeader = F("Authorization: Basic ");

    authHeader += encoder.encode(auth) + " \r\n";

  }





  addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+ControllerSettings.getHostPortString());





  WiFiClient client;

  if (!ControllerSettings.connectToHost(client))

  {

    connectionFailures++;

    addLog(LOG_LEVEL_ERROR, F("HTTP : connection failed"));

    return false;

  }

  statusLED(true);

  if (connectionFailures)

    connectionFailures--;



  if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

    PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



  String url = "/";

  url += ControllerSettings.Publish;

  parseControllerVariables(url, event, true);



  url.replace(F("%valname%"), URLEncode(ExtraTaskSettings.TaskDeviceValueNames[varIndex]));

  url.replace(F("%value%"), formattedValue);





  addLog(LOG_LEVEL_DEBUG_MORE, url);





  client.print(String(F("GET ")) + url + F(" HTTP/1.1\r\n") +

               F("Host: ") + ControllerSettings.getHost() + F("\r\n") + authHeader +

               F("Connection: close\r\n\r\n"));



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    yield();





  while (client.available()) {



    String line;

    safeReadStringUntil(client, line, '\n');





    addLog(LOG_LEVEL_DEBUG_MORE, line);

    if (line.startsWith(F("HTTP/1.1 200 OK")))

    {





      addLog(LOG_LEVEL_DEBUG, F("HTTP : Success!"));



    }

    delay(1);

  }





  addLog(LOG_LEVEL_DEBUG, F("HTTP : closing connection"));



  client.flush();

  client.stop();



  return(true);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C009.ino"
#ifdef USES_C009
# 57 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C009.ino"
#define CPLUGIN_009 

#define CPLUGIN_ID_009 9

#define CPLUGIN_NAME_009 "FHEM HTTP"

#include <ArduinoJson.h>



boolean CPlugin_009(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_009;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].usesID = false;

        Protocol[protocolCount].defaultPort = 8383;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_009);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);





        String url = F("/ESPEasy");





        DynamicJsonBuffer jsonBuffer;

        JsonObject& root = jsonBuffer.createObject();

        root[F("module")] = String(F("ESPEasy"));

        root[F("version")] = String(F("1.04"));





        JsonObject& data = root.createNestedObject(String(F("data")));

        JsonObject& ESP = data.createNestedObject(String(F("ESP")));

        ESP[F("name")] = Settings.Name;

        ESP[F("unit")] = Settings.Unit;

        ESP[F("version")] = Settings.Version;

        ESP[F("build")] = Settings.Build;

        ESP[F("build_notes")] = String(F(BUILD_NOTES));

        ESP[F("build_git")] = String(F(BUILD_GIT));

        ESP[F("node_type_id")] = NODE_TYPE_ID;

        ESP[F("sleep")] = Settings.deepSleep;
# 183 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C009.ino"
        ESP[F("ip")] = WiFi.localIP().toString();





        JsonObject& SENSOR = data.createNestedObject(String(F("SENSOR")));

        byte valueCount = getValueCountFromSensorType(event->sensorType);



        for (byte x = 0; x < valueCount; x++)

        {





          JsonObject& val = SENSOR.createNestedObject(String(x));

          val[F("deviceName")] = ExtraTaskSettings.TaskDeviceName;

          val[F("valueName")] = ExtraTaskSettings.TaskDeviceValueNames[x];

          val[F("type")] = event->sensorType;

          val[F("value")] = formatUserVarNoCheck(event, x);

        }
# 223 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C009.ino"
        String jsonString;

        root.printTo(jsonString);



        FHEMHTTPsend(url, jsonString, event->ControllerIndex);

        break;

      }

  }

  return success;

}
# 253 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C009.ino"
void FHEMHTTPsend(String & url, String & buffer, byte index)

{

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(index, (byte*)&ControllerSettings, sizeof(ControllerSettings));







  String authHeader = "";

  if ((SecuritySettings.ControllerUser[index][0] != 0) && (SecuritySettings.ControllerPassword[index][0] != 0)) {

    base64 encoder;

    String auth = SecuritySettings.ControllerUser[index];

    auth += ":";

    auth += SecuritySettings.ControllerPassword[index];

    authHeader = String(F("Authorization: Basic ")) + encoder.encode(auth) + " \r\n";

  }



  addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+ControllerSettings.getHostPortString());





  WiFiClient client;

  if (!ControllerSettings.connectToHost(client)) {

    connectionFailures++;



    addLog(LOG_LEVEL_ERROR, F("HTTP : connection failed"));

    return;

  }



  statusLED(true);

  if (connectionFailures)

    connectionFailures--;





  int len = buffer.length();

  client.print(String("POST ") + url + F(" HTTP/1.1\r\n") +

              F("Content-Length: ")+ len + F("\r\n") +

              F("Host: ") + ControllerSettings.getHost() + F("\r\n") + authHeader +

              F("Connection: close\r\n\r\n")

              + buffer);



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    yield();





  while (client.available()) {



    String line;

    safeReadStringUntil(client, line, '\n');







    addLog(LOG_LEVEL_DEBUG_MORE, line);



    if (line.startsWith(F("HTTP/1.1 200 OK"))) {



      addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP : Success"));



    }

    else if (line.startsWith(F("HTTP/1.1 4"))) {

      addLog(LOG_LEVEL_ERROR, String(F("HTTP : Error: "))+line);

    }

    yield();

  }



  addLog(LOG_LEVEL_DEBUG, F("HTTP : closing connection"));

  client.flush();

  client.stop();

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C010.ino"
#ifdef USES_C010
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C010.ino"
#define CPLUGIN_010 

#define CPLUGIN_ID_010 10

#define CPLUGIN_NAME_010 "Generic UDP"



boolean CPlugin_010(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_010;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 514;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_010);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = F("%sysname%_%tskname%_%valname%=%value%");

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          bool isvalid;

          String formattedValue = formatUserVar(event, x, isvalid);

          if (isvalid)

            C010_Send(event, x, formattedValue);

          if (valueCount > 1)

          {

            delayBackground(Settings.MessageDelay);







          }

        }

        break;

      }



  }

  return success;

}
# 137 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C010.ino"
void C010_Send(struct EventStruct *event, byte varIndex, const String& formattedValue)

{

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



  char log[80];



  addLog(LOG_LEVEL_DEBUG, String(F("UDP  : sending to ")) + ControllerSettings.getHostPortString());

  statusLED(true);



  if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

    PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



  String msg = "";

  msg += ControllerSettings.Publish;

  parseControllerVariables(msg, event, false);

  msg.replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[varIndex]);

  msg.replace(F("%value%"), formattedValue);



  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {

    ControllerSettings.beginPacket(portUDP);

    portUDP.write((uint8_t*)msg.c_str(),msg.length());

    portUDP.endPacket();

  }



  msg.toCharArray(log, 80);

  addLog(LOG_LEVEL_DEBUG_MORE, log);



}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C011.ino"
#ifdef USES_C011
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C011.ino"
#define CPLUGIN_011 

#define CPLUGIN_ID_011 11

#define CPLUGIN_NAME_011 "Generic HTTP Advanced [TESTING]"



#define C011_HTTP_METHOD_MAX_LEN 16

#define C011_HTTP_URI_MAX_LEN 240

#define C011_HTTP_HEADER_MAX_LEN 256

#define C011_HTTP_BODY_MAX_LEN 512



struct C011_ConfigStruct

{

  char HttpMethod[C011_HTTP_METHOD_MAX_LEN];

  char HttpUri[C011_HTTP_URI_MAX_LEN];

  char HttpHeader[C011_HTTP_HEADER_MAX_LEN];

  char HttpBody[C011_HTTP_BODY_MAX_LEN];

};



boolean CPlugin_011(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_011;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_011);

        break;

      }



    case CPLUGIN_WEBFORM_LOAD:

      {

        String escapeBuffer;



        C011_ConfigStruct customConfig;



        LoadCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));

        String methods[] = { F("GET"), F("POST"), F("PUT"), F("HEAD"), F("PATCH") };

        string += F("<TR><TD>HTTP Method :<TD><select name='P011httpmethod'>");

        for (byte i = 0; i < 5; i++)

        {

          string += F("<option value='");

          string += methods[i] + "'";

          string += methods[i].equals(customConfig.HttpMethod) ? F(" selected='selected'") : F("");

          string += F(">");

          string += methods[i];

          string += F("</option>");

        }

        string += F("</select>");



        string += F("<TR><TD>HTTP URI:<TD><input type='text' name='P011httpuri' size=80 maxlength='");

        string += C011_HTTP_URI_MAX_LEN-1;

        string += F("' value='");

        string += customConfig.HttpUri;



        string += F("'>");



        string += F("<TR><TD>HTTP Header:<TD><textarea name='P011httpheader' rows='4' cols='50' maxlength='");

        string += C011_HTTP_HEADER_MAX_LEN-1;

        string += F("'>");

        escapeBuffer=customConfig.HttpHeader;

        htmlEscape(escapeBuffer);

        string += escapeBuffer;

        string += F("</textarea>");



        string += F("<TR><TD>HTTP Body:<TD><textarea name='P011httpbody' rows='8' cols='50' maxlength='");

        string += C011_HTTP_BODY_MAX_LEN-1;

        string += F("'>");

        escapeBuffer=customConfig.HttpBody;

        htmlEscape(escapeBuffer);

        string += escapeBuffer;

        string += F("</textarea>");

        break;

      }



    case CPLUGIN_WEBFORM_SAVE:

      {

        C011_ConfigStruct customConfig;

        String httpmethod = WebServer.arg(F("P011httpmethod"));

        String httpuri = WebServer.arg(F("P011httpuri"));

        String httpheader = WebServer.arg(F("P011httpheader"));

        String httpbody = WebServer.arg(F("P011httpbody"));



        strlcpy(customConfig.HttpMethod, httpmethod.c_str(), sizeof(customConfig.HttpMethod));

        strlcpy(customConfig.HttpUri, httpuri.c_str(), sizeof(customConfig.HttpUri));

        strlcpy(customConfig.HttpHeader, httpheader.c_str(), sizeof(customConfig.HttpHeader));

        strlcpy(customConfig.HttpBody, httpbody.c_str(), sizeof(customConfig.HttpBody));

        SaveCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

       HTTPSend011(event);

      }



  }

  return success;

}
# 243 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C011.ino"
boolean HTTPSend011(struct EventStruct *event)

{

  if (!WiFiConnected(100)) {

    return false;

  }

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



  String authHeader = "";

  if ((SecuritySettings.ControllerUser[event->ControllerIndex][0] != 0) && (SecuritySettings.ControllerPassword[event->ControllerIndex][0] != 0))

  {

    base64 encoder;

    String auth = SecuritySettings.ControllerUser[event->ControllerIndex];

    auth += ":";

    auth += SecuritySettings.ControllerPassword[event->ControllerIndex];

    authHeader = F("Authorization: Basic ");

    authHeader += encoder.encode(auth);

    authHeader += F(" \r\n");

  }



  C011_ConfigStruct customConfig;

  LoadCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));



  boolean success = false;

  addLog(LOG_LEVEL_DEBUG, String(F("HTTP : connecting to "))+

      ControllerSettings.getHostPortString());





  WiFiClient client;

  if (!ControllerSettings.connectToHost(client))

  {

    connectionFailures++;

    addLog(LOG_LEVEL_ERROR, F("HTTP : connection failed"));

    return false;

  }

  statusLED(true);

  if (connectionFailures)

    connectionFailures--;



  if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

    PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



  String payload = String(customConfig.HttpMethod) + " /";

  payload += customConfig.HttpUri;

  payload += F(" HTTP/1.1\r\n");

  payload += F("Host: ");

  payload += ControllerSettings.getHostPortString();

  payload += F("\r\n");

  payload += authHeader;

  payload += F("Connection: close\r\n");



  if (strlen(customConfig.HttpHeader) > 0)

    payload += customConfig.HttpHeader;

  ReplaceTokenByValue(payload, event);



  if (strlen(customConfig.HttpBody) > 0)

  {

    String body = String(customConfig.HttpBody);

    ReplaceTokenByValue(body, event);

    payload += F("\r\nContent-Length: ");

    payload += String(body.length());

    payload += F("\r\n\r\n");

    payload += body;

  }

  payload += F("\r\n");





  client.print(payload);

  addLog(LOG_LEVEL_DEBUG_MORE, payload);



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    yield();





  while (client.available()) {



    String line;

    safeReadStringUntil(client, line, '\n');







    addLog(LOG_LEVEL_DEBUG_MORE, line);

    if (line.startsWith(F("HTTP/1.1 2")))

    {

      addLog(LOG_LEVEL_DEBUG, F("HTTP : Success!"));

      success = true;

    }

    yield();

  }

  addLog(LOG_LEVEL_DEBUG, F("HTTP : closing connection"));



  client.flush();

  client.stop();



  return(success);

}







void DeleteNotNeededValues(String &s, byte numberOfValuesWanted)

{

 numberOfValuesWanted++;

 for (byte i=1; i < 5; i++)

 {

    String startToken=String(F("%")) + i + F("%");

    String endToken=String(F("%/")) + i + F("%");





    if (i<numberOfValuesWanted)

    {



      s.replace(startToken, "");

      s.replace(endToken, "");

    }

    else

    {



      int startIndex=s.indexOf(startToken);

      int endIndex=s.indexOf(endToken);

      while(startIndex != -1 && endIndex != -1 && endIndex>startIndex)

    {

        String p = s.substring(startIndex,endIndex+4);



    s.replace(p, F(""));





        startIndex=s.indexOf(startToken);

        endIndex=s.indexOf(endToken);

    }

    }

 }

}
# 533 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C011.ino"
void ReplaceTokenByValue(String& s, struct EventStruct *event)

{







 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP before parsing: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);

  const byte valueCount = getValueCountFromSensorType(event->sensorType);

  DeleteNotNeededValues(s,valueCount);



 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP after parsing: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);



  parseControllerVariables(s, event, true);



 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP after replacements: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C012.ino"
#ifdef USES_C012
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C012.ino"
#define CPLUGIN_012 

#define CPLUGIN_ID_012 12

#define CPLUGIN_NAME_012 "Blynk HTTP [TESTING]"



boolean CPlugin_012(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_012;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_012);

        break;

      }



     case CPLUGIN_PROTOCOL_SEND:

      {

        if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

          success = false;

          break;

        }



        String postDataStr = F("");

        const byte valueCount = getValueCountFromSensorType(event->sensorType);

        success = CPlugin_012_send(event, valueCount);

        break;

      }

  }

  return success;

}



boolean CPlugin_012_send(struct EventStruct *event, int nrValues) {

  String postDataStr = F("");

  boolean success = true;

  for (int i = 0; i < nrValues && success; ++i) {

    postDataStr = F("update/V") ;

    postDataStr += event->idx + i;

    postDataStr += F("?value=");

    postDataStr += formatUserVarNoCheck(event, i);

    success = Blynk_get(postDataStr, event->ControllerIndex);

  }

  return success;

}





boolean Blynk_get(const String& command, byte controllerIndex, float *data )

{

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    return false;

  }



  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(controllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));



  WiFiClient client;

  if ((SecuritySettings.ControllerPassword[controllerIndex][0] == 0) || !ControllerSettings.connectToHost(client))

  {

    connectionFailures++;

    addLog(LOG_LEVEL_ERROR, F("Blynk : connection failed"));

    return false;

  }

  if (connectionFailures)

    connectionFailures--;





  char request[300] = {0};

  sprintf_P(request,

            PSTR("GET /%s/%s HTTP/1.1\r\n Host: %s \r\n Connection: close\r\n\r\n"),

            SecuritySettings.ControllerPassword[controllerIndex],

            command.c_str(),

            ControllerSettings.getHost().c_str());

  addLog(LOG_LEVEL_DEBUG, request);

  client.print(request);



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    yield();



  boolean success = false;

  char log[80] = {0};





  while (client.available()) {

    String line;

    safeReadStringUntil(client, line, '\n');

    addLog(LOG_LEVEL_DEBUG_MORE, line);



    if (line.substring(0, 15) == F("HTTP/1.1 200 OK")) {

      strcpy_P(log, PSTR("HTTP : Success"));

      success = true;

    }

    else if (line.substring(0, 24) == F("HTTP/1.1 400 Bad Request")) {

      strcpy_P(log, PSTR("HTTP : Unauthorized"));

    }

    else if (line.substring(0, 25) == F("HTTP/1.1 401 Unauthorized")) {

      strcpy_P(log, PSTR("HTTP : Unauthorized"));

    }

    addLog(LOG_LEVEL_DEBUG, log);





    if (data && line.startsWith("["))

    {

      String strValue = line;

      byte pos = strValue.indexOf('"',2);

      strValue = strValue.substring(2, pos);

      strValue.trim();

      float value = strValue.toFloat();

      *data = value;

      success = true;



      char value_char[5] = {0};

      strValue.toCharArray(value_char, 5);

      sprintf_P(log, PSTR("Blynk get - %s => %s"),command.c_str(), value_char );

      addLog(LOG_LEVEL_DEBUG, log);

    }

    yield();

  }

  strcpy_P(log, PSTR("HTTP : closing connection"));

  addLog(LOG_LEVEL_DEBUG, log);



  client.flush();

  client.stop();





  timer = millis() + Settings.MessageDelay;

  while (!timeOutReached(timer))

              backgroundtasks();



  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C013.ino"
#ifdef USES_C013
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C013.ino"
#define CPLUGIN_013 

#define CPLUGIN_ID_013 13

#define CPLUGIN_NAME_013 "ESPEasy P2P Networking"



WiFiUDP C013_portUDP;



struct infoStruct

{

  byte header = 255;

  byte ID = 3;

  byte sourcelUnit;

  byte destUnit;

  byte sourceTaskIndex;

  byte destTaskIndex;

  byte deviceNumber;

  char taskName[26];

  char ValueNames[VARS_PER_TASK][26];

};



struct dataStruct

{

  byte header = 255;

  byte ID = 5;

  byte sourcelUnit;

  byte destUnit;

  byte sourceTaskIndex;

  byte destTaskIndex;

  float Values[VARS_PER_TASK];

};





boolean CPlugin_013(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_013;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 65501;

        Protocol[protocolCount].usesID = false;

        Protocol[protocolCount].Custom = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_013);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = "";

        break;

      }



    case CPLUGIN_INIT:

      {



        break;

      }



    case CPLUGIN_TASK_CHANGE_NOTIFICATION:

      {

        C013_SendUDPTaskInfo(0, event->TaskIndex, event->TaskIndex);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        C013_Send(event, 0, UserVar[event->BaseVarIndex], 0);

        break;

      }



    case CPLUGIN_UDP_IN:

      {

        C013_Receive(event);

        break;

      }



  }

  return success;

}
# 201 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C013.ino"
void C013_Send(struct EventStruct *event, byte varIndex, float value, unsigned long longValue)

{

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(event->ControllerIndex, (byte*)&ControllerSettings, sizeof(ControllerSettings));

  statusLED(true);

  C013_SendUDPTaskData(0, event->TaskIndex, event->TaskIndex);

}



void C013_SendUDPTaskInfo(byte destUnit, byte sourceTaskIndex, byte destTaskIndex)

{

  if (!WiFiConnected(100)) {

    return;

  }

  struct infoStruct infoReply;

  infoReply.sourcelUnit = Settings.Unit;

  infoReply.sourceTaskIndex = sourceTaskIndex;

  infoReply.destTaskIndex = destTaskIndex;

  LoadTaskSettings(infoReply.sourceTaskIndex);

  infoReply.deviceNumber = Settings.TaskDeviceNumber[infoReply.sourceTaskIndex];

  strcpy(infoReply.taskName, ExtraTaskSettings.TaskDeviceName);

  for (byte x = 0; x < VARS_PER_TASK; x++)

    strcpy(infoReply.ValueNames[x], ExtraTaskSettings.TaskDeviceValueNames[x]);



  byte firstUnit = 1;

  byte lastUnit = UNIT_MAX - 1;

  if (destUnit != 0)

  {

    firstUnit = destUnit;

    lastUnit = destUnit;

  }

  for (byte x = firstUnit; x <= lastUnit; x++)

  {

    if (x != Settings.Unit){

      infoReply.destUnit = x;

      C013_sendUDP(x, (byte*)&infoReply, sizeof(infoStruct));

      delay(10);

    }

  }

  delay(50);

}



void C013_SendUDPTaskData(byte destUnit, byte sourceTaskIndex, byte destTaskIndex)

{

  if (!WiFiConnected(100)) {

    return;

  }

  struct dataStruct dataReply;

  dataReply.sourcelUnit = Settings.Unit;

  dataReply.sourceTaskIndex = sourceTaskIndex;

  dataReply.destTaskIndex = destTaskIndex;

  for (byte x = 0; x < VARS_PER_TASK; x++)

    dataReply.Values[x] = UserVar[dataReply.sourceTaskIndex * VARS_PER_TASK + x];



  byte firstUnit = 1;

  byte lastUnit = UNIT_MAX - 1;

  if (destUnit != 0)

  {

    firstUnit = destUnit;

    lastUnit = destUnit;

  }

  for (byte x = firstUnit; x <= lastUnit; x++)

  {

    if (x != Settings.Unit){

      dataReply.destUnit = x;

      C013_sendUDP(x, (byte*) &dataReply, sizeof(dataStruct));

      delay(10);

    }

  }

  delay(50);

}
# 349 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_C013.ino"
void C013_sendUDP(byte unit, byte* data, byte size)

{

  if (!WiFiConnected(100)) {

    return;

  }

  if (unit != 255)

    if (Nodes[unit].ip[0] == 0)

      return;

  String log = F("C013 : Send UDP message to ");

  log += unit;

  addLog(LOG_LEVEL_DEBUG_MORE, log);



  statusLED(true);



  IPAddress remoteNodeIP;

  if (unit == 255)

    remoteNodeIP = {255, 255, 255, 255};

  else

    remoteNodeIP = Nodes[unit].ip;

  C013_portUDP.beginPacket(remoteNodeIP, Settings.UDPPort);

  C013_portUDP.write(data, size);

  C013_portUDP.endPacket();

}



void C013_Receive(struct EventStruct *event) {



  if (event->Data[1] > 1 && event->Data[1] < 6)

  {

    String log = (F("C013 : msg "));

    for (byte x = 1; x < 6; x++)

    {

      log += " ";

      log += (int)event->Data[x];

    }

    addLog(LOG_LEVEL_DEBUG_MORE, log);

  }



  switch (event->Data[1]) {

    case 2:

      {



        break;

      }



    case 3:

      {

        struct infoStruct infoReply;

        memcpy((byte*)&infoReply, (byte*)event->Data, sizeof(infoStruct));







        if (Settings.TaskDeviceNumber[infoReply.destTaskIndex] == 0)

        {

          Settings.TaskDeviceNumber[infoReply.destTaskIndex] = infoReply.deviceNumber;

          Settings.TaskDeviceDataFeed[infoReply.destTaskIndex] = 1;

          for (byte x = 0; x < CONTROLLER_MAX; x++)

            Settings.TaskDeviceSendData[x][infoReply.destTaskIndex] = false;

          strcpy(ExtraTaskSettings.TaskDeviceName, infoReply.taskName);

          for (byte x = 0; x < VARS_PER_TASK; x++)

            strcpy( ExtraTaskSettings.TaskDeviceValueNames[x], infoReply.ValueNames[x]);

          SaveTaskSettings(infoReply.destTaskIndex);

          SaveSettings();

        }

        break;

      }



    case 4:

      {



        break;

      }



    case 5:

      {

        struct dataStruct dataReply;

        memcpy((byte*)&dataReply, (byte*)event->Data, sizeof(dataStruct));





        if (Settings.TaskDeviceDataFeed[dataReply.destTaskIndex] != 0)

        {

          for (byte x = 0; x < VARS_PER_TASK; x++)

          {

            UserVar[dataReply.destTaskIndex * VARS_PER_TASK + x] = dataReply.Values[x];

          }

          if (Settings.UseRules)

            createRuleEvents(dataReply.destTaskIndex);

        }

        break;

      }

  }

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_CPlugin_DomoticzHelper.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_CPlugin_DomoticzHelper.ino"
String humStatDomoticz(struct EventStruct *event, byte rel_index){

  const int hum = UserVar[event->BaseVarIndex + rel_index];

  if (hum < 30) { return formatUserVarDomoticz(2); }

  if (hum < 40) { return formatUserVarDomoticz(0); }

  if (hum < 59) { return formatUserVarDomoticz(1); }

  return formatUserVarDomoticz(3);

}



int mapRSSItoDomoticz() {

  long rssi = WiFi.RSSI();

  if (-50 < rssi) { return 10; }

  if (rssi <= -98) { return 0; }

  rssi = rssi + 97;

  return (rssi / 5) + 1;

}



int mapVccToDomoticz() {

  #if FEATURE_ADC_VCC



    if (vcc < 2.6) return 0;

    return (vcc - 2.6) * 100;

  #else

    return 255;

  #endif

}





String formatUserVarDomoticz(struct EventStruct *event, byte rel_index) {

  String text = formatUserVarNoCheck(event, rel_index);

  text += F(";");

  return text;

}



String formatUserVarDomoticz(int value) {

  String text;

  text += value;

  text.trim();

  text += F(";");

  return text;

}



String formatDomoticzSensorType(struct EventStruct *event) {

  String values;

  switch (event->sensorType)

  {

    case SENSOR_TYPE_SINGLE:

      values = formatUserVarDomoticz(event, 0);

      break;

    case SENSOR_TYPE_LONG:

      values = (unsigned long)UserVar[event->BaseVarIndex] + ((unsigned long)UserVar[event->BaseVarIndex + 1] << 16);

      break;

    case SENSOR_TYPE_DUAL:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      break;

    case SENSOR_TYPE_TEMP_HUM:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += humStatDomoticz(event, 1);

      break;

    case SENSOR_TYPE_TEMP_HUM_BARO:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += humStatDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_TEMP_BARO:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(0);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_TRIPLE:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      break;

    case SENSOR_TYPE_QUAD:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      values += formatUserVarDomoticz(event, 3);

      break;

    case SENSOR_TYPE_WIND:





      values = formatUserVarDomoticz(event, 0);

      values += getBearing(UserVar[event->BaseVarIndex]);

      values += ";";



      values += toString((UserVar[event->BaseVarIndex + 1] * 10),ExtraTaskSettings.TaskDeviceValueDecimals[1]);

      values += ";";

      values += toString((UserVar[event->BaseVarIndex + 2] * 10),ExtraTaskSettings.TaskDeviceValueDecimals[2]);

      values += ";";

      values += formatUserVarDomoticz(0);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_SWITCH:

    case SENSOR_TYPE_DIMMER:



      break;

    default:

    {

      String log = F("Domoticz Controller: Not yet implemented sensor type: ");

      log += event->sensorType;

      log += F(" idx: ");

      log += event->idx;

      addLog(LOG_LEVEL_ERROR, log);

      break;

    }

  }



  int index_last_char = values.length() -1;

  if (index_last_char > 0 && values.charAt(index_last_char) == ';') {

    values.setCharAt(index_last_char, ' ');

  }

  values.trim();

  {

    String log = F(" Domoticz: Sensortype: ");

    log += event->sensorType;

    log += F(" idx: ");

    log += event->idx;

    log += F(" values: ");

    log += values;

    addLog(LOG_LEVEL_INFO, log);

  }

  return values;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_CPlugin_SensorTypeHelper.ino"
# 9 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_CPlugin_SensorTypeHelper.ino"
byte getValueCountFromSensorType(byte sensorType)

{

  switch (sensorType)

  {

    case SENSOR_TYPE_NONE:

      return 0;

    case SENSOR_TYPE_SINGLE:

    case SENSOR_TYPE_SWITCH:

    case SENSOR_TYPE_DIMMER:

      return 1;

    case SENSOR_TYPE_LONG:

      return 1;

    case SENSOR_TYPE_TEMP_HUM:

    case SENSOR_TYPE_TEMP_BARO:

    case SENSOR_TYPE_DUAL:

      return 2;

    case SENSOR_TYPE_TEMP_HUM_BARO:

    case SENSOR_TYPE_TRIPLE:

    case SENSOR_TYPE_WIND:

      return 3;

    case SENSOR_TYPE_QUAD:

      return 4;

  }

  addLog(LOG_LEVEL_ERROR, F("getValueCountFromSensorType: Unknown sensortype"));

  return 0;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N001_Email.ino"
#ifdef USES_N001
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N001_Email.ino"
#define NPLUGIN_001 

#define NPLUGIN_ID_001 1

#define NPLUGIN_NAME_001 "Email (SMTP)"



#define NPLUGIN_001_TIMEOUT 5000



boolean NPlugin_001(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case NPLUGIN_PROTOCOL_ADD:

      {

        Notification[++notificationCount].Number = NPLUGIN_ID_001;

        Notification[notificationCount].usesMessaging = true;

        Notification[notificationCount].usesGPIO=0;

        break;

      }



    case NPLUGIN_GET_DEVICENAME:

      {

        string = F(NPLUGIN_NAME_001);

        break;

      }
# 95 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N001_Email.ino"
    case NPLUGIN_NOTIFY:

      {

        NotificationSettingsStruct NotificationSettings;

        LoadNotificationSettings(event->NotificationIndex, (byte*)&NotificationSettings, sizeof(NotificationSettings));

        String subject = NotificationSettings.Subject;

        String body = "";

        if (string.length() >0)

          body = string;

        else

          body = NotificationSettings.Body;

        subject = parseTemplate(subject, subject.length());

        body = parseTemplate(body, body.length());

        NPlugin_001_send(NotificationSettings, subject, body);

        success = true;

      }



  }

  return success;

}



boolean NPlugin_001_send(const NotificationSettingsStruct& notificationsettings, const String& aSub, String& aMesg) {



  boolean myStatus = false;





  WiFiClient client;

  String aHost = notificationsettings.Server;

  addLog(LOG_LEVEL_DEBUG, String(F("EMAIL: Connecting to "))+aHost + notificationsettings.Port);

  if (!client.connect(aHost.c_str(), notificationsettings.Port)) {

    addLog(LOG_LEVEL_ERROR, String(F("EMAIL: Error connecting to "))+aHost + notificationsettings.Port);

    myStatus = false;

  }

  else {

    String mailheader = F(

      "From: $nodename <$emailfrom>\r\n"

      "To: $ato\r\n"

      "Subject: $subject\r\n"

      "Reply-To: $nodename <$emailfrom>\r\n"

      "MIME-VERSION: 1.0\r\n"

      "Content-type: text/html; charset=UTF-8\r\n"

      "X-Mailer: EspEasy v$espeasyversion\r\n\r\n"

    );



    mailheader.replace(String(F("$nodename")), Settings.Name);

    mailheader.replace(String(F("$emailfrom")), notificationsettings.Sender);

    mailheader.replace(String(F("$ato")), notificationsettings.Receiver);

    mailheader.replace(String(F("$subject")), aSub);

    mailheader.replace(String(F("$espeasyversion")), String(BUILD));

    aMesg.replace(F("\r"), F("<br/>"));







    while (true) {



      if (!NPlugin_001_MTA(client, "", F("220 "))) break;

      if (!NPlugin_001_MTA(client, String(F("EHLO ")) + notificationsettings.Domain, F("250 "))) break;

      if (!NPlugin_001_Auth(client, notificationsettings.User, notificationsettings.Pass)) break;

      if (!NPlugin_001_MTA(client, String(F("MAIL FROM:<")) + notificationsettings.Sender + ">", F("250 "))) break;

      if (!NPlugin_001_MTA(client, String(F("RCPT TO:<")) + notificationsettings.Receiver + ">", F("250 "))) break;

      if (!NPlugin_001_MTA(client, F("DATA"), F("354 "))) break;

      if (!NPlugin_001_MTA(client, mailheader + aMesg + String(F("\r\n.\r\n")), F("250 "))) break;



      myStatus = true;

      break;



    }



    client.flush();

    client.stop();



    if (myStatus == true) {

      addLog(LOG_LEVEL_INFO, F("EMAIL: Connection Closed Successfully"));

    }

    else {

      String log = F("EMAIL: Connection Closed With Error. Used header: ");

      log += mailheader;

      addLog(LOG_LEVEL_ERROR, log);

    }

  }

  return myStatus;

}



boolean NPlugin_001_Auth(WiFiClient& client, String user, String pass) {

  if (user.length() == 0 || pass.length() == 0) {



    return true;

  }

  if (!NPlugin_001_MTA(client, String(F("AUTH LOGIN")), F("334 "))) return false;

  base64 encoder;

  String auth;

  auth = encoder.encode(user);

  if (!NPlugin_001_MTA(client, auth, F("334 "))) return false;

  auth = encoder.encode(pass);

  if (!NPlugin_001_MTA(client, auth, F("235 "))) return false;



  return true;

}



boolean NPlugin_001_MTA(WiFiClient& client, String aStr, const String &aWaitForPattern)

{

  addLog(LOG_LEVEL_DEBUG, aStr);



  if (aStr.length() ) client.println(aStr);



  yield();





  unsigned long timer = millis() + NPLUGIN_001_TIMEOUT;

  while (true) {

    if (timeOutReached(timer)) {

      String log = F("Plugin_001_MTA: timeout. ");

      log += aStr;

      addLog(LOG_LEVEL_ERROR, log);

      return false;

    }



    yield();





    String line;

    safeReadStringUntil(client, line, '\n');



    addLog(LOG_LEVEL_DEBUG, line);



    if (line.indexOf(aWaitForPattern) >= 0) {

      return true;

    }

  }



  return false;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N002_Buzzer.ino"
#ifdef USES_N002
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N002_Buzzer.ino"
#define NPLUGIN_002 

#define NPLUGIN_ID_002 2

#define NPLUGIN_NAME_002 "Buzzer"



boolean NPlugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case NPLUGIN_PROTOCOL_ADD:

      {

        Notification[++notificationCount].Number = NPLUGIN_ID_002;

        Notification[notificationCount].usesMessaging = false;

        Notification[notificationCount].usesGPIO=1;

        break;

      }



    case NPLUGIN_GET_DEVICENAME:

      {

        string = F(NPLUGIN_NAME_002);

        break;

      }
# 89 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_N002_Buzzer.ino"
    case NPLUGIN_NOTIFY:

      {

        NotificationSettingsStruct NotificationSettings;

        LoadNotificationSettings(event->NotificationIndex, (byte*)&NotificationSettings, sizeof(NotificationSettings));



        #ifndef ESP32



        tone(NotificationSettings.Pin1, 500, 500);

        #endif

        success = true;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P001_Switch.ino"
#ifdef USES_P001
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P001_Switch.ino"
#define PLUGIN_001 

#define PLUGIN_ID_001 1

#define PLUGIN_NAME_001 "Switch input - Switch"

#define PLUGIN_VALUENAME1_001 "Switch"

#if defined(ESP8266)

  Servo servo1;

  Servo servo2;

#endif

#define GPIO_MAX 17



#define PLUGIN_001_TYPE_SWITCH 0

#define PLUGIN_001_TYPE_DIMMER 3

#define PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH 0

#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW 1

#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH 2



boolean Plugin_001_read_switch_state(struct EventStruct *event) {

  return digitalRead(Settings.TaskDevicePin1[event->TaskIndex]) == HIGH;

}



boolean Plugin_001(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static boolean switchstate[TASKS_MAX];

  static boolean outputstate[TASKS_MAX];

  static int8_t PinMonitor[GPIO_MAX];

  static int8_t PinMonitorState[GPIO_MAX];



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_001;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_001);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_001));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        String options[2];

        options[0] = F("Switch");

        options[1] = F("Dimmer");

        int optionValues[2] = { PLUGIN_001_TYPE_SWITCH, PLUGIN_001_TYPE_DIMMER };

        const byte switchtype = P001_getSwitchType(event);

        addFormSelector(F("Switch Type"), F("plugin_001_type"), 2, options, optionValues, switchtype);



        if (switchtype == PLUGIN_001_TYPE_DIMMER)

        {

          char tmpString[128];

          sprintf_P(tmpString, PSTR("<TR><TD>Dim value:<TD><input type='text' name='plugin_001_dimvalue' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

          addHtml(tmpString);

        }



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String buttonOptions[3];

        buttonOptions[0] = F("Normal Switch");

        buttonOptions[1] = F("Push Button Active Low");

        buttonOptions[2] = F("Push Button Active High");

        int buttonOptionValues[3] = {PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH};

        addFormSelector(F("Switch Button Type"), F("plugin_001_button"), 3, buttonOptions, buttonOptionValues, choice);



        addFormCheckBox(F("Send Boot state"),F("plugin_001_boot"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_001_type"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == PLUGIN_001_TYPE_DIMMER)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_001_dimvalue"));

        }



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_001_button"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_001_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        for (byte x=0; x < GPIO_MAX; x++){

           PinMonitor[x] = 0;

           PinMonitorState[x] = 0;

          }



        if (Settings.TaskDevicePin1PullUp[event->TaskIndex])

          pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        else

          pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT);



        setPinState(PLUGIN_ID_001, Settings.TaskDevicePin1[event->TaskIndex], PIN_MODE_INPUT, 0);



        switchstate[event->TaskIndex] = Plugin_001_read_switch_state(event);

        outputstate[event->TaskIndex] = switchstate[event->TaskIndex];





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];

          outputstate[event->TaskIndex] = !outputstate[event->TaskIndex];

        }

        success = true;

        break;

      }



    case PLUGIN_REQUEST:

      {

        String device = parseString(string, 1);

        String command = parseString(string, 2);

        String strPar1 = parseString(string, 3);

        int par1 = strPar1.toInt();

        if (device == F("gpio") && command == F("pinstate"))

        {

          string = digitalRead(par1);

          success = true;

        }

        break;

      }



    case PLUGIN_UNCONDITIONAL_POLL:

      {



        for (byte x=0; x < GPIO_MAX; x++)

           if (PinMonitor[x] != 0){

             byte state = digitalRead(x);

             if (PinMonitorState[x] != state){

               String eventString = F("GPIO#");

               eventString += x;

               eventString += F("=");

               eventString += state;

               rulesProcessing(eventString);

               PinMonitorState[x] = state;

             }

           }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        const boolean state = Plugin_001_read_switch_state(event);

        if (state != switchstate[event->TaskIndex])

        {

          switchstate[event->TaskIndex] = state;

          const boolean currentOutputState = outputstate[event->TaskIndex];

          boolean new_outputState = currentOutputState;

          switch(Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

            case PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH:

                new_outputState = state;

              break;

            case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW:

              if (!state)

                new_outputState = !currentOutputState;

              break;

            case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH:

              if (state)

                new_outputState = !currentOutputState;

              break;

          }





          if (currentOutputState != new_outputState)

          {

            outputstate[event->TaskIndex] = new_outputState;

            boolean sendState = new_outputState;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex])

              sendState = !sendState;



            byte output_value = sendState ? 1 : 0;

            event->sensorType = SENSOR_TYPE_SWITCH;

            if (P001_getSwitchType(event) == PLUGIN_001_TYPE_DIMMER) {

              if (sendState) {

                output_value = Settings.TaskDevicePluginConfig[event->TaskIndex][1];



                event->sensorType = SENSOR_TYPE_DIMMER;

              }

            }

            UserVar[event->BaseVarIndex] = output_value;

            String log = F("SW   : Switch state ");

            log += state ? F("1") : F("0");

            log += F(" Output value ");

            log += output_value;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("SW   : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("gpio"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            if (event->Par2 == 2) {

              pinMode(event->Par1, INPUT);

              setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_INPUT, 0);

            } else {

              pinMode(event->Par1, OUTPUT);

              digitalWrite(event->Par1, event->Par2);

              setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            }

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("pwm"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            #if defined(ESP8266)

              pinMode(event->Par1, OUTPUT);

            #endif

            if(event->Par3 != 0)

            {

              byte prev_mode;

              uint16_t prev_value;

              getPinState(PLUGIN_ID_001, event->Par1, &prev_mode, &prev_value);

              if(prev_mode != PIN_MODE_PWM)

                prev_value = 0;



              int32_t step_value = ((event->Par2 - prev_value) << 12) / event->Par3;

              int32_t curr_value = prev_value << 12;



              int i = event->Par3;

              while(i--){

                curr_value += step_value;

                int16_t new_value;

                new_value = (uint16_t)(curr_value >> 12);

                #if defined(ESP8266)

                  analogWrite(event->Par1, new_value);

                #endif

                #if defined(ESP32)

                  analogWriteESP32(event->Par1, new_value);

                #endif

                delay(1);

              }

            }



            #if defined(ESP8266)

              analogWrite(event->Par1, event->Par2);

            #endif

            #if defined(ESP32)

              analogWriteESP32(event->Par1, event->Par2);

            #endif

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_PWM, event->Par2);

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Set PWM to ")) + String(event->Par2);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("pulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            pinMode(event->Par1, OUTPUT);

            digitalWrite(event->Par1, event->Par2);

            delay(event->Par3);

            digitalWrite(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if ((command == F("longpulse")) || (command == F("longpulse_ms")))

        {

          boolean time_in_msec = command == F("longpulse_ms");

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            pinMode(event->Par1, OUTPUT);

            digitalWrite(event->Par1, event->Par2);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            setSystemTimer(time_in_msec ? event->Par3 : event->Par3 * 1000,

                           PLUGIN_ID_001, event->Par1, !event->Par2, 0);

            log = String(F("SW   : GPIO ")) + String(event->Par1) +

                  String(F(" Pulse set for ")) + String(event->Par3) + String(time_in_msec ? F(" msec") : F(" sec"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("servo"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 2)

            switch (event->Par1)

            {

              case 1:





                #if defined(ESP8266)

                  servo1.attach(event->Par2);

                  servo1.write(event->Par3);

                #endif

                break;

              case 2:

                #if defined(ESP8266)

                  servo2.attach(event->Par2);

                  servo2.write(event->Par3);

                #endif

                break;

            }

          setPinState(PLUGIN_ID_001, event->Par2, PIN_MODE_SERVO, event->Par3);

          log = String(F("SW   : GPIO ")) + String(event->Par2) + String(F(" Servo set to ")) + String(event->Par3);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par2, log, 0));

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("gpio"))

          {

            success = true;

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par2, dummyString, 0));

          }

        }



        if (command == F("monitor"))

        {

          if (parseString(string, 2) == F("gpio"))

          {

            PinMonitor[event->Par2] = 1;

            success = true;

          }

        }



        if (command == F("inputswitchstate"))

        {

          success = true;

          UserVar[event->Par1 * VARS_PER_TASK] = event->Par2;

          outputstate[event->Par1] = event->Par2;

        }







        if (command == F("rtttl"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 16)

          {

            pinMode(event->Par1, OUTPUT);



            String tmpString=string;

            tmpString.replace('-', '#');



            play_rtttl(event->Par1, tmpString.c_str());

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : ")) + string;

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }





        if (command == F("tone"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            pinMode(event->Par1, OUTPUT);

            tone(event->Par1, event->Par2, event->Par3);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : ")) + string;

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        digitalWrite(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}





#if defined(ESP32)

void analogWriteESP32(int pin, int value)

{



  int8_t ledChannel = -1;

  for(byte x = 0; x < 16; x++)

    if (ledChannelPin[x] == pin)

      ledChannel = x;



  if(ledChannel == -1)

    {

      for(byte x = 0; x < 16; x++)

        if (ledChannelPin[x] == -1)

          {

            int freq = 5000;

            ledChannelPin[x] = pin;

            ledcSetup(x, freq, 10);

            ledcAttachPin(pin, x);

            ledChannel = x;

            break;

          }

    }

  ledcWrite(ledChannel, value);

}

#endif





byte P001_getSwitchType(struct EventStruct *event) {

  byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

  switch (choice) {

    case 2:

    case PLUGIN_001_TYPE_DIMMER:

      choice = PLUGIN_001_TYPE_DIMMER;

      break;

    case 1:

    case PLUGIN_001_TYPE_SWITCH:

    default:

      choice = PLUGIN_001_TYPE_SWITCH;

      break;

  }

  return choice;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P002_ADC.ino"
#ifdef USES_P002
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P002_ADC.ino"
#define PLUGIN_002 

#define PLUGIN_ID_002 2

#define PLUGIN_NAME_002 "Analog input - internal"

#define PLUGIN_VALUENAME1_002 "Analog"



uint32_t Plugin_002_OversamplingValue = 0;

uint16_t Plugin_002_OversamplingCount = 0;





boolean Plugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_002;

        Device[deviceCount].Type = DEVICE_TYPE_ANALOG;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_002);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_002));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #if defined(ESP32)

          addHtml(F("<TR><TD>Analog Pin:<TD>"));

          addPinSelect(false, "taskdevicepin1", Settings.TaskDevicePin1[event->TaskIndex]);

        #endif



        addFormCheckBox(F("Oversampling"), F("plugin_002_oversampling"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_002_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("plugin_002_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], 0, 1023);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_002_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_002_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], 0, 1023);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_002_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_002_oversampling"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_002_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_002_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_002_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_002_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_002_out2"));



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

          #if defined(ESP8266)

            Plugin_002_OversamplingValue += analogRead(A0);

          #endif

          #if defined(ESP32)

            Plugin_002_OversamplingValue += analogRead(Settings.TaskDevicePin1[event->TaskIndex]);

          #endif

          Plugin_002_OversamplingCount ++;

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("ADC  : Analog value: ");



        if (Plugin_002_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_002_OversamplingValue / Plugin_002_OversamplingCount;

          Plugin_002_OversamplingValue = 0;

          Plugin_002_OversamplingCount = 0;



          log += String(UserVar[event->BaseVarIndex], 3);

        }

        else

        {

          #if defined(ESP8266)

            int16_t value = analogRead(A0);

          #endif

          #if defined(ESP32)

            int16_t value = analogRead(Settings.TaskDevicePin1[event->TaskIndex]);

          #endif

          UserVar[event->BaseVarIndex] = (float)value;



          log += value;

        }



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" = ");

            log += String(UserVar[event->BaseVarIndex], 3);

          }

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
#ifdef USES_P003
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
#define PLUGIN_003 

#define PLUGIN_ID_003 3

#define PLUGIN_NAME_003 "Generic - Pulse counter"

#define PLUGIN_VALUENAME1_003 "Count"

#define PLUGIN_VALUENAME2_003 "Total"

#define PLUGIN_VALUENAME3_003 "Time"





void Plugin_003_pulse_interrupt1() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt2() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt3() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt4() ICACHE_RAM_ATTR;
# 47 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
unsigned long Plugin_003_pulseCounter[TASKS_MAX];

unsigned long Plugin_003_pulseTotalCounter[TASKS_MAX];

unsigned long Plugin_003_pulseTime[TASKS_MAX];

unsigned long Plugin_003_pulseTimePrevious[TASKS_MAX];



boolean Plugin_003(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_003;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_003);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_003));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_003));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_003));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Debounce Time (mSec)"), F("plugin_003")

         , Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options[4] = { F("Delta"), F("Delta/Total/Time"), F("Total"), F("Delta/Total") };

        addFormSelector(F("Counter Type"), F("plugin_003_countertype"), 4, options, NULL, choice );



        if (choice !=0)

          addHtml(F("<span style=\"color:red\">Total count is not persistent!</span>"));



        String modeRaise[4];

        modeRaise[0] = F("LOW");

        modeRaise[1] = F("CHANGE");

        modeRaise[2] = F("RISING");

        modeRaise[3] = F("FALLING");

        int modeValues[4];

        modeValues[0] = LOW;

        modeValues[1] = CHANGE;

        modeValues[2] = RISING;

        modeValues[3] = FALLING;



        addFormSelector(F("Mode Type"), F("plugin_003_raisetype"), 4, modeRaise, modeValues, choice2 );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_003"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_003_countertype"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_003_raisetype"));

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SHOW_VALUES:

      {

        string += F("<div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[0];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseCounter[event->TaskIndex];

        string += F("</div><div class=\"div_br\"></div><div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[1];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseTotalCounter[event->TaskIndex];

        string += F("</div><div class=\"div_br\"></div><div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[2];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseTime[event->TaskIndex];

        string += F("</div>");

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        String log = F("INIT : Pulse ");

        log += Settings.TaskDevicePin1[event->TaskIndex];

        addLog(LOG_LEVEL_INFO,log);

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        success = Plugin_003_pulseinit(Settings.TaskDevicePin1[event->TaskIndex], event->TaskIndex,Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

        UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

        UserVar[event->BaseVarIndex+2] = Plugin_003_pulseTime[event->TaskIndex];



        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][1])

        {

          case 0:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            break;

          }

          case 1:

          {

            event->sensorType = SENSOR_TYPE_TRIPLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+2] = Plugin_003_pulseTime[event->TaskIndex];

            break;

          }

          case 2:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            break;

          }

          case 3:

          {

            event->sensorType = SENSOR_TYPE_DUAL;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            break;

          }

        }

        Plugin_003_pulseCounter[event->TaskIndex] = 0;

        success = true;

        break;

      }

  }

  return success;

}
# 363 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
void Plugin_003_pulsecheck(byte Index)

{

  const unsigned long PulseTime=timePassedSince(Plugin_003_pulseTimePrevious[Index]);

  if(PulseTime > (unsigned long)Settings.TaskDevicePluginConfig[Index][0])

    {

      Plugin_003_pulseCounter[Index]++;

      Plugin_003_pulseTotalCounter[Index]++;

      Plugin_003_pulseTime[Index] = PulseTime;

      Plugin_003_pulseTimePrevious[Index]=millis();

    }

}
# 395 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
void Plugin_003_pulse_interrupt1()

{

  Plugin_003_pulsecheck(0);

}

void Plugin_003_pulse_interrupt2()

{

  Plugin_003_pulsecheck(1);

}

void Plugin_003_pulse_interrupt3()

{

  Plugin_003_pulsecheck(2);

}

void Plugin_003_pulse_interrupt4()

{

  Plugin_003_pulsecheck(3);

}

void Plugin_003_pulse_interrupt5()

{

  Plugin_003_pulsecheck(4);

}

void Plugin_003_pulse_interrupt6()

{

  Plugin_003_pulsecheck(5);

}

void Plugin_003_pulse_interrupt7()

{

  Plugin_003_pulsecheck(6);

}

void Plugin_003_pulse_interrupt8()

{

  Plugin_003_pulsecheck(7);

}
# 469 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
bool Plugin_003_pulseinit(byte Par1, byte Index, byte Mode)

{



  switch (Index)

  {

    case 0:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt1, Mode);

      break;

    case 1:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt2, Mode);

      break;

    case 2:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt3, Mode);

      break;

    case 3:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt4, Mode);

      break;
# 527 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P003_Pulse.ino"
    default:

      addLog(LOG_LEVEL_ERROR,F("PULSE: Error, only the first 4 tasks can be pulse counters."));

      return(false);

  }



  return(true);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
#ifdef USES_P004
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
#if defined(ESP32)

  #define ESP32noInterrupts() {portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;portENTER_CRITICAL(&mux)

  #define ESP32interrupts() portEXIT_CRITICAL(&mux);}

#endif



#define PLUGIN_004 

#define PLUGIN_ID_004 4

#define PLUGIN_NAME_004 "Environment - DS18b20"

#define PLUGIN_VALUENAME1_004 "Temperature"



int8_t Plugin_004_DallasPin;



boolean Plugin_004(byte function, struct EventStruct * event, String& string)

{

    boolean success = false;



    switch (function)

    {

        case PLUGIN_DEVICE_ADD:

        {

            Device[++deviceCount].Number = PLUGIN_ID_004;

            Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

            Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

            Device[deviceCount].Ports = 0;

            Device[deviceCount].PullUpOption = false;

            Device[deviceCount].InverseLogicOption = false;

            Device[deviceCount].FormulaOption = true;

            Device[deviceCount].ValueCount = 1;

            Device[deviceCount].SendDataOption = true;

            Device[deviceCount].TimerOption = true;

            Device[deviceCount].GlobalSyncOption = true;

            break;

        }



        case PLUGIN_GET_DEVICENAME:

        {

            string = F(PLUGIN_NAME_004);

            break;

        }



        case PLUGIN_GET_DEVICEVALUENAMES:

        {

            strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_004));

            break;

        }



        case PLUGIN_WEBFORM_LOAD:

        {

            uint8_t savedAddress[8];

            byte resolutionChoice = 0;



            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_004_DallasPin != -1){



              for (byte i = 0; i < 8; i++)

                  savedAddress[i] = ExtraTaskSettings.TaskDevicePluginConfigLong[i];





              addRowLabel(F("Device Address"));

              addSelector_Head(F("plugin_004_dev"), false);

              addSelector_Item("", -1, false, false, F(""));

              uint8_t tmpAddress[8];

              byte count = 0;

              Plugin_004_DS_reset();

              Plugin_004_DS_reset_search();

              while (Plugin_004_DS_search(tmpAddress))

              {

                  String option = "";

                  for (byte j = 0; j < 8; j++)

                  {

                      option += String(tmpAddress[j], HEX);

                      if (j < 7) option += F("-");

                  }

                  bool selected = (memcmp(tmpAddress, savedAddress, 8) == 0) ? true : false;

                  addSelector_Item(option, count, selected, false, F(""));

                  count ++;

              }

              addSelector_Foot();





              if (ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0)

                  resolutionChoice = Plugin_004_DS_getResolution(savedAddress);

              else

                  resolutionChoice = 9;

              String resultsOptions[4] = { "9", "10", "11", "12" };

              int resultsOptionValues[4] = { 9, 10, 11, 12 };

              addFormSelector(F("Device Resolution"), F("plugin_004_res"), 4, resultsOptions, resultsOptionValues, resolutionChoice);

              addHtml(F(" Bit"));

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SAVE:

        {

            uint8_t addr[8] = {0,0,0,0,0,0,0,0};





            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_004_DallasPin != -1){

              Plugin_004_DS_scan(getFormItemInt(F("plugin_004_dev")), addr);

              for (byte x = 0; x < 8; x++)

                  ExtraTaskSettings.TaskDevicePluginConfigLong[x] = addr[x];



              Plugin_004_DS_setResolution(addr, getFormItemInt(F("plugin_004_res")));

              Plugin_004_DS_startConvertion(addr);

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SHOW_CONFIG:

        {

            for (byte x = 0; x < 8; x++)

            {

                if (x != 0)

                    string += "-";



            }

            success = true;

            break;

        }

        case PLUGIN_INIT:

        {

            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

            if (Plugin_004_DallasPin != -1){

              uint8_t addr[8];

              Plugin_004_get_addr(addr, event->TaskIndex);

              Plugin_004_DS_startConvertion(addr);

              delay(800);

            }

            success = true;

            break;

        }



        case PLUGIN_READ:

        {

            if (ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0){

                uint8_t addr[8];

                Plugin_004_get_addr(addr, event->TaskIndex);



                Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

                float value = 0;

                String log = F("DS   : Temperature: ");



                if (Plugin_004_DS_readTemp(addr, &value))

                {

                    UserVar[event->BaseVarIndex] = value;

                    log += UserVar[event->BaseVarIndex];

                    success = true;

                }

                else

                {

                    UserVar[event->BaseVarIndex] = NAN;

                    log += F("Error!");

                }

                Plugin_004_DS_startConvertion(addr);



                log += (" (");

                for (byte x = 0; x < 8; x++)

                {

                    if (x != 0)

                        log += "-";

                    log += String(ExtraTaskSettings.TaskDevicePluginConfigLong[x], HEX);

                }



                log += ')';

                addLog(LOG_LEVEL_INFO, log);

            }

            break;

        }

    }

    return success;

}



void Plugin_004_get_addr(uint8_t addr[], byte TaskIndex)

{



  LoadTaskSettings(TaskIndex);

  for (byte x = 0; x < 8; x++)

      addr[x] = ExtraTaskSettings.TaskDevicePluginConfigLong[x];

}
# 393 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
byte Plugin_004_DS_scan(byte getDeviceROM, uint8_t* ROM)

{

    byte tmpaddr[8];

    byte devCount = 0;

    Plugin_004_DS_reset();



    Plugin_004_DS_reset_search();

    while (Plugin_004_DS_search(tmpaddr))

    {

        if (getDeviceROM == devCount)

            for (byte i = 0; i < 8; i++)

                ROM[i] = tmpaddr[i];

        devCount++;

    }

    return devCount;

}
# 441 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
void Plugin_004_DS_startConvertion(uint8_t ROM[8])

{

    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);

    Plugin_004_DS_write(0x44);

}
# 465 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
boolean Plugin_004_DS_readTemp(uint8_t ROM[8], float * value)

{

    int16_t DSTemp;

    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

    {

        *value = 0;

        return false;

    }



    if ((ROM[0] == 0x28 ) || (ROM[0] == 0x3b) || (ROM[0] == 0x22))

    {

        DSTemp = (ScratchPad[1] << 8) + ScratchPad[0];

        if (DSTemp == 0x550)

           return false;

        *value = (float(DSTemp) * 0.0625);

    }

    else if (ROM[0] == 0x10)

    {

        if (ScratchPad[0] == 0xaa)

          return false;

        DSTemp = (ScratchPad[1] << 11) | ScratchPad[0] << 3;

        DSTemp = ((DSTemp & 0xfff0) << 3) - 16 +

                 (((ScratchPad[7] - ScratchPad[6]) << 7) / ScratchPad[7]);

        *value = float(DSTemp) * 0.0078125;

    }

    return true;

}
# 551 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
int Plugin_004_DS_getResolution(uint8_t ROM[8])

{



    if (ROM[0] == 0x10) return 12;



    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

        return 0;

    else

    {

        switch (ScratchPad[4])

        {

            case 0x7F:

                return 12;



            case 0x5F:

                return 11;



            case 0x3F:

                return 10;



            case 0x1F:

            default:

                return 9;

        }

    }

    return(0);

}
# 637 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
boolean Plugin_004_DS_setResolution(uint8_t ROM[8], byte res)

{



    if (ROM[0] == 0x10) return true;



    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

        return false;

    else

    {

        switch (res)

        {

            case 12:

                ScratchPad[4] = 0x7F;

                break;

            case 11:

                ScratchPad[4] = 0x5F;

                break;

            case 10:

                ScratchPad[4] = 0x3F;

                break;

            case 9:

            default:

                ScratchPad[4] = 0x1F;

                break;

        }



        Plugin_004_DS_reset();

        Plugin_004_DS_write(0x55);

        for (byte i = 0; i < 8; i++)

            Plugin_004_DS_write(ROM[i]);



        Plugin_004_DS_write(0x4E);

        Plugin_004_DS_write(ScratchPad[2]);

        Plugin_004_DS_write(ScratchPad[3]);

        Plugin_004_DS_write(ScratchPad[4]);



        Plugin_004_DS_write(0x55);

        for (byte i = 0; i < 8; i++)

            Plugin_004_DS_write(ROM[i]);





        Plugin_004_DS_write(0x48);

        delay(100);

        Plugin_004_DS_reset();



        return true;

    }

}
# 765 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_reset()

{

    uint8_t r;

    uint8_t retries = 125;

    #if defined(ESP32)

      ESP32noInterrupts();

    #endif

    pinMode(Plugin_004_DallasPin, INPUT);

    do

    {

        if (--retries == 0)

            return 0;

        delayMicroseconds(2);

    }

    while (!digitalRead(Plugin_004_DallasPin));



    pinMode(Plugin_004_DallasPin, OUTPUT); digitalWrite(Plugin_004_DallasPin, LOW);

    delayMicroseconds(492);

    pinMode(Plugin_004_DallasPin, INPUT);

    delayMicroseconds(40);

    r = !digitalRead(Plugin_004_DallasPin);

    delayMicroseconds(420);

    #if defined(ESP32)

      ESP32interrupts();

    #endif

    return r;

}



#define FALSE 0

#define TRUE 1



unsigned char ROM_NO[8];

uint8_t LastDiscrepancy;

uint8_t LastFamilyDiscrepancy;

uint8_t LastDeviceFlag;
# 845 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
void Plugin_004_DS_reset_search()

{



    LastDiscrepancy = 0;

    LastDeviceFlag = FALSE;

    LastFamilyDiscrepancy = 0;

    for (byte i = 0; i < 8; i++)

        ROM_NO[i] = 0;

}
# 873 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_search(uint8_t * newAddr)

{

    uint8_t id_bit_number;

    uint8_t last_zero, rom_byte_number, search_result;

    uint8_t id_bit, cmp_id_bit;

    unsigned char rom_byte_mask, search_direction;





    id_bit_number = 1;

    last_zero = 0;

    rom_byte_number = 0;

    rom_byte_mask = 1;

    search_result = 0;





    if (!LastDeviceFlag)

    {



        if (!Plugin_004_DS_reset())

        {



            LastDiscrepancy = 0;

            LastDeviceFlag = FALSE;

            LastFamilyDiscrepancy = 0;

            return FALSE;

        }





        Plugin_004_DS_write(0xF0);





        do

        {



            id_bit = Plugin_004_DS_read_bit();

            cmp_id_bit = Plugin_004_DS_read_bit();





            if ((id_bit == 1) && (cmp_id_bit == 1))

                break;

            else

            {



                if (id_bit != cmp_id_bit)

                    search_direction = id_bit;

                else

                {





                    if (id_bit_number < LastDiscrepancy)

                        search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);

                    else



                        search_direction = (id_bit_number == LastDiscrepancy);





                    if (search_direction == 0)

                    {

                        last_zero = id_bit_number;





                        if (last_zero < 9)

                            LastFamilyDiscrepancy = last_zero;

                    }

                }







                if (search_direction == 1)

                    ROM_NO[rom_byte_number] |= rom_byte_mask;

                else

                    ROM_NO[rom_byte_number] &= ~rom_byte_mask;





                Plugin_004_DS_write_bit(search_direction);







                id_bit_number++;

                rom_byte_mask <<= 1;





                if (rom_byte_mask == 0)

                {

                    rom_byte_number++;

                    rom_byte_mask = 1;

                }

            }

        }

        while (rom_byte_number < 8);





        if (!(id_bit_number < 65))

        {



            LastDiscrepancy = last_zero;





            if (LastDiscrepancy == 0)

                LastDeviceFlag = TRUE;



            search_result = TRUE;

        }

    }





    if (!search_result || !ROM_NO[0])

    {

        LastDiscrepancy = 0;

        LastDeviceFlag = FALSE;

        LastFamilyDiscrepancy = 0;

        search_result = FALSE;

    }



    for (int i = 0; i < 8; i++)

        newAddr[i] = ROM_NO[i];



    return search_result;

}
# 1119 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_read(void)

{

    uint8_t bitMask;

    uint8_t r = 0;



    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        if (Plugin_004_DS_read_bit())

            r |= bitMask;



    return r;

}
# 1149 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
void Plugin_004_DS_write(uint8_t ByteToWrite)

{

    uint8_t bitMask;

    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        Plugin_004_DS_write_bit( (bitMask & ByteToWrite) ? 1 : 0);

}
# 1169 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_read_bit(void)

{

    uint8_t r;



    #if defined(ESP32)

       ESP32noInterrupts();

    #endif

    pinMode(Plugin_004_DallasPin, OUTPUT);

    digitalWrite(Plugin_004_DallasPin, LOW);

    delayMicroseconds(3);

    pinMode(Plugin_004_DallasPin, INPUT);

    delayMicroseconds(10);

    r = digitalRead(Plugin_004_DallasPin);

    #if defined(ESP32)

       ESP32interrupts();

    #endif

    delayMicroseconds(53);

    return r;

}
# 1215 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
void Plugin_004_DS_write_bit(uint8_t v)

{

    if (v & 1)

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_004_DallasPin, LOW);

        pinMode(Plugin_004_DallasPin, OUTPUT);

        delayMicroseconds(10);

        digitalWrite(Plugin_004_DallasPin, HIGH);

        #if defined(ESP32)

          ESP32interrupts();

        #endif

        delayMicroseconds(55);

    }

    else

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_004_DallasPin, LOW);

        pinMode(Plugin_004_DallasPin, OUTPUT);

        delayMicroseconds(65);

        digitalWrite(Plugin_004_DallasPin, HIGH);

        #if defined(ESP32)

           ESP32interrupts();

        #endif

        delayMicroseconds(5);

    }

}
# 1285 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P004_Dallas.ino"
boolean Plugin_004_DS_crc8(uint8_t * addr)

{

  uint8_t crc = 0;

  uint8_t len = 8;



    while (len--)

    {

        uint8_t inbyte = *addr++;

        for (uint8_t i = 8; i; i--)

        {

            uint8_t mix = (crc ^ inbyte) & 0x01;

            crc >>= 1;

            if (mix) crc ^= 0x8C;

            inbyte >>= 1;

        }

    }

    return crc == *addr;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P005_DHT.ino"
#ifdef USES_P005
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P005_DHT.ino"
#define PLUGIN_005 

#define PLUGIN_ID_005 5

#define PLUGIN_NAME_005 "Environment - DHT11/12/22  SONOFF2301/7021"

#define PLUGIN_VALUENAME1_005 "Temperature"

#define PLUGIN_VALUENAME2_005 "Humidity"



uint8_t Plugin_005_DHT_Pin;



boolean Plugin_005(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_005;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_005);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_005));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_005));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const String options[] = { F("DHT 11"), F("DHT 22"), F("DHT 12"), F("Sonoff am2301"), F("Sonoff si7021") };

        int indices[] = { 11, 22, 12, 23, 70 };



        addFormSelector(F("DHT Type"), F("plugin_005_dhttype"), 5, options, indices, Settings.TaskDevicePluginConfig[event->TaskIndex][0] );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_005_dhttype"));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        byte dht_dat[5];

        byte i;

        boolean error = false;



        byte Par3 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_005_DHT_Pin = Settings.TaskDevicePin1[event->TaskIndex];



        pinMode(Plugin_005_DHT_Pin, OUTPUT);

        digitalWrite(Plugin_005_DHT_Pin, LOW);

        if(Par3 == 11 || Par3 == 22 || Par3 == 12) delay(18);

        else if (Par3 == 23 ) delayMicroseconds(900);

        else if (Par3 == 70 ) delayMicroseconds(500);

        pinMode(Plugin_005_DHT_Pin, INPUT);

        delayMicroseconds(50);



        error = waitState(0);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        error = waitState(1);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        noInterrupts();

        error = waitState(0);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        for (i = 0; i < 5; i++)

        {

            byte data = Plugin_005_read_dht_dat();

            if(data == -1)

            { logError(event, F("DHT  : protocol timeout!"));

                break;

            }

            dht_dat[i] = data;

        }

        interrupts();





        byte dht_check_sum = (dht_dat[0] + dht_dat[1] + dht_dat[2] + dht_dat[3]) & 0xFF;

        if (dht_dat[4] != dht_check_sum)

        {

            logError(event, F("DHT  : checksum error!"));

            break;

        }



        float temperature = NAN;

        float humidity = NAN;

        if (Par3 == 11)

        {

          temperature = float(dht_dat[2]);

          humidity = float(dht_dat[0]);

        }

        else if (Par3 == 12)

        {

            temperature = float(dht_dat[2]*10 + (dht_dat[3] & 0x7f)) / 10.0;

            if (dht_dat[3] & 0x80) { temperature = -temperature; }

            humidity = float(dht_dat[0]*10+dht_dat[1]) / 10.0;

        }

        else if (Par3 == 22 || Par3 == 23 || Par3 == 70)

        {

          if (dht_dat[2] & 0x80)

            temperature = -0.1 * word(dht_dat[2] & 0x7F, dht_dat[3]);

          else

            temperature = 0.1 * word(dht_dat[2], dht_dat[3]);

          humidity = 0.1 * word(dht_dat[0], dht_dat[1]);

        }



        if (temperature == NAN || humidity == NAN)

        { logError(event, F("DHT  : invalid NAN reading !"));

              break;

        }



        UserVar[event->BaseVarIndex] = temperature;

        UserVar[event->BaseVarIndex + 1] = humidity;

        String log = F("DHT  : Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        log = F("DHT  : Humidity: ");

        log += UserVar[event->BaseVarIndex + 1];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}
# 331 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P005_DHT.ino"
void logError(struct EventStruct *event, String text)

{

  addLog(LOG_LEVEL_INFO, text);

  UserVar[event->BaseVarIndex] = NAN;

  UserVar[event->BaseVarIndex + 1] = NAN;

}
# 351 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P005_DHT.ino"
boolean waitState(int state)

{

  byte counter = 0;

  while (( digitalRead(Plugin_005_DHT_Pin) != state) && (counter < 100))

  {

    delayMicroseconds(1);

    counter++;

  }

  if( counter < 100) return false;

  return true;

}
# 381 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P005_DHT.ino"
int Plugin_005_read_dht_dat(void)

{

  byte i = 0;

  byte result = 0;

  byte counter = 0;

  for (i = 0; i < 8; i++)

  {

    while ((!digitalRead(Plugin_005_DHT_Pin)) && (counter < 100))

    {

      delayMicroseconds(1);

      counter++;

    }

    if (counter >= 100)

    {

      return -1;

    }

    delayMicroseconds(35);

    if (digitalRead(Plugin_005_DHT_Pin))

      result |= (1 << (7 - i));

    counter = 0;

    while ((digitalRead(Plugin_005_DHT_Pin)) && (counter < 100))

    {

      delayMicroseconds(1);

      counter++;

    }

    if (counter >= 100)

    {

      return -1;

    }

  }

  return result;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P006_BMP085.ino"
#ifdef USES_P006
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P006_BMP085.ino"
#define PLUGIN_006 

#define PLUGIN_ID_006 6

#define PLUGIN_NAME_006 "Environment - BMP085/180"

#define PLUGIN_VALUENAME1_006 "Temperature"

#define PLUGIN_VALUENAME2_006 "Pressure"







boolean Plugin_006_init = false;



boolean Plugin_006(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_006;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_006);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_006));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_006));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Altitude [m]"), F("_p006_bmp085_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("_p006_bmp085_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_006_init)

        {

          if (Plugin_006_bmp085_begin())

            Plugin_006_init = true;

        }



        if (Plugin_006_init)

        {

          UserVar[event->BaseVarIndex] = Plugin_006_bmp085_readTemperature();

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_006_pressureElevation((float)Plugin_006_bmp085_readPressure() / 100, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ((float)Plugin_006_bmp085_readPressure()) / 100;

          }

          String log = F("BMP  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}



#define BMP085_I2CADDR 0x77

#define BMP085_ULTRAHIGHRES 3

#define BMP085_CAL_AC1 0xAA

#define BMP085_CAL_AC2 0xAC

#define BMP085_CAL_AC3 0xAE

#define BMP085_CAL_AC4 0xB0

#define BMP085_CAL_AC5 0xB2

#define BMP085_CAL_AC6 0xB4

#define BMP085_CAL_B1 0xB6

#define BMP085_CAL_B2 0xB8

#define BMP085_CAL_MB 0xBA

#define BMP085_CAL_MC 0xBC

#define BMP085_CAL_MD 0xBE

#define BMP085_CONTROL 0xF4

#define BMP085_TEMPDATA 0xF6

#define BMP085_PRESSUREDATA 0xF6

#define BMP085_READTEMPCMD 0x2E

#define BMP085_READPRESSURECMD 0x34



uint8_t oversampling = BMP085_ULTRAHIGHRES;

int16_t ac1, ac2, ac3, b1, b2, mb, mc, md;

uint16_t ac4, ac5, ac6;





boolean Plugin_006_bmp085_begin()



{

  if (Plugin_006_bmp085_read8(0xD0) != 0x55) return false;





  ac1 = Plugin_006_bmp085_read16(BMP085_CAL_AC1);

  ac2 = Plugin_006_bmp085_read16(BMP085_CAL_AC2);

  ac3 = Plugin_006_bmp085_read16(BMP085_CAL_AC3);

  ac4 = Plugin_006_bmp085_read16(BMP085_CAL_AC4);

  ac5 = Plugin_006_bmp085_read16(BMP085_CAL_AC5);

  ac6 = Plugin_006_bmp085_read16(BMP085_CAL_AC6);



  b1 = Plugin_006_bmp085_read16(BMP085_CAL_B1);

  b2 = Plugin_006_bmp085_read16(BMP085_CAL_B2);



  mb = Plugin_006_bmp085_read16(BMP085_CAL_MB);

  mc = Plugin_006_bmp085_read16(BMP085_CAL_MC);

  md = Plugin_006_bmp085_read16(BMP085_CAL_MD);



  return(true);

}





uint16_t Plugin_006_bmp085_readRawTemperature(void)



{

  Plugin_006_bmp085_write8(BMP085_CONTROL, BMP085_READTEMPCMD);

  delay(5);

  return Plugin_006_bmp085_read16(BMP085_TEMPDATA);

}





uint32_t Plugin_006_bmp085_readRawPressure(void)



{

  uint32_t raw;



  Plugin_006_bmp085_write8(BMP085_CONTROL, BMP085_READPRESSURECMD + (oversampling << 6));



  delay(26);



  raw = Plugin_006_bmp085_read16(BMP085_PRESSUREDATA);

  raw <<= 8;

  raw |= Plugin_006_bmp085_read8(BMP085_PRESSUREDATA + 2);

  raw >>= (8 - oversampling);



  return raw;

}





int32_t Plugin_006_bmp085_readPressure(void)



{

  int32_t UT, UP, B3, B5, B6, X1, X2, X3, p;

  uint32_t B4, B7;



  UT = Plugin_006_bmp085_readRawTemperature();

  UP = Plugin_006_bmp085_readRawPressure();





  X1 = (UT - (int32_t)(ac6)) * ((int32_t)(ac5)) / pow(2, 15);

  X2 = ((int32_t)mc * pow(2, 11)) / (X1 + (int32_t)md);

  B5 = X1 + X2;





  B6 = B5 - 4000;

  X1 = ((int32_t)b2 * ( (B6 * B6) >> 12 )) >> 11;

  X2 = ((int32_t)ac2 * B6) >> 11;

  X3 = X1 + X2;

  B3 = ((((int32_t)ac1 * 4 + X3) << oversampling) + 2) / 4;



  X1 = ((int32_t)ac3 * B6) >> 13;

  X2 = ((int32_t)b1 * ((B6 * B6) >> 12)) >> 16;

  X3 = ((X1 + X2) + 2) >> 2;

  B4 = ((uint32_t)ac4 * (uint32_t)(X3 + 32768)) >> 15;

  B7 = ((uint32_t)UP - B3) * (uint32_t)( 50000UL >> oversampling );



  if (B7 < 0x80000000)

  {

    p = (B7 * 2) / B4;

  }

  else

  {

    p = (B7 / B4) * 2;

  }

  X1 = (p >> 8) * (p >> 8);

  X1 = (X1 * 3038) >> 16;

  X2 = (-7357 * p) >> 16;



  p = p + ((X1 + X2 + (int32_t)3791) >> 4);

  return p;

}





float Plugin_006_bmp085_readTemperature(void)



{

  int32_t UT, X1, X2, B5;

  float temp;



  UT = Plugin_006_bmp085_readRawTemperature();





  X1 = (UT - (int32_t)ac6) * ((int32_t)ac5) / pow(2, 15);

  X2 = ((int32_t)mc * pow(2, 11)) / (X1 + (int32_t)md);

  B5 = X1 + X2;

  temp = (B5 + 8) / pow(2, 4);

  temp /= 10;



  return temp;

}





uint8_t Plugin_006_bmp085_read8(uint8_t a)



{

  uint8_t ret;



  Wire.beginTransmission(BMP085_I2CADDR);

  Wire.write(a);

  Wire.endTransmission();



  Wire.beginTransmission(BMP085_I2CADDR);

  Wire.requestFrom(BMP085_I2CADDR, 1);

  ret = Wire.read();

  Wire.endTransmission();



  return ret;

}





uint16_t Plugin_006_bmp085_read16(uint8_t a)



{

  uint16_t ret;



  Wire.beginTransmission(BMP085_I2CADDR);

  Wire.write(a);

  Wire.endTransmission();



  Wire.beginTransmission(BMP085_I2CADDR);

  Wire.requestFrom(BMP085_I2CADDR, 2);

  ret = Wire.read();

  ret <<= 8;

  ret |= Wire.read();

  Wire.endTransmission();



  return ret;

}





boolean Plugin_006_bmp085_write8(uint8_t a, uint8_t d)



{

  Wire.beginTransmission(BMP085_I2CADDR);

  Wire.write(a);

  Wire.write(d);

  if(Wire.endTransmission() != 0)

    return false;



  return true;

}





float Plugin_006_pressureElevation(float atmospheric, int altitude) {



  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P007_PCF8591.ino"
#ifdef USES_P007
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P007_PCF8591.ino"
#define PLUGIN_007 

#define PLUGIN_ID_007 7

#define PLUGIN_NAME_007 "Analog input - PCF8591"

#define PLUGIN_VALUENAME1_007 "Analog"



boolean Plugin_007(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;







  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_007;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 4;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_007);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_007));

        break;

      }



    case PLUGIN_READ:

      {

        byte unit = (Settings.TaskDevicePort[event->TaskIndex] - 1) / 4;

        byte port = Settings.TaskDevicePort[event->TaskIndex] - (unit * 4);

        uint8_t address = 0x48 + unit;





        Wire.beginTransmission(address);

        Wire.write(port - 1);

        Wire.endTransmission();



        Wire.requestFrom(address, (uint8_t)0x2);

        if (Wire.available())

        {

          Wire.read();

          UserVar[event->BaseVarIndex] = (float)Wire.read();

          String log = F("PCF  : Analog value: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO,log);

          success = true;

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P008_RFID.ino"
#ifdef USES_P008
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P008_RFID.ino"
#define PLUGIN_008 

#define PLUGIN_ID_008 8

#define PLUGIN_NAME_008 "RFID - Wiegand"

#define PLUGIN_VALUENAME1_008 "Tag"



void Plugin_008_interrupt1() ICACHE_RAM_ATTR;

void Plugin_008_interrupt2() ICACHE_RAM_ATTR;



volatile byte Plugin_008_bitCount = 0;

uint64_t Plugin_008_keyBuffer = 0;

byte Plugin_008_timeoutCount = 0;

byte Plugin_008_WiegandSize = 26;



boolean Plugin_008_init = false;



boolean Plugin_008(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_008;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_008);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_008));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_008_init = true;

        Plugin_008_WiegandSize = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        pinMode(Settings.TaskDevicePin2[event->TaskIndex], INPUT_PULLUP);

        attachInterrupt(Settings.TaskDevicePin1[event->TaskIndex], Plugin_008_interrupt1, FALLING);

        attachInterrupt(Settings.TaskDevicePin2[event->TaskIndex], Plugin_008_interrupt2, FALLING);

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if (Plugin_008_init)

        {

          if (Plugin_008_bitCount > 0)

          {

            if (Plugin_008_bitCount % 4 == 0 && ((Plugin_008_keyBuffer & 0xF) == 11))

            {



              Plugin_008_keyBuffer = Plugin_008_keyBuffer >> 4;

              UserVar[event->BaseVarIndex] = (Plugin_008_keyBuffer & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((Plugin_008_keyBuffer >> 16) & 0xFFFF);

            }

            else if (Plugin_008_bitCount == Plugin_008_WiegandSize)

            {



              Plugin_008_keyBuffer = Plugin_008_keyBuffer >> 1;

              if (Plugin_008_WiegandSize == 26)

                Plugin_008_keyBuffer &= 0xFFFFFF;

              else

                Plugin_008_keyBuffer &= 0xFFFFFFFF;

              UserVar[event->BaseVarIndex] = (Plugin_008_keyBuffer & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((Plugin_008_keyBuffer >> 16) & 0xFFFF);

            }

            else

            {



              Plugin_008_timeoutCount++;

              if (Plugin_008_timeoutCount > 5)

              {

                String log = F("RFID : reset bits: ");

                log += Plugin_008_bitCount;

                addLog(LOG_LEVEL_INFO, log );



                Plugin_008_keyBuffer = 0;

                Plugin_008_bitCount = 0;

                Plugin_008_timeoutCount = 0;

              }

              break;

            }



            unsigned long bitCount = Plugin_008_bitCount;

            unsigned long keyBuffer = Plugin_008_keyBuffer;

            Plugin_008_keyBuffer = 0;

            Plugin_008_bitCount = 0;

            Plugin_008_timeoutCount = 0;



            String log = F("RFID : Tag: ");

            log += keyBuffer;

            log += F(" Bits: ");

            log += bitCount;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        break;

      }

      case PLUGIN_WEBFORM_LOAD:

        {

          byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          String options[2];

          options[0] = F("26 Bits");

          options[1] = F("34 Bits");

          int optionValues[2];

          optionValues[0] = 26;

          optionValues[1] = 34;

          string += F("<TR><TD>Wiegand Type:<TD><select name='plugin_008_type'>");

          for (byte x = 0; x < 2; x++)

          {

            string += F("<option value='");

            string += optionValues[x];

            string += "'";

            if (choice == optionValues[x])

              string += F(" selected");

            string += ">";

            string += options[x];

            string += F("</option>");

          }

          string += F("</select>");



          success = true;

          break;

        }



      case PLUGIN_WEBFORM_SAVE:

        {

          String plugin1 = WebServer.arg(F("plugin_008_type"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = plugin1.toInt();

          success = true;

          break;

        }

  }

  return success;

}





void Plugin_008_interrupt1()



{



  Plugin_008_keyBuffer = Plugin_008_keyBuffer << 1;

  Plugin_008_keyBuffer += 1;

  Plugin_008_bitCount++;

}





void Plugin_008_interrupt2()



{



  Plugin_008_keyBuffer = Plugin_008_keyBuffer << 1;

  Plugin_008_bitCount++;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P009_MCP.ino"
#ifdef USES_P009
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P009_MCP.ino"
#define PLUGIN_009 

#define PLUGIN_ID_009 9

#define PLUGIN_NAME_009 "Switch input - MCP23017"

#define PLUGIN_VALUENAME1_009 "Switch"



boolean Plugin_009(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_009;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 16;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_009);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_009));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("Send Boot state") ,F("plugin_009_boot"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_009_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {



        Plugin_009_Config(Settings.TaskDevicePort[event->TaskIndex], 1);





        switchstate[event->TaskIndex] = Plugin_009_Read(Settings.TaskDevicePort[event->TaskIndex]);





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];



        setPinState(PLUGIN_ID_009, Settings.TaskDevicePort[event->TaskIndex], PIN_MODE_INPUT, 0);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        int state = Plugin_009_Read(Settings.TaskDevicePort[event->TaskIndex]);

        if (state != -1)

        {

          if (state != switchstate[event->TaskIndex])

          {

            String log = F("MCP  : State ");

            log += state;

            addLog(LOG_LEVEL_INFO, log);

            switchstate[event->TaskIndex] = state;

            UserVar[event->BaseVarIndex] = state;

            event->sensorType = SENSOR_TYPE_SWITCH;

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("MCP   : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("mcpgpio"))

        {

          success = true;

          Plugin_009_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

        }



        if (command == F("mcppulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 128)

          {

            Plugin_009_Write(event->Par1, event->Par2);

            delay(event->Par3);

            Plugin_009_Write(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

          }

        }



        if (command == F("mcplongpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 128)

          {

            Plugin_009_Write(event->Par1, event->Par2);

            setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            setSystemTimer(event->Par3 * 1000, PLUGIN_ID_009, event->Par1, !event->Par2, 0);

            log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

          }

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("mcp"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_009, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par2, dummyString, 0);

            else

            {

              int state = Plugin_009_Read(event->Par2);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_009_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 381 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P009_MCP.ino"
int Plugin_009_Read(byte Par1)

{

  int8_t state = -1;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankValueReg = 0x12;

  if (port > 8)

  {

    port = port - 8;

    IOBankValueReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankValueReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    state = ((Wire.read() & _BV(port - 1)) >> (port - 1));

  }

  return state;

}
# 437 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P009_MCP.ino"
boolean Plugin_009_Write(byte Par1, byte Par2)

{

  boolean success = false;

  byte portvalue = 0;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankConfigReg = 0;

  byte IOBankValueReg = 0x12;

  if (port > 8)

  {

    port = port - 8;

    IOBankConfigReg++;

    IOBankValueReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankConfigReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankConfigReg);

    Wire.write(portvalue);

    Wire.endTransmission();

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankValueReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    if (Par2 == 1)

      portvalue |= (1 << (port - 1));

    else

      portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankValueReg);

    Wire.write(portvalue);

    Wire.endTransmission();

    success = true;

  }

  return(success);

}
# 553 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P009_MCP.ino"
void Plugin_009_Config(byte Par1, byte Par2)

{



  byte portvalue = 0;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankConfigReg = 0xC;

  if (port > 8)

  {

    port = port - 8;

    IOBankConfigReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankConfigReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    if (Par2 == 1)

      portvalue |= (1 << (port - 1));

    else

      portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankConfigReg);

    Wire.write(portvalue);

    Wire.endTransmission();

  }

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P010_BH1750.ino"
#ifdef USES_P010
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P010_BH1750.ino"
#include <AS_BH1750.h>



#define PLUGIN_010 

#define PLUGIN_ID_010 10

#define PLUGIN_NAME_010 "Light/Lux - BH1750"

#define PLUGIN_VALUENAME1_010 "Lux"





boolean Plugin_010(byte function, struct EventStruct *event, String& string)

  {

  boolean success=false;



  switch(function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_010;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_010);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_010));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 113 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P010_BH1750.ino"
        int optionValues[2];

        optionValues[0] = BH1750_DEFAULT_I2CADDR;

        optionValues[1] = BH1750_SECOND_I2CADDR;

        addFormSelectorI2C(F("plugin_010"), 2, optionValues, choice);

        addFormNote(F("ADDR Low=0x23, High=0x5c"));



        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String optionsMode[4];

        optionsMode[0] = F("RESOLUTION_LOW");

        optionsMode[1] = F("RESOLUTION_NORMAL");

        optionsMode[2] = F("RESOLUTION_HIGH");

        optionsMode[3] = F("RESOLUTION_AUTO_HIGH");

        int optionValuesMode[4];

        optionValuesMode[0] = RESOLUTION_LOW;

        optionValuesMode[1] = RESOLUTION_NORMAL;

        optionValuesMode[2] = RESOLUTION_HIGH;

        optionValuesMode[3] = RESOLUTION_AUTO_HIGH;

        addFormSelector(F("Measurement mode"), F("plugin_010_mode"), 4, optionsMode, optionValuesMode, choiceMode);



        addFormCheckBox(F("Send sensor to sleep"), F("plugin_010_sleep"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_010"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_010_mode"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_010_sleep"));

        success = true;

        break;

      }



  case PLUGIN_READ:

    {

     uint8_t address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];





      AS_BH1750 sensor = AS_BH1750(address);

      sensors_resolution_t mode;



      mode = (sensors_resolution_t)Settings.TaskDevicePluginConfig[event->TaskIndex][1];
# 217 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P010_BH1750.ino"
      sensor.begin(mode,Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



      float lux = sensor.readLightLevel();

      if (lux != -1) {

       UserVar[event->BaseVarIndex] = lux;

     String log = F("BH1750 Address: 0x");

     log += String(address,HEX);

     log += F(" Mode: 0x");

     log += String(mode);

     log += F(" : Light intensity: ");

     log += UserVar[event->BaseVarIndex];

     addLog(LOG_LEVEL_INFO,log);

       success=true;

      }

      break;

    }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P011_PME.ino"
#ifdef USES_P011
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P011_PME.ino"
#define PLUGIN_011 

#define PLUGIN_ID_011 11

#define PLUGIN_NAME_011 "Extra IO - ProMini Extender"

#define PLUGIN_VALUENAME1_011 "Value"



#define PLUGIN_011_I2C_ADDRESS 0x7f



boolean Plugin_011(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_011;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].Ports = 14;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_011);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_011));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2] = { F("Digital"), F("Analog") };

        addFormSelector(F("Port Type"), F("plugin_011"), 2, options, NULL, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_011"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_011_Read(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePort[event->TaskIndex]);

        String log = F("PME  : PortValue: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("extgpio"))

        {

          success = true;

          Plugin_011_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

        }



        if (command == F("extpwm"))

        {

          success = true;

          uint8_t address = PLUGIN_011_I2C_ADDRESS;

          Wire.beginTransmission(address);

          Wire.write(3);

          Wire.write(event->Par1);

          Wire.write(event->Par2 & 0xff);

          Wire.write((event->Par2 >> 8));

          Wire.endTransmission();

          setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_PWM, event->Par2);

          log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Set PWM to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

        }



        if (command == F("extpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 13)

          {

            Plugin_011_Write(event->Par1, event->Par2);

            delay(event->Par3);

            Plugin_011_Write(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

          }

        }



        if (command == F("extlongpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 13)

          {

            Plugin_011_Write(event->Par1, event->Par2);

            setSystemTimer(event->Par3 * 1000, PLUGIN_ID_011, event->Par1, !event->Par2, 0);

            setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

          }

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("ext"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_011, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par2, dummyString, 0);

            else

            {

              byte port = event->Par2;

              byte type = 0;

              if (port > 13)

              {

                type = 1;

                port -= 20;

              }

              int state = Plugin_011_Read(type, port);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_011_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 351 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P011_PME.ino"
int Plugin_011_Read(byte Par1, byte Par2)

{

  int value = -1;

  uint8_t address = PLUGIN_011_I2C_ADDRESS;

  Wire.beginTransmission(address);

  if (Par1 == 0)

    Wire.write(2);

  else

    Wire.write(4);

  Wire.write(Par2);

  Wire.write(0);

  Wire.write(0);

  Wire.endTransmission();

  delay(1);

  Wire.requestFrom(address, (uint8_t)0x4);

  byte buffer[4];

  if (Wire.available() == 4)

  {

    for (byte x = 0; x < 4; x++)

      buffer[x] = Wire.read();

    value = buffer[0] + 256 * buffer[1];

  }

  return value;

}
# 409 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P011_PME.ino"
void Plugin_011_Write(byte Par1, byte Par2)

{

  uint8_t address = 0x7f;

  Wire.beginTransmission(address);

  Wire.write(1);

  Wire.write(Par1);

  Wire.write(Par2 & 0xff);

  Wire.write((Par2 >> 8));

  Wire.endTransmission();

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P012_LCD.ino"
#ifdef USES_P012
# 23 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P012_LCD.ino"
#include <LiquidCrystal_I2C.h>



LiquidCrystal_I2C *lcd=NULL;

int Plugin_012_cols = 16;

int Plugin_012_rows = 2;

int Plugin_012_mode = 1;



#define PLUGIN_012 

#define PLUGIN_ID_012 12

#define PLUGIN_NAME_012 "Display - LCD2004"

#define PLUGIN_VALUENAME1_012 "LCD"



boolean Plugin_012(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte displayTimer = 0;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_012;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_012);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_012));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[16];

        for (byte x = 0; x < 16; x++)

        {

          if (x < 8)

            optionValues[x] = 0x20 + x;

          else

            optionValues[x] = 0x30 + x;





        }

        addFormSelectorI2C(F("plugin_012_adr"), 16, optionValues, choice);





        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[2];

        options2[0] = F("2 x 16");

        options2[1] = F("4 x 20");

        int optionValues2[2] = { 1, 2 };

        addFormSelector(F("Display Size"), F("plugin_012_size"), 2, options2, optionValues2, choice2);





        char deviceTemplate[4][80];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        for (byte varNr = 0; varNr < 4; varNr++)

        {

          addHtml(F("<TR><TD>Line "));

          addHtml(String(varNr + 1));

          addHtml(F(":<TD><input type='text' size='80' maxlength='80' name='Plugin_012_template"));

          addHtml(String(varNr + 1));

          addHtml(F("' value='"));

          addHtml(deviceTemplate[varNr]);

          addHtml(F("'>"));

        }





        addRowLabel(F("Display button"));

        addPinSelect(false, F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);





        char tmpString[128];

        sprintf_P(tmpString, PSTR("<TR><TD>Display Timeout:<TD><input type='text' name='plugin_12_timer' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        addHtml(tmpString);





        String options3[3];

        options3[0] = F("Continue to next line (as in v1.4)");

        options3[1] = F("Truncate exceeding message");

        options3[2] = F("Clear then truncate exceeding message");

        int optionValues3[3] = { 0,1,2 };

        addFormSelector(F("LCD command Mode"), F("plugin_012_mode"), 3, options3, optionValues3, Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_012_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_012_size"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_12_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_012_mode"));



        char deviceTemplate[4][80];

        for (byte varNr = 0; varNr < 4; varNr++)

        {

          char argc[25];

          String arg = F("Plugin_012_template");

          arg += varNr + 1;

          arg.toCharArray(argc, 25);

          String tmpString = WebServer.arg(argc);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2) {

          Plugin_012_rows = 4;

          Plugin_012_cols = 20;

        } else if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 1) {

          Plugin_012_rows = 2;

          Plugin_012_cols = 16;

        }



        Plugin_012_mode = Settings.TaskDevicePluginConfig[event->TaskIndex][3];







        if (!lcd)

          lcd = new LiquidCrystal_I2C(Settings.TaskDevicePluginConfig[event->TaskIndex][0], 20, 4);





        lcd->init();

        lcd->backlight();

        lcd->print(F("ESP Easy"));

        displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            if (lcd) {

              lcd->backlight();

            }

            displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if ( displayTimer > 0)

        {

          displayTimer--;

          if (lcd && displayTimer == 0)

            lcd->noBacklight();

        }

        break;

      }



    case PLUGIN_READ:

      {

        char deviceTemplate[4][80];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte x = 0; x < Plugin_012_rows; x++)

        {

          String tmpString = deviceTemplate[x];

          if (lcd && tmpString.length())

          {

            String newString = P012_parseTemplate(tmpString, Plugin_012_cols);

            lcd->setCursor(0, x);

            lcd->print(newString);

          }

        }

        success = false;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        if (lcd && tmpString.equalsIgnoreCase(F("LCDCMD")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          if (tmpString.equalsIgnoreCase(F("Off"))){

              lcd->noBacklight();

          }

          else if (tmpString.equalsIgnoreCase(F("On"))){

              lcd->backlight();

          }

          else if (tmpString.equalsIgnoreCase(F("Clear"))){

              lcd->clear();

          }

        }

        else if (lcd && tmpString.equalsIgnoreCase(F("LCD")))

        {

          success = true;

          tmpString = P012_parseTemplate(string, Plugin_012_cols);

          argIndex = tmpString.lastIndexOf(',');

          tmpString = tmpString.substring(argIndex + 1);



          int colPos = event->Par2 - 1;

          int rowPos = event->Par1 - 1;





          if (Plugin_012_mode == 2){

              lcd->setCursor(colPos, rowPos);

              for (byte i = colPos; i < Plugin_012_cols; i++) {

                  lcd->print(F(" "));

              }

          }





          lcd->setCursor(colPos, rowPos);

          if(Plugin_012_mode == 1 || Plugin_012_mode == 2){

              lcd->setCursor(colPos, rowPos);

              for (byte i = 0; i < Plugin_012_cols - colPos; i++) {

                  if(tmpString[i]){

                     lcd->print(tmpString[i]);

                  }

              }

          }





          else{



              boolean stillProcessing = 1;

              byte charCount = 1;

              while(stillProcessing) {

                   if (++colPos > Plugin_012_cols) {

                        rowPos += 1;

                        lcd->setCursor(0,rowPos);

                        colPos = 1;

                   }





                   if(rowPos < Plugin_012_rows ){

                       lcd->print(tmpString[charCount - 1]);

                   }



                   if (!tmpString[charCount]) {

                        stillProcessing = 0;

                   }

                   charCount += 1;

              }





          }



        }

        break;

      }



  }

  return success;

}







String P012_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);

  const char degree[3] = {0xc2, 0xb0, 0};

  const char degree_lcd[2] = {0xdf, 0};

  result.replace(degree, degree_lcd);

  return result;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P013_HCSR04.ino"
#ifdef USES_P013
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P013_HCSR04.ino"
#define PLUGIN_013 

#define PLUGIN_ID_013 13

#define PLUGIN_NAME_013 "Distance - HC-SR04, RCW-0001, etc."

#define PLUGIN_VALUENAME1_013 "Distance"



#include <NewPing.h>



boolean Plugin_013_init = false;

byte Plugin_013_TRIG_Pin = 0;

byte Plugin_013_IRQ_Pin = 0;

NewPing *sonar = NULL;



boolean Plugin_013(byte function, struct EventStruct *event, String& string)

{

  static byte switchstate[TASKS_MAX];

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_013;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_013);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_013));

        break;

      }





    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2];

        options[0] = F("Value");

        options[1] = F("State");

        int optionValues[2] = { 1, 2 };

        addFormSelector(F("Mode"), F("plugin_013_mode"), 2, options, optionValues, choice);



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

         addFormNumericBox(F("Threshold"), F("plugin_013_threshold"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_013_mode"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_013_threshold"));

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_013_init = true;



        Plugin_013_TRIG_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        Plugin_013_IRQ_Pin = Settings.TaskDevicePin2[event->TaskIndex];



        if (sonar)

        {

          delete sonar;

          sonar=NULL;

        }



        sonar = new NewPing(Plugin_013_TRIG_Pin, Plugin_013_IRQ_Pin);

        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

        if (sonar)

        {

          delete sonar;

          sonar=NULL;

        }

        break;

      }



    case PLUGIN_READ:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 1)

        {

          Plugin_013_TRIG_Pin = Settings.TaskDevicePin1[event->TaskIndex];

          float value = Plugin_013_read();

          String log = F("ULTRASONIC : Distance: ");

          if (value > 0)

          {

            UserVar[event->BaseVarIndex] = value;

            log += UserVar[event->BaseVarIndex];

            success = true;

          }

          else

            log += F("No reading!");



        addLog(LOG_LEVEL_INFO,log);

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

          Plugin_013_TRIG_Pin = Settings.TaskDevicePin1[event->TaskIndex];

          byte state = 0;

          float value = Plugin_013_read();

          if (value > 0)

          {

            if (value < Settings.TaskDevicePluginConfig[event->TaskIndex][1])

              state = 1;

            if (state != switchstate[event->TaskIndex])

            {

              String log = F("ULTRASONIC : State ");

              log += state;

              addLog(LOG_LEVEL_INFO,log);

              switchstate[event->TaskIndex] = state;

              UserVar[event->BaseVarIndex] = state;

              event->sensorType = SENSOR_TYPE_SWITCH;

              sendData(event);

            }

          }

        }

        success = true;

        break;

      }

  }

  return success;

}





float Plugin_013_read()



{

  if (!sonar)

  {

    return 0;

  }



  return sonar->ping_cm();

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
#ifdef USES_P014
# 13 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
#define PLUGIN_014 

#define PLUGIN_ID_014 14

#define PLUGIN_NAME_014 "Environment - SI7021/HTU21D"

#define PLUGIN_VALUENAME1_014 "Temperature"

#define PLUGIN_VALUENAME2_014 "Humidity"



boolean Plugin_014_init = false;
# 35 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
#define SI7021_I2C_ADDRESS 0x40

#define SI7021_MEASURE_TEMP_HUM 0xE0

#define SI7021_MEASURE_TEMP_HM 0xE3

#define SI7021_MEASURE_HUM_HM 0xE5

#define SI7021_MEASURE_TEMP 0xF3

#define SI7021_MEASURE_HUM 0xF5

#define SI7021_WRITE_REG 0xE6

#define SI7021_READ_REG 0xE7

#define SI7021_SOFT_RESET 0xFE







#define SI7021_RESOLUTION_14T_12RH 0x00

#define SI7021_RESOLUTION_13T_10RH 0x80

#define SI7021_RESOLUTION_12T_08RH 0x01

#define SI7021_RESOLUTION_11T_11RH 0x81

#define SI7021_RESOLUTION_MASK 0B01111110



uint16_t si7021_humidity;

int16_t si7021_temperature;



boolean Plugin_014(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_014;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_014);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_014));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_014));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #define SI7021_RESOLUTION_OPTION 4



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[SI7021_RESOLUTION_OPTION];

        int optionValues[SI7021_RESOLUTION_OPTION];

        optionValues[0] = SI7021_RESOLUTION_14T_12RH;

        options[0] = F("Temp 14 bits / RH 12 bits");

        optionValues[1] = SI7021_RESOLUTION_13T_10RH;

        options[1] = F("Temp 13 bits / RH 10 bits");

        optionValues[2] = SI7021_RESOLUTION_12T_08RH;

        options[2] = F("Temp 12 bits / RH  8 bits");

        optionValues[3] = SI7021_RESOLUTION_11T_11RH;

        options[3] = F("Temp 11 bits / RH 11 bits");

        addFormSelector(F("Resolution"), F("plugin_014_res"), SI7021_RESOLUTION_OPTION, options, optionValues, choice);





        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_014_res"));

        Plugin_014_init = false;

        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        uint8_t res = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (!Plugin_014_init) {

          Plugin_014_init = Plugin_014_si7021_begin(res);

        }





        if (Plugin_014_init && Plugin_014_si7021_readValues(res) == 0) {

          UserVar[event->BaseVarIndex] = si7021_temperature/100.0;

          UserVar[event->BaseVarIndex + 1] = si7021_humidity / 10.0;

          success = true;
# 251 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
        } else {

          addLog(LOG_LEVEL_INFO,F("SI7021 : Read Error!"));

        }



        break;

      }



  }

  return success;

}
# 287 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
boolean Plugin_014_si7021_begin(uint8_t resolution)

{

  uint8_t ret;





  ret = Plugin_014_si7021_setResolution(resolution);

  if ( ret == 0 ) {

    ret = true;

  } else {

    String log = F("SI7021 : Res=0x");

    log += String(resolution,HEX);

    log += F(" => Error 0x");

    log += String(ret,HEX);

    addLog(LOG_LEVEL_INFO,log);

    ret = false;

  }



  return ret;

}
# 341 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
uint8_t Plugin_014_si7021_checkCRC(uint16_t data, uint8_t check)

{

  uint32_t remainder, divisor;





  remainder = (uint32_t)data << 8;
# 361 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
  divisor = (uint32_t) 0x988000;





  remainder |= check;







  for (uint8_t i = 0 ; i < 16 ; i++) {



    if( remainder & (uint32_t)1<<(23 - i) )

      remainder ^= divisor;





    divisor >>= 1;

  }

  return ((uint8_t) remainder);

}
# 411 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_readRegister(uint8_t * value)

{





  Wire.beginTransmission(SI7021_I2C_ADDRESS);

  Wire.write(SI7021_READ_REG);

  Wire.endTransmission();





  Wire.requestFrom(SI7021_I2C_ADDRESS, 1);

  if (Wire.available()>=1) {

      *value = Wire.read();

      return 0;

  }



  return 1;

}
# 463 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_startConv(uint8_t datatype, uint8_t resolution)

{

  long data;

  uint16_t raw ;

  uint8_t checksum,tmp;





  Wire.beginTransmission(SI7021_I2C_ADDRESS);

  Wire.write(datatype);

  Wire.endTransmission();
# 515 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
  if (resolution == SI7021_RESOLUTION_11T_11RH)

    tmp = 7;

  else if (resolution == SI7021_RESOLUTION_12T_08RH)

    tmp = 13;

  else if (resolution == SI7021_RESOLUTION_13T_10RH)

    tmp = 25;

  else

    tmp = 50;







  if (datatype == SI7021_MEASURE_HUM)

    tmp *=2;



  delay(tmp);
# 577 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
  if ( Wire.requestFrom(SI7021_I2C_ADDRESS, 3) < 3 ) {

    return -1;

  }





  raw = ((uint16_t) Wire.read()) << 8;

  raw |= Wire.read();

  checksum = Wire.read();





  if(Plugin_014_si7021_checkCRC(raw, checksum) != 0) {

    addLog(LOG_LEVEL_INFO,F("SI7021 : checksum error!"));

    return -1;

  }





  if (datatype == SI7021_MEASURE_HUM || datatype == SI7021_MEASURE_HUM_HM) {





    data = ((1250 * (long)raw) >> 16) - 60;





    if (data>1000) data = 1000;

    if (data<0) data = 0;





    if (resolution == SI7021_RESOLUTION_12T_08RH) {

      data = (data + 5) / 10;

      data *= 10;

    }



    si7021_humidity = (uint16_t) data;





  } else if (datatype == SI7021_MEASURE_TEMP ||datatype == SI7021_MEASURE_TEMP_HM || datatype == SI7021_MEASURE_TEMP_HUM) {





    data = ((17572 * (long)raw) >> 16) - 4685;
# 681 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
    si7021_temperature = (int16_t) data;

  }



  return 0;

}
# 709 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_readValues(uint8_t resolution)

{

  int8_t error = 0;





  error |= Plugin_014_si7021_startConv(SI7021_MEASURE_HUM, resolution);





  error |= Plugin_014_si7021_startConv(SI7021_MEASURE_TEMP, resolution);



  return error;

}
# 749 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_setResolution(uint8_t res)

{

  uint8_t reg;

  uint8_t error;





  error = Plugin_014_si7021_readRegister(&reg);

  if ( error == 0) {



    reg &= SI7021_RESOLUTION_MASK ;





    Wire.beginTransmission(SI7021_I2C_ADDRESS);

    Wire.write(SI7021_WRITE_REG);





    Wire.write(reg | ( res &= ~SI7021_RESOLUTION_MASK) );

    return (int8_t) Wire.endTransmission();

  }



  return error;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
#ifdef USES_P015
# 21 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
#define PLUGIN_015 

#define PLUGIN_ID_015 15

#define PLUGIN_NAME_015 "Light/Lux - TSL2561"

#define PLUGIN_VALUENAME1_015 "Lux"

#define PLUGIN_VALUENAME2_015 "Infrared"

#define PLUGIN_VALUENAME3_015 "Broadband"



boolean Plugin_015_init = false;





#define TSL2561_ADDR_0 0x29

#define TSL2561_ADDR 0x39

#define TSL2561_ADDR_1 0x49



#define TSL2561_CMD 0x80

#define TSL2561_REG_CONTROL 0x00

#define TSL2561_REG_TIMING 0x01

#define TSL2561_REG_DATA_0 0x0C

#define TSL2561_REG_DATA_1 0x0E





byte plugin_015_i2caddr;

byte _error;



boolean plugin_015_begin()

{

 Wire.begin();

 return(true);

}



boolean plugin_015_readByte(unsigned char address, unsigned char &value)
# 91 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{



 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);

 _error = Wire.endTransmission();





 if (_error == 0)

 {

  Wire.requestFrom(plugin_015_i2caddr,(byte)1);

  if (Wire.available() == 1)

  {

   value = Wire.read();

   return(true);

  }

 }

 return(false);

}



boolean plugin_015_writeByte(unsigned char address, unsigned char value)
# 141 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{



 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);



 Wire.write(value);

 _error = Wire.endTransmission();

 if (_error == 0)

  return(true);



 return(false);

}





boolean plugin_015_readUInt(unsigned char address, unsigned int &value)
# 181 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{







 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);

 _error = Wire.endTransmission();





 if (_error == 0)

 {

  Wire.requestFrom(plugin_015_i2caddr,(byte)2);

  if (Wire.available() == 2)

  {

   char high, low;

   low = Wire.read();

   high = Wire.read();



   value = word(high,low);

   return(true);

  }

 }

 return(false);

}





boolean plugin_015_writeUInt(unsigned char address, unsigned int value)
# 245 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{



 if (plugin_015_writeByte(address,lowByte(value))

  && plugin_015_writeByte(address + 1,highByte(value)))

  return(true);



 return(false);

}







boolean plugin_015_setTiming(boolean gain, unsigned char time)
# 285 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{

 unsigned char timing;





 if (plugin_015_readByte(TSL2561_REG_TIMING,timing))

 {



  if (gain)

   timing |= 0x10;

  else

   timing &= ~0x10;





  timing &= ~0x03;

  timing |= (time & 0x03);





  if (plugin_015_writeByte(TSL2561_REG_TIMING,timing))

   return(true);

 }

 return(false);

}





boolean plugin_015_setTiming(boolean gain, unsigned char time, unsigned int &ms)
# 353 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{



 switch (time)

 {

  case 0: ms = 14; break;

  case 1: ms = 101; break;

  case 2: ms = 402; break;

  default: ms = 0;

 }



 return(plugin_015_setTiming(gain,time));

}





boolean plugin_015_setPowerUp(void)







{



 return(plugin_015_writeByte(TSL2561_REG_CONTROL,0x03));

}





boolean plugin_015_setPowerDown(void)







{



 return(plugin_015_writeByte(TSL2561_REG_CONTROL,0x00));

}



boolean plugin_015_getData(unsigned int &data0, unsigned int &data1)
# 429 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{



 if (plugin_015_readUInt(TSL2561_REG_DATA_0,data0) && plugin_015_readUInt(TSL2561_REG_DATA_1,data1))

  return(true);



 return(false);

}





boolean plugin_015_getLux(unsigned char gain, unsigned int ms, unsigned int CH0, unsigned int CH1, double &lux, double &infrared, double &broadband)
# 463 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
{
# 473 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
 if ((CH0 == 0xFFFF) || (CH1 == 0xFFFF))

 {

  lux = 65535.0;

  return(false);

 }

 else

 {

  double ratio, d0, d1;



  d0 = CH0; d1 = CH1;





  ratio = d1 / d0;





    infrared = d1;

    broadband = d0;





  d0 *= (402.0/ms);

  d1 *= (402.0/ms);





  if (!gain)

  {

   d0 *= 16;

   d1 *= 16;

  }







  if (ratio < 0.5)

  {

   lux = 0.0304 * d0 - 0.062 * d0 * pow(ratio,1.4);

   return(true);

  }



  if (ratio < 0.61)

  {

   lux = 0.0224 * d0 - 0.031 * d1;

   return(true);

  }



  if (ratio < 0.80)

  {

   lux = 0.0128 * d0 - 0.0153 * d1;

   return(true);

  }



  if (ratio < 1.30)

  {

   lux = 0.00146 * d0 - 0.00112 * d1;

   return(true);

  }





  lux = 0.0;

  return(true);

 }

}





boolean Plugin_015(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_015;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_015);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_015));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_015));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_015));



        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice1 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 689 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
        int optionValues1[3];

        optionValues1[0] = TSL2561_ADDR;

        optionValues1[1] = TSL2561_ADDR_1;

        optionValues1[2] = TSL2561_ADDR_0;

    addFormSelectorI2C(F("plugin_015_tsl2561_i2c"), 3, optionValues1, choice1);



        #define TSL2561_INTEGRATION_OPTION 3



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[TSL2561_INTEGRATION_OPTION];

        int optionValues2[TSL2561_INTEGRATION_OPTION];

        optionValues2[0] = 0x00;

        options2[0] = F("13 ms");

        optionValues2[1] = 0x01;

        options2[1] = F("101 ms");

        optionValues2[2] = 0x02;

        options2[2] = F("402 ms");

    addFormSelector(F("Integration time"), F("plugin_015_integration"), TSL2561_INTEGRATION_OPTION, options2, optionValues2, choice2);



        addFormCheckBox(F("Send sensor to sleep:"), F("plugin_015_sleep"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addFormCheckBox(F("Enable 16x Gain:"), F("plugin_015_gain"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_015_tsl2561_i2c"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_015_integration"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_015_sleep"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_015_gain"));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       plugin_015_i2caddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        boolean gain;

        unsigned int ms;



        plugin_015_begin();







         gain = Settings.TaskDevicePluginConfig[event->TaskIndex][3];
# 807 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P015_TSL2561.ino"
         unsigned char time = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

         plugin_015_setTiming(gain,time,ms);

         plugin_015_setPowerUp();

         delayBackground(ms);

         unsigned int data0, data1;



         if (plugin_015_getData(data0,data1))

         {



           double lux;

           double infrared;

           double broadband;

           boolean good;







           good = plugin_015_getLux(gain,ms,data0,data1,lux, infrared, broadband);

          UserVar[event->BaseVarIndex] = lux;

           UserVar[event->BaseVarIndex + 1] = infrared;

           UserVar[event->BaseVarIndex + 2] = broadband;



           if (!good)

           {

             addLog(LOG_LEVEL_INFO,F("TSL2561: Sensor saturated! > 65535 Lux"));

           }



           success = true;

           String log = F("TSL2561: Address: 0x");

           log += String(plugin_015_i2caddr,HEX);

           log += F(": Mode: ");

           log += String(time,HEX);

           log += F(": Gain: ");

           log += String(gain,HEX);

           log += F(": Lux: ");

           log += UserVar[event->BaseVarIndex];

           log += F(": Infrared: ");

           log += UserVar[event->BaseVarIndex + 1];

           log += F(": Broadband: ");

           log += UserVar[event->BaseVarIndex + 2];

           addLog(LOG_LEVEL_INFO,log);

         }

         else

         {



          addLog(LOG_LEVEL_ERROR, F("TSL2561: i2c error"));



         }

         if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

          addLog(LOG_LEVEL_DEBUG_MORE, F("TSL2561: sleeping..."));

          plugin_015_setPowerDown();

         }



        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P016_IR.ino"
#ifdef USES_P016
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P016_IR.ino"
#include <IRremoteESP8266.h>

IRrecv *irReceiver;

decode_results results;



#define PLUGIN_016 

#define PLUGIN_ID_016 16

#define PLUGIN_NAME_016 "Communication - TSOP4838"

#define PLUGIN_VALUENAME1_016 "IR"



boolean Plugin_016(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_016;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_016);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_016));

        break;

      }



    case PLUGIN_INIT:

      {

        int irPin = Settings.TaskDevicePin1[event->TaskIndex];

        if (irReceiver == 0 && irPin != -1)

        {

          Serial.println(F("IR Init"));

          irReceiver= new IRrecv(irPin);

          irReceiver->enableIRIn();

        }

        if (irReceiver != 0 && irPin == -1)

        {

          Serial.println(F("IR Removed"));

          irReceiver->disableIRIn();

          delete irReceiver;

          irReceiver=0;

        }

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (irReceiver->decode(&results))

        {

          unsigned long IRcode = results.value;

          irReceiver->resume();

          UserVar[event->BaseVarIndex] = (IRcode & 0xFFFF);

          UserVar[event->BaseVarIndex + 1] = ((IRcode >> 16) & 0xFFFF);

          String log = F("IR   : Code ");

          log += String(IRcode, HEX);

          log += F(" - Type: ");

          log += results.decode_type;

          log += F(" - Bits: ");

          log += results.bits;

          addLog(LOG_LEVEL_INFO, log);

          sendData(event);

        }

        success = true;

        break;

      }

  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
#ifdef USES_P017
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
#define PLUGIN_017 

#define PLUGIN_ID_017 17

#define PLUGIN_NAME_017 "RFID - PN532"

#define PLUGIN_VALUENAME1_017 "Tag"



#define PN532_I2C_ADDRESS 0x24



#define PN532_PREAMBLE (0x00)

#define PN532_STARTCODE1 (0x00)

#define PN532_STARTCODE2 (0xFF)

#define PN532_POSTAMBLE (0x00)

#define PN532_HOSTTOPN532 (0xD4)

#define PN532_PN532TOHOST (0xD5)

#define PN532_ACK_WAIT_TIME (3)

#define PN532_INVALID_ACK (-1)

#define PN532_TIMEOUT (-2)

#define PN532_INVALID_FRAME (-3)

#define PN532_NO_SPACE (-4)



#define PN532_COMMAND_GETFIRMWAREVERSION (0x02)

#define PN532_COMMAND_SAMCONFIGURATION (0x14)

#define PN532_COMMAND_INLISTPASSIVETARGET (0x4A)

#define PN532_RESPONSE_INLISTPASSIVETARGET (0x4B)

#define PN532_MIFARE_ISO14443A (0x00)



uint8_t Plugin_017_pn532_packetbuffer[64];

uint8_t Plugin_017_command;



boolean Plugin_017(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_017;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_017);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_017));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormPinSelect(F("Reset Pin"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {
# 163 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
        for(byte x=0; x < 3; x++)

        {

          if(Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]))

            break;

          delay(1000);

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        static unsigned long tempcounter = 0;

        static byte counter;

        static byte errorCount=0;



        counter++;

        if (counter == 3)

        {

          if (digitalRead(4) == 0 || digitalRead(5) == 0)

          {

            addLog(LOG_LEVEL_ERROR, F("PN532: BUS error"));

            Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]);



          }

          counter = 0;

          uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };

          uint8_t uidLength;

          byte error = Plugin_017_readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &uidLength);



          if (error == 1)

          {

            errorCount++;

            String log = F("PN532: Read error: ");

            log += errorCount;

            addLog(LOG_LEVEL_ERROR, log);

          }

          else

            errorCount=0;



          if (errorCount > 2)

          {

            Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]);

          }



          if (error == 0) {

            unsigned long key = uid[0];

            for (uint8_t i = 1; i < 4; i++) {

              key <<= 8;

              key += uid[i];

            }

            UserVar[event->BaseVarIndex] = (key & 0xFFFF);

            UserVar[event->BaseVarIndex + 1] = ((key >> 16) & 0xFFFF);

            String log = F("PN532: Tag: ");

            log += key;

            tempcounter++;

            log += " ";

            log += tempcounter;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        break;

      }

  }

  return success;

}
# 305 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
boolean Plugin_017_Init(int8_t resetPin)

{

  if (resetPin != -1)

  {

    String log = F("PN532: Reset on pin: ");

    log += resetPin;

    addLog(LOG_LEVEL_INFO, log);

    pinMode(resetPin, OUTPUT);

    digitalWrite(resetPin, LOW);

    delay(100);

    digitalWrite(resetPin, HIGH);

    pinMode(resetPin, INPUT_PULLUP);

    delay(10);

  }



  Wire.beginTransmission(PN532_I2C_ADDRESS);

  Wire.endTransmission();

  delay(5);



  uint32_t versiondata = getFirmwareVersion();

  if (versiondata) {

    String log = F("PN532: Found chip PN5");

    log += String((versiondata >> 24) & 0xFF, HEX);

    log += F(" FW: ");

    log += String((versiondata >> 16) & 0xFF, HEX);

    log += F(".");

    log += String((versiondata >> 8) & 0xFF, HEX);

    addLog(LOG_LEVEL_INFO, log);

  }

  else

    return false;



  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_SAMCONFIGURATION;

  Plugin_017_pn532_packetbuffer[1] = 0x01;

  Plugin_017_pn532_packetbuffer[2] = 0x2;

  Plugin_017_pn532_packetbuffer[3] = 0x01;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 4))

    return false;





  Wire.beginTransmission(PN532_I2C_ADDRESS);

  Wire.endTransmission();

  delay(5);



  return true;

}
# 409 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
uint32_t getFirmwareVersion(void)

{

  uint32_t response;



  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_GETFIRMWAREVERSION;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 1)) {

    return 0;

  }



  delay(50);





  int16_t status = Plugin_017_readResponse(Plugin_017_pn532_packetbuffer, sizeof(Plugin_017_pn532_packetbuffer));

  if (0 > status) {

    return 0;

  }



  response = Plugin_017_pn532_packetbuffer[0];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[1];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[2];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[3];



  return response;

}
# 475 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
byte Plugin_017_readPassiveTargetID(uint8_t cardbaudrate, uint8_t *uid, uint8_t *uidLength)

{

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_INLISTPASSIVETARGET;

  Plugin_017_pn532_packetbuffer[1] = 1;

  Plugin_017_pn532_packetbuffer[2] = cardbaudrate;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 3)) {

    return 0x1;

  }



  delay(50);





  if (Plugin_017_readResponse(Plugin_017_pn532_packetbuffer, sizeof(Plugin_017_pn532_packetbuffer)) < 0) {
# 513 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
    Wire.beginTransmission(PN532_I2C_ADDRESS);

    Wire.endTransmission();

    return 0x2;

  }



  if (Plugin_017_pn532_packetbuffer[0] != 1)

    return 0x3;



  uint16_t sens_res = Plugin_017_pn532_packetbuffer[2];

  sens_res <<= 8;

  sens_res |= Plugin_017_pn532_packetbuffer[3];





  *uidLength = Plugin_017_pn532_packetbuffer[5];



  for (uint8_t i = 0; i < Plugin_017_pn532_packetbuffer[5]; i++) {

    uid[i] = Plugin_017_pn532_packetbuffer[6 + i];

  }



  return 0;

}
# 565 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen)

{

  Plugin_017_command = header[0];

  Wire.beginTransmission(PN532_I2C_ADDRESS);



  Wire.write(PN532_PREAMBLE);

  Wire.write(PN532_STARTCODE1);

  Wire.write(PN532_STARTCODE2);



  uint8_t length = hlen + 1;

  Wire.write(length);

  Wire.write(~length + 1);



  Wire.write(PN532_HOSTTOPN532);

  uint8_t sum = PN532_HOSTTOPN532;



  for (uint8_t i = 0; i < hlen; i++) {

    if (Wire.write(header[i])) {

      sum += header[i];



    } else {

      return PN532_INVALID_FRAME;

    }

  }



  uint8_t checksum = ~sum + 1;

  Wire.write(checksum);

  Wire.write(PN532_POSTAMBLE);

  byte status = Wire.endTransmission();



  if (status != 0)

    return PN532_INVALID_FRAME;



  return Plugin_017_readAckFrame();

}
# 645 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
int16_t Plugin_017_readResponse(uint8_t buf[], uint8_t len)

{

  if (!Wire.requestFrom(PN532_I2C_ADDRESS, len + 2))

    return -1;



  if (!(Wire.read() & 1))

    return -1;



  if (0x00 != Wire.read() ||

      0x00 != Wire.read() ||

      0xFF != Wire.read()

     ) {



    return PN532_INVALID_FRAME;

  }



  uint8_t length = Wire.read();

  if (0 != (uint8_t)(length + Wire.read())) {

    return PN532_INVALID_FRAME;

  }



  uint8_t cmd = Plugin_017_command + 1;

  if (PN532_PN532TOHOST != Wire.read() || (cmd) != Wire.read()) {

    return PN532_INVALID_FRAME;

  }



  length -= 2;

  if (length > len) {

    return PN532_NO_SPACE;

  }



  uint8_t sum = PN532_PN532TOHOST + cmd;

  for (uint8_t i = 0; i < length; i++) {

    buf[i] = Wire.read();

    sum += buf[i];



  }



  uint8_t checksum = Wire.read();

  if (0 != (uint8_t)(sum + checksum)) {

    return PN532_INVALID_FRAME;

  }

  Wire.read();



  return length;

}
# 747 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P017_PN532.ino"
int8_t Plugin_017_readAckFrame()

{

  const uint8_t PN532_ACK[] = {0, 0, 0xFF, 0, 0xFF, 0};

  uint8_t ackBuf[sizeof(PN532_ACK)];



  uint16_t time = 0;

  do {

    if (Wire.requestFrom(PN532_I2C_ADDRESS, sizeof(PN532_ACK) + 1)) {

      if (Wire.read() & 1) {

        break;

      }

    }



    delay(5);

    time++;

    if (time > PN532_ACK_WAIT_TIME) {

      return PN532_TIMEOUT;

    }

  } while (1);





  for (uint8_t i = 0; i < sizeof(PN532_ACK); i++) {

    ackBuf[i] = Wire.read();

  }



  if (memcmp(ackBuf, PN532_ACK, sizeof(PN532_ACK))) {

    return PN532_INVALID_ACK;

  }



  return 0;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P018_Dust.ino"
#ifdef USES_P018
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P018_Dust.ino"
#define PLUGIN_018 

#define PLUGIN_ID_018 18

#define PLUGIN_NAME_018 "Dust - Sharp GP2Y10"

#define PLUGIN_VALUENAME1_018 "Dust"



boolean Plugin_018_init = false;

byte Plugin_GP2Y10_LED_Pin = 0;



boolean Plugin_018(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_018;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_018);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_018));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_018_init = true;

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

        Plugin_GP2Y10_LED_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        digitalWrite(Plugin_GP2Y10_LED_Pin, HIGH);

        success = true;

        break;

      }





    case PLUGIN_READ:

      {

        Plugin_GP2Y10_LED_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        noInterrupts();

        byte x;

        int value;

        value = 0;

        for (x = 0; x < 25; x++)

        {

          digitalWrite(Plugin_GP2Y10_LED_Pin, LOW);

          delayMicroseconds(280);

          value = value + analogRead(A0);

          delayMicroseconds(40);

          digitalWrite(Plugin_GP2Y10_LED_Pin, HIGH);

          delayMicroseconds(9680);

        }

        interrupts();

        UserVar[event->BaseVarIndex] = (float)value;

        String log = F("GPY  : Dust value: ");

        log += value;

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P019_PCF8574.ino"
#ifdef USES_P019
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P019_PCF8574.ino"
#define PLUGIN_019 

#define PLUGIN_ID_019 19

#define PLUGIN_NAME_019 "Switch input - PCF8574"

#define PLUGIN_VALUENAME1_019 "Switch"



boolean Plugin_019(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_019;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 8;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_019);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_019));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("Send Boot state"), F("plugin_019_boot"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_019_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {



        switchstate[event->TaskIndex] = Plugin_019_Read(Settings.TaskDevicePort[event->TaskIndex]);





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        int state = Plugin_019_Read(Settings.TaskDevicePort[event->TaskIndex]);

        if (state != -1)

        {

          if (state != switchstate[event->TaskIndex])

          {

            String log = F("PCF  : State ");

            log += state;

            addLog(LOG_LEVEL_INFO, log);

            switchstate[event->TaskIndex] = state;

            UserVar[event->BaseVarIndex] = state;

            event->sensorType = SENSOR_TYPE_SWITCH;

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("PCF  : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("pcfgpio"))

        {

          success = true;

          if (event->Par2 == 2) {



           setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_INPUT, 1);

           Plugin_019_Write(event->Par1,1);

           log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Set to 1"));

          }

          else {

           setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

           Plugin_019_Write(event->Par1, event->Par2);

           log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          }

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("pcfpulse"))

        {

          success = true;

          Plugin_019_Write(event->Par1, event->Par2);

          delay(event->Par3);

          Plugin_019_Write(event->Par1, !event->Par2);

          setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("pcflongpulse"))

        {

          success = true;

          Plugin_019_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          setSystemTimer(event->Par3 * 1000, PLUGIN_ID_019, event->Par1, !event->Par2, 0);

          log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("pcf"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_019, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par2, dummyString, 0);

            else

            {

              int state = Plugin_019_Read(event->Par2);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_019_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 377 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P019_PCF8574.ino"
int Plugin_019_Read(byte Par1)

{

  int8_t state = -1;

  byte unit = (Par1 - 1) / 8;

  byte port = Par1 - (unit * 8);

  uint8_t address = 0x20 + unit;

  if (unit > 7) address += 0x10;





  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    state = ((Wire.read() & _BV(port - 1)) >> (port - 1));

  }

  return state;

}
# 419 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P019_PCF8574.ino"
boolean Plugin_019_Write(byte Par1, byte Par2)

{

  byte unit = (Par1 - 1) / 8;

  byte port = Par1 - (unit * 8);

  uint8_t address = 0x20 + unit;

  if (unit > 7) address += 0x10;





  int i = 0;

  byte portmask = 0;

  byte mode = 0;

  uint16_t value = 0;

  unit *= 8;

  unit += 1;

  for(i =0;i<8;i++){

   mode =0;

   if(!getPinState(PLUGIN_ID_019, unit, &mode, &value) || mode == PIN_MODE_INPUT || (mode == PIN_MODE_OUTPUT && value == 1))

    portmask |= (1 << i);

   unit++;

  }



  if (Par2 == 1)

    portmask |= (1 << (port - 1));

  else

    portmask &= ~(1 << (port - 1));



  Wire.beginTransmission(address);

  Wire.write(portmask);

  Wire.endTransmission();



  return true;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P020_Ser2Net.ino"
#ifdef USES_P020
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P020_Ser2Net.ino"
#define PLUGIN_020 

#define PLUGIN_ID_020 20

#define PLUGIN_NAME_020 "Communication - Serial Server"

#define PLUGIN_VALUENAME1_020 "Ser2Net"



#define P020_BUFFER_SIZE 128

boolean Plugin_020_init = false;

byte Plugin_020_SerialProcessing = 0;



WiFiServer *ser2netServer;

WiFiClient ser2netClient;



boolean Plugin_020(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte connectionState = 0;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_020;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_020);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_020));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("TCP Port"), F("plugin_020_port"), ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

       addFormNumericBox(F("Baud Rate"), F("plugin_020_baud"), ExtraTaskSettings.TaskDevicePluginConfigLong[1]);

       addFormNumericBox(F("Data bits"), F("plugin_020_data"), ExtraTaskSettings.TaskDevicePluginConfigLong[2]);



        byte choice = ExtraTaskSettings.TaskDevicePluginConfigLong[3];

        String options[3];

        options[0] = F("No parity");

        options[1] = F("Even");

        options[2] = F("Odd");

        int optionValues[3];

        optionValues[0] = 0;

        optionValues[1] = 2;

        optionValues[2] = 3;

        addFormSelector(F("Parity"), F("plugin_020_parity"), 3, options, optionValues, choice);



       addFormNumericBox(F("Stop bits"), F("plugin_020_stop"), ExtraTaskSettings.TaskDevicePluginConfigLong[4]);



       addFormPinSelect(F("Reset target after boot"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);



       addFormNumericBox(F("RX Receive Timeout (mSec)"), F("plugin_020_rxwait"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);





        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[3];

        options2[0] = F("None");

        options2[1] = F("Generic");

        options2[2] = F("RFLink");

        addFormSelector(F("Event processing"), F("plugin_020_events"), 3, options2, NULL, choice2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        ExtraTaskSettings.TaskDevicePluginConfigLong[0] = getFormItemInt(F("plugin_020_port"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[1] = getFormItemInt(F("plugin_020_baud"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[2] = getFormItemInt(F("plugin_020_data"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[3] = getFormItemInt(F("plugin_020_parity"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[4] = getFormItemInt(F("plugin_020_stop"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_020_rxwait"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_020_events"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        LoadTaskSettings(event->TaskIndex);

        if ((ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0) && (ExtraTaskSettings.TaskDevicePluginConfigLong[1] != 0))

        {

          #if defined(ESP8266)

            byte serialconfig = 0x10;

          #endif

          #if defined(ESP32)

            uint32_t serialconfig = 0x8000010;

          #endif

          serialconfig += ExtraTaskSettings.TaskDevicePluginConfigLong[3];

          serialconfig += (ExtraTaskSettings.TaskDevicePluginConfigLong[2] - 5) << 2;

          if (ExtraTaskSettings.TaskDevicePluginConfigLong[4] == 2)

            serialconfig += 0x20;

          #if defined(ESP8266)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], (SerialConfig)serialconfig);

          #endif

          #if defined(ESP32)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], serialconfig);

          #endif

          ser2netServer = new WiFiServer(ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

          ser2netServer->begin();



          if (Settings.TaskDevicePin1[event->TaskIndex] != -1)

          {

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], LOW);

            delay(500);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], HIGH);

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

          }



          Plugin_020_init = true;

        }

        Plugin_020_SerialProcessing = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_020_init)

        {

          size_t bytes_read;

          if (ser2netServer->hasClient())

          {

            if (ser2netClient) ser2netClient.stop();

            ser2netClient = ser2netServer->available();

            addLog(LOG_LEVEL_ERROR, F("Ser2N: Client connected!"));

          }



          if (ser2netClient.connected())

          {

            connectionState = 1;

            uint8_t net_buf[P020_BUFFER_SIZE];

            int count = ser2netClient.available();

            if (count > 0)

            {

              if (count > P020_BUFFER_SIZE)

                count = P020_BUFFER_SIZE;

              bytes_read = ser2netClient.read(net_buf, count);

              Serial.write(net_buf, bytes_read);

              Serial.flush();



              if (count == P020_BUFFER_SIZE)

              {

                count--;

                addLog(LOG_LEVEL_ERROR, F("Ser2N: network buffer full!"));

              }

              net_buf[count] = 0;

              char log[P020_BUFFER_SIZE + 40];

              sprintf_P(log, PSTR("Ser2N: N>: %s"), (char*)net_buf);

              addLog(LOG_LEVEL_DEBUG, log);

            }

          }

          else

          {

            if (connectionState == 1)

            {

              connectionState = 0;



              ser2netClient = WiFiClient();

              addLog(LOG_LEVEL_ERROR, F("Ser2N: Client disconnected!"));

            }



            while (Serial.available())

              Serial.read();

          }



          success = true;

        }

        break;

      }



    case PLUGIN_SERIAL_IN:

      {

        uint8_t serial_buf[P020_BUFFER_SIZE];

        int RXWait = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if (RXWait == 0)

          RXWait = 1;

        int timeOut = RXWait;

        size_t bytes_read = 0;

        while (timeOut > 0)

        {

          while (Serial.available()) {

            if (bytes_read < P020_BUFFER_SIZE) {

              serial_buf[bytes_read] = Serial.read();

              bytes_read++;

            }

            else

              Serial.read();



            timeOut = RXWait;

          }

          delay(1);

          timeOut--;

        }



        if (bytes_read != P020_BUFFER_SIZE)

        {

          if (bytes_read > 0) {

            if (Plugin_020_init && ser2netClient.connected())

            {

              ser2netClient.write((const uint8_t*)serial_buf, bytes_read);

              ser2netClient.flush();

            }

          }

        }

        else

        {

          while (Serial.available())

            Serial.read();

          bytes_read--;



          addLog(LOG_LEVEL_ERROR, F("Ser2N: serial buffer full!"));

        }

        serial_buf[bytes_read] = 0;

        char log[P020_BUFFER_SIZE + 40];

        sprintf_P(log, PSTR("Ser2N: S>: %s"), (char*)serial_buf);

        addLog(LOG_LEVEL_DEBUG, log);





        if (Settings.UseRules)

        {

          String message = (char*)serial_buf;

          int NewLinePos = message.indexOf(F("\r\n"));

          if (NewLinePos > 0)

            message = message.substring(0, NewLinePos);

          String eventString = "";



          switch (Plugin_020_SerialProcessing)

          {

            case 0:

              {

                break;

              }



            case 1:

              {

                eventString = F("!Serial#");

                eventString += message;

                break;

              }



            case 2:

              {

                message = message.substring(6);

                if (message.startsWith("ESPEASY"))

                {

                  message = message.substring(8);

                  eventString = F("RFLink#");

                }

                else

                  eventString = F("!RFLink#");

                eventString += message;

                break;

              }

          }



          if (eventString.length() > 0)

            rulesProcessing(eventString);



        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String command = parseString(string, 1);

        if (command == F("serialsend"))

        {

          success = true;

          String tmpString = string.substring(11);

          Serial.println(tmpString);

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P021_Level.ino"
#ifdef USES_P021
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P021_Level.ino"
#define PLUGIN_021 

#define PLUGIN_ID_021 21

#define PLUGIN_NAME_021 "Regulator - Level Control"

#define PLUGIN_VALUENAME1_021 "Output"



boolean Plugin_021(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_021;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_021);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_021));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {





        addHtml(F("<TR><TD>Check Task:<TD>"));

        addTaskSelect(F("plugin_021_task"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        LoadTaskSettings(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        addHtml(F("<TR><TD>Check Value:<TD>"));

        addTaskValueSelect(F("plugin_021_value"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



       addFormTextBox(F("Set Level"), F("plugin_021_setvalue"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0]), 8);



       addFormTextBox(F("Hysteresis"), F("plugin_021_hyst"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1]), 8);



        LoadTaskSettings(event->TaskIndex);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_021_task"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_021_value"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_021_setvalue"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_021_hyst"));

        success = true;

        break;

      }



    case PLUGIN_SET_CONFIG:

      {

        String command = parseString(string, 1);

        if (command == F("setlevel"))

        {

          String value = parseString(string, 2);

          float result=0;

          Calculate(value.c_str(), &result);

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = result;

          SaveSettings();

          success = true;

        }

        break;

      }



    case PLUGIN_GET_CONFIG:

      {

        String command = parseString(string, 1);

        if (command == F("getlevel"))

        {

          string = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          success = true;

        }

        break;

      }



    case PLUGIN_INIT:

      {

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {



        byte TaskIndex = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte BaseVarIndex = TaskIndex * VARS_PER_TASK + Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        float value = UserVar[BaseVarIndex];

        byte state = switchstate[event->TaskIndex];



        float valueLowThreshold = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] - (Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] / 2);

        float valueHighThreshold = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] + (Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] / 2);

        if (value <= valueLowThreshold)

          state = 1;

        if (value >= valueHighThreshold)

          state = 0;

        if (state != switchstate[event->TaskIndex])

        {

          String log = F("LEVEL: State ");

          log += state;

          addLog(LOG_LEVEL_INFO, log);

          switchstate[event->TaskIndex] = state;

          digitalWrite(Settings.TaskDevicePin1[event->TaskIndex],state);

          UserVar[event->BaseVarIndex] = state;

          sendData(event);

        }



        success = true;

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P022_PCA9685.ino"
#ifdef USES_P022
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P022_PCA9685.ino"
#define PLUGIN_022 

#define PLUGIN_ID_022 22

#define PLUGIN_NAME_022 "Extra IO - PCA9685"

#define PLUGIN_VALUENAME1_022 "PWM"



#define PLUGIN_022_PCA9685_MODE1 0x00

#define PCA9685_MODE2 0x01

#define PCA9685_LED0 0x06

#define PCA9685_ADDRESS 0x40



boolean Plugin_022_init = false;



boolean Plugin_022(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;





  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_022;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_022);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_022));

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("pcapwm"))

        {

          if (!Plugin_022_init) Plugin_022_initialize();

          success = true;

          Plugin_022_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_022, event->Par1, PIN_MODE_PWM, event->Par2);

          log = String(F("PCA  : GPIO ")) + String(event->Par1) + String(F(" Set PWM to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par1, log, 0));

        }

        if (command == F("pcafrq"))

        {

          if (!Plugin_022_init) Plugin_022_initialize();

          success = true;

          Plugin_022_Frequency(event->Par1);

          setPinState(PLUGIN_ID_022, 99, PIN_MODE_UNDEFINED, event->Par1);

          log = String(F("PCA  : FREQ ")) + String(event->Par1);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, 99, log, 0));

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("pca"))

          {

            if (!Plugin_022_init) Plugin_022_initialize();

            success = true;

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par2, dummyString, 0));

          }

        }

        break;

      }

  }

  return success;

}
# 193 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P022_PCA9685.ino"
void Plugin_022_writeRegister(int regAddress, byte data) {

  Wire.beginTransmission(PCA9685_ADDRESS);

  Wire.write(regAddress);

  Wire.write(data);

  Wire.endTransmission();

}



uint8_t Plugin_022_readRegister(int regAddress) {

  uint8_t res = 0;

  Wire.requestFrom(PCA9685_ADDRESS,1,1);

  while (Wire.available()) {

    res = Wire.read();

  }

  return res;

}
# 233 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P022_PCA9685.ino"
void Plugin_022_Write(byte Par1, int Par2)

{



  uint16_t LED_ON = 0;

  uint16_t LED_OFF = Par2;

  Wire.beginTransmission(PCA9685_ADDRESS);

  Wire.write(0x06 + 4 * Par1);

  Wire.write(lowByte(LED_ON));

  Wire.write(highByte(LED_ON));

  Wire.write(lowByte(LED_OFF));

  Wire.write(highByte(LED_OFF));

  Wire.endTransmission();

}

void Plugin_022_Frequency(uint16_t freq)

{

  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)0x0);

  freq *= 0.9;



  uint16_t prescale = 6103;

  prescale /= freq;

  prescale -= 1;

  uint8_t oldmode = Plugin_022_readRegister(0);

  uint8_t newmode = (oldmode&0x7f) | 0x10;

  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)newmode);

  Plugin_022_writeRegister(0xfe, (byte)prescale);

  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)oldmode);

  delayMicroseconds(5000);

  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)oldmode | 0xa1);

}



void Plugin_022_initialize()

{



  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)0x01);

  delay(1);

  Plugin_022_writeRegister(PLUGIN_022_PCA9685_MODE1, (byte)B10100000);

  Plugin_022_writeRegister(PCA9685_MODE2, (byte)0x10);

  Plugin_022_init = true;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P023_OLED.ino"
#ifdef USES_P023
# 23 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P023_OLED.ino"
#define PLUGIN_023 

#define PLUGIN_ID_023 23

#define PLUGIN_NAME_023 "Display - OLED SSD1306"

#define PLUGIN_VALUENAME1_023 "OLED"



byte Plugin_023_OLED_address = 0x3c;

byte Plugin_023_OLED_type = 0;

byte Plugin_023_OLED_font_width = 0;



enum

{

  OLED_64x48 = 0x01,

  OLED_rotated = 0x02,

  OLED_128x32 = 0x04

};



enum

{

  Size_normal = 0x01,

  Size_optimized = 0x02

};



boolean Plugin_023(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte displayTimer = 0;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_023;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_023);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_023));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x3C, 0x3D };

        addFormSelectorI2C(F("plugin_023_adr"), 2, optionValues, choice);



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[2] = { F("Normal"), F("Rotated") };

        int optionValues2[2] = { 1, 2 };

        addFormSelector(F("Rotation"), F("plugin_023_rotate"), 2, options2, optionValues2, choice2);



        byte choice3 = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        String options3[3] = { F("128x64"), F("128x32"), F("64x48") };

        int optionValues3[3] = { 1, 3, 2 };

        addFormSelector(F("Display Size"), F("plugin_023_size"), 3, options3, optionValues3, choice3);



        byte choice4 = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        String options4[2] = { F("Normal"), F("Optimized") };

        int optionValues4[2] = { 1, 2 };

        addFormSelector(F("Font Width"), F("plugin_023_font_width"), 2, options4, optionValues4, choice4);



        char deviceTemplate[8][64];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        for (byte varNr = 0; varNr < 8; varNr++)

        {

         addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_023_template")) + (varNr + 1), deviceTemplate[varNr], 64);

        }



        addFormPinSelect(F("Display button"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);



        addFormNumericBox(F("Display Timeout"), F("plugin_23_timer"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_023_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_023_rotate"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_23_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_023_size"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_023_font_width"));



        char deviceTemplate[8][64];

        for (byte varNr = 0; varNr < 8; varNr++)

        {

          String arg = F("Plugin_023_template");

          arg += varNr + 1;

          String tmpString = WebServer.arg(arg);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr])-1);

          deviceTemplate[varNr][63]=0;

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_023_OLED_type = 0;

        Plugin_023_OLED_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3] == 3)

        {

          Plugin_023_OLED_type = OLED_128x32;

        }



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][4] == 2)

        {

          Plugin_023_OLED_font_width = Size_optimized;

        }



        Plugin_023_StartUp_OLED();

        Plugin_023_clear_display();

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2)

        {

          Plugin_023_OLED_type |= OLED_rotated;

          Plugin_023_sendcommand(0xA0 | 0x1);

          Plugin_023_sendcommand(0xC8);

        }

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3] == 2)

        {

          Plugin_023_OLED_type |= OLED_64x48;

        }



        Plugin_023_sendStrXY("ESP Easy ", 0, 0);

        displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            Plugin_023_displayOn();

            displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if ( displayTimer > 0)

        {

          displayTimer--;

          if (displayTimer == 0)

            Plugin_023_displayOff();

        }

        break;

      }



    case PLUGIN_READ:

      {

        char deviceTemplate[8][64];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte x = 0; x < 8; x++)

        {

          String tmpString = deviceTemplate[x];

          if (tmpString.length())

          {

            String newString = P023_parseTemplate(tmpString, 16);

            Plugin_023_sendStrXY(newString.c_str(), x, 0);

          }

        }

        success = false;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);

        if (tmpString.equalsIgnoreCase(F("OLEDCMD")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          if (tmpString.equalsIgnoreCase(F("Off")))

            Plugin_023_displayOff();

          else if (tmpString.equalsIgnoreCase(F("On")))

            Plugin_023_displayOn();

          else if (tmpString.equalsIgnoreCase(F("Clear")))

            Plugin_023_clear_display();

        }

        else if (tmpString.equalsIgnoreCase(F("OLED")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          String newString = P023_parseTemplate(tmpString, 16);

          Plugin_023_sendStrXY(newString.c_str(), event->Par1 - 1, event->Par2 - 1);

        }

        break;

      }

  }

  return success;

}



const char Plugin_023_myFont_Size[] PROGMEM = {

  0x05,

  0x05,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x06,

  0x06,

  0x08,

  0x08,

  0x05,

  0x08,

  0x05,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x06,

  0x07,

  0x08,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x08,

  0x06,

  0x08,

  0x08,

  0x06,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x05,

  0x06,

  0x07,

  0x06,

  0x08,

  0x07,

  0x07,

  0x07,

  0x07,

  0x07,

  0x07,

  0x06,

  0x07,

  0x08,

  0x08,

  0x08,

  0x07,

  0x08,

  0x06,

  0x05,

  0x06,

  0x08,

  0x08

};





String P023_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);

  const char degree[3] = {0xc2, 0xb0, 0};

  const char degree_oled[2] = {0x7F, 0};

  result.replace(degree, degree_oled);

  return result;

}







const char Plugin_023_myFont[][8] PROGMEM = {

  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00},

  {0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00},

  {0x00, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00},

  {0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00},

  {0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00},

  {0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00, 0x00},

  {0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00},

  {0x00, 0xA0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00},

  {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00},

  {0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00},

  {0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00},

  {0x00, 0x62, 0x51, 0x49, 0x49, 0x46, 0x00, 0x00},

  {0x00, 0x22, 0x41, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00},

  {0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00},

  {0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00},

  {0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00},

  {0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00},

  {0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0xAC, 0x6C, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},

  {0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00},

  {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00},

  {0x00, 0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00},

  {0x00, 0x7E, 0x09, 0x09, 0x09, 0x7E, 0x00, 0x00},

  {0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00},

  {0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00},

  {0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x51, 0x72, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00},

  {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00},

  {0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},

  {0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00},

  {0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00},

  {0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00},

  {0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00},

  {0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00},

  {0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00},

  {0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00},

  {0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00},

  {0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00},

  {0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00},

  {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00},

  {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00},

  {0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00},

  {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00},

  {0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00},

  {0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00},

  {0x00, 0x08, 0x7E, 0x09, 0x02, 0x00, 0x00, 0x00},

  {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},

  {0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00},

  {0x00, 0x7C, 0x08, 0x04, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00},

  {0x00, 0xFC, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00},

  {0x00, 0x18, 0x24, 0x24, 0xFC, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x7C, 0x08, 0x04, 0x00, 0x00, 0x00},

  {0x00, 0x48, 0x54, 0x54, 0x24, 0x00, 0x00, 0x00},

  {0x00, 0x04, 0x7F, 0x44, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x3C, 0x40, 0x40, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00},

  {0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00},

  {0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00},

  {0x00, 0x1C, 0xA0, 0xA0, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00},

  {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00},

  {0x00, 0x02, 0x05, 0x05, 0x02, 0x00, 0x00, 0x00}

};



void Plugin_023_reset_display(void)

{

  Plugin_023_displayOff();

  Plugin_023_clear_display();

  Plugin_023_displayOn();

}





void Plugin_023_StartUp_OLED()

{

  Plugin_023_init_OLED();

  Plugin_023_reset_display();

  Plugin_023_displayOff();

  Plugin_023_setXY(0, 0);

  Plugin_023_clear_display();

  Plugin_023_displayOn();

}





void Plugin_023_displayOn(void)

{

  Plugin_023_sendcommand(0xaf);

}





void Plugin_023_displayOff(void)

{

  Plugin_023_sendcommand(0xae);

}





void Plugin_023_clear_display(void)

{

  unsigned char i, k;

  for (k = 0; k < 8; k++)

  {

    Plugin_023_setXY(k, 0);

    {

      for (i = 0; i < 128; i++)

      {

        Plugin_023_SendChar(0);

      }

    }

  }

}







void Plugin_023_SendChar(unsigned char data)

{

  Wire.beginTransmission(Plugin_023_OLED_address);

  Wire.write(0x40);

  Wire.write(data);

  Wire.endTransmission();

}
# 1039 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P023_OLED.ino"
void Plugin_023_sendcommand(unsigned char com)

{

  Wire.beginTransmission(Plugin_023_OLED_address);

  Wire.write(0x80);

  Wire.write(com);

  Wire.endTransmission();

}
# 1061 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P023_OLED.ino"
void Plugin_023_setXY(unsigned char row, unsigned char col)

{

  switch (Plugin_023_OLED_type)

  {

    case OLED_64x48:

      col += 4;

      break;

    case OLED_64x48 | OLED_rotated:

      col += 4;

      row += 2;

  }



  Plugin_023_sendcommand(0xb0 + row);

  Plugin_023_sendcommand(0x00 + (8 * col & 0x0f));

  Plugin_023_sendcommand(0x10 + ((8 * col >> 4) & 0x0f));

}
# 1133 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P023_OLED.ino"
void Plugin_023_sendStrXY(const char *string, int X, int Y)

{

  Plugin_023_setXY(X, Y);

  unsigned char i = 0;

  unsigned char font_width = 0;



  while (*string)

  {

    switch (Plugin_023_OLED_font_width)

    {

      case Size_optimized:

        font_width = pgm_read_byte(&(Plugin_023_myFont_Size[*string - 0x20]));

        break;

      default:

        font_width = 8;

    }



    for (i = 0; i < font_width; i++)

    {

      Plugin_023_SendChar(pgm_read_byte(Plugin_023_myFont[*string - 0x20] + i));

    }

    string++;

  }

}





void Plugin_023_init_OLED(void)

{

  unsigned char multiplex;

  unsigned char compins;

  switch (Plugin_023_OLED_type)

  {

    case OLED_128x32:

      multiplex = 0x1F;

      compins = 0x02;

      break;

    default:

      multiplex = 0x3F;

      compins = 0x12;

  }



  Plugin_023_sendcommand(0xAE);

  Plugin_023_sendcommand(0xD5);

  Plugin_023_sendcommand(0x80);

  Plugin_023_sendcommand(0xA8);

  Plugin_023_sendcommand(multiplex);

  Plugin_023_sendcommand(0xD3);

  Plugin_023_sendcommand(0x00);

  Plugin_023_sendcommand(0x40 | 0x0);

  Plugin_023_sendcommand(0x8D);

  Plugin_023_sendcommand(0x14);

  Plugin_023_sendcommand(0x20);

  Plugin_023_sendcommand(0x00);

  Plugin_023_sendcommand(0xA0);

  Plugin_023_sendcommand(0xC0);

  Plugin_023_sendcommand(0xDA);

  Plugin_023_sendcommand(compins);

  Plugin_023_sendcommand(0x81);

  Plugin_023_sendcommand(0xCF);

  Plugin_023_sendcommand(0xD9);

  Plugin_023_sendcommand(0xF1);

  Plugin_023_sendcommand(0xDB);

  Plugin_023_sendcommand(0x40);

  Plugin_023_sendcommand(0xA4);

  Plugin_023_sendcommand(0xA6);



  Plugin_023_clear_display();

  Plugin_023_sendcommand(0x2E);

  Plugin_023_sendcommand(0x20);

  Plugin_023_sendcommand(0x00);



}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P024_MLX90614.ino"
#ifdef USES_P024
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P024_MLX90614.ino"
#define PLUGIN_024 

#define PLUGIN_ID_024 24

#define PLUGIN_NAME_024 "Environment - MLX90614"

#define PLUGIN_VALUENAME1_024 "Temperature"



boolean Plugin_024_init = false;



uint16_t readRegister024(uint8_t i2cAddress, uint8_t reg) {

  uint16_t ret;

  Wire.beginTransmission(i2cAddress);

  Wire.write(reg);

  Wire.endTransmission(false);

  Wire.requestFrom(i2cAddress, (uint8_t)3);

  ret = Wire.read();

  ret |= Wire.read() << 8;

  Wire.read();

  return ret;

}



float readTemp024(uint8_t i2c_addr, uint8_t i2c_reg)

{

  float temp;

  temp = readRegister024(i2c_addr, i2c_reg);

  temp *= .02;

  temp -= 273.15;

  return temp;

}



boolean Plugin_024(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_024;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 16;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_024);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_024));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #define MLX90614_OPTION 2



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[MLX90614_OPTION];

        int optionValues[MLX90614_OPTION];

        optionValues[0] = (0x07);

        options[0] = F("IR object temperature");

        optionValues[1] = (0x06);

        options[1] = F("Ambient temperature");

        addFormSelector(F("Option"), F("plugin_024_option"), MLX90614_OPTION, options, optionValues, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_024_option"));

        Plugin_024_init = false;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_024_init = true;
# 205 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P024_MLX90614.ino"
        success = true;

        break;

      }



    case PLUGIN_READ:

      {







        byte unit = Settings.TaskDevicePort[event->TaskIndex];

        uint8_t address = 0x5A + unit;

        UserVar[event->BaseVarIndex] = (float) readTemp024(address, Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        String log = F("MLX90614  : Temperature: ");

        log += UserVar[event->BaseVarIndex];



        addLog(LOG_LEVEL_INFO,log);

        success = true;



        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P025_ADS1115.ino"
#ifdef USES_P025
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P025_ADS1115.ino"
#define PLUGIN_025 

#define PLUGIN_ID_025 25

#define PLUGIN_NAME_025 "Analog input - ADS1115"

#define PLUGIN_VALUENAME1_025 "Analog"



boolean Plugin_025_init = false;



uint16_t readRegister025(uint8_t i2cAddress, uint8_t reg) {

  Wire.beginTransmission(i2cAddress);

  Wire.write((0x00));

  Wire.endTransmission();

  if (Wire.requestFrom(i2cAddress, (uint8_t)2) != 2)

    return 0x8000;

  return ((Wire.read() << 8) | Wire.read());

}



boolean Plugin_025(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_025;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_025);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_025));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte port = Settings.TaskDevicePort[event->TaskIndex];

        if (port > 0)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = Settings.TaskDevicePluginConfig[event->TaskIndex][0] / 2;

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = 0x48 + ((port-1)/4);

          Settings.TaskDevicePluginConfig[event->TaskIndex][2] = ((port-1) & 3) | 4;

          Settings.TaskDevicePort[event->TaskIndex] = 0;

        }



        #define ADS1115_I2C_OPTION 4

        byte addr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        int optionValues[ADS1115_I2C_OPTION] = { 0x48, 0x49, 0x4A, 0x4B };

        addFormSelectorI2C(F("plugin_025_i2c"), ADS1115_I2C_OPTION, optionValues, addr);



        addFormSubHeader(F("Input"));



        #define ADS1115_PGA_OPTION 6

        byte pga = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String pgaOptions[ADS1115_PGA_OPTION] = {

          F("2/3x gain (FS=6.144V)"),

          F("1x gain (FS=4.096V)"),

          F("2x gain (FS=2.048V)"),

          F("4x gain (FS=1.024V)"),

          F("8x gain (FS=0.512V)"),

          F("16x gain (FS=0.256V)")

        };

        addFormSelector(F("Gain"), F("plugin_025_gain"), ADS1115_PGA_OPTION, pgaOptions, NULL, pga);



        #define ADS1115_MUX_OPTION 8

        byte mux = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String muxOptions[ADS1115_MUX_OPTION] = {

          F("AIN0 - AIN1 (Differential)"),

          F("AIN0 - AIN3 (Differential)"),

          F("AIN1 - AIN3 (Differential)"),

          F("AIN2 - AIN3 (Differential)"),

          F("AIN0 - GND (Single-Ended)"),

          F("AIN1 - GND (Single-Ended)"),

          F("AIN2 - GND (Single-Ended)"),

          F("AIN3 - GND (Single-Ended)"),

        };

        addFormSelector(F("Input Multiplexer"), F("plugin_025_mode"), ADS1115_MUX_OPTION, muxOptions, NULL, mux);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_025_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("plugin_025_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], -32768, 32767);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_025_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_025_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], -32768, 32767);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_025_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_025_i2c"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_025_gain"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_025_mode"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_025_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_025_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_025_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_025_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_025_out2"));



        Plugin_025_init = false;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_025_init = true;

        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 301 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P025_ADS1115.ino"
        uint8_t address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        uint16_t config = (0x0003) |

                          (0x0000) |

                          (0x0000) |

                          (0x0000) |

                          (0x0080) |

                          (0x0100);



        uint16_t pga = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        config |= pga << 9;



        uint16_t mux = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        config |= mux << 12;



        config |= (0x8000);



        Wire.beginTransmission(address);

        Wire.write((uint8_t)(0x01));

        Wire.write((uint8_t)(config >> 8));

        Wire.write((uint8_t)(config & 0xFF));

        Wire.endTransmission();



        String log = F("ADS1115 : Analog value: ");



        delay(8);

        int16_t value = readRegister025((address), (0x00));

        UserVar[event->BaseVarIndex] = (float)value;

        log += value;



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(value - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" ");

            log += UserVar[event->BaseVarIndex];

          }

        }







        addLog(LOG_LEVEL_DEBUG,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P026_Sysinfo.ino"
#ifdef USES_P026
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P026_Sysinfo.ino"
#define PLUGIN_026 

#define PLUGIN_ID_026 26

#define PLUGIN_NAME_026 "Generic - System Info"

#define PLUGIN_VALUENAME1_026 ""



boolean Plugin_026(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_026;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].FormulaOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_026);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_026));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[10];

        options[0] = F("Uptime");

        options[1] = F("Free RAM");

        options[2] = F("Wifi RSSI");

        options[3] = F("Input VCC");

        options[4] = F("System load");

        options[5] = F("IP 1.Octet");

        options[6] = F("IP 2.Octet");

        options[7] = F("IP 3.Octet");

        options[8] = F("IP 4.Octet");

        options[9] = F("Web activity");

        addFormSelector(F("Indicator"), F("plugin_026"), 10, options, NULL, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_026"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        float value = 0;

        switch(Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

          case 0:

          {

            value = (wdcounter /2);

            break;

          }

          case 1:

          {

            value = ESP.getFreeHeap();

            break;

          }

          case 2:

          {

            value = WiFi.RSSI();

            break;

          }

          case 3:

          {

#if FEATURE_ADC_VCC

            value = vcc;

#else

            value = -1.0;

#endif

            break;

          }

          case 4:

          {

            value = (100 - (100 * loopCounterLast / loopCounterMax));

            break;

          }

          case 5:

          {

            value = WiFi.localIP()[0];

            break;

          }

          case 6:

          {

            value = WiFi.localIP()[1];

            break;

          }

          case 7:

          {

            value = WiFi.localIP()[2];

            break;

          }

          case 8:

          {

            value = WiFi.localIP()[3];

            break;

          }

          case 9:

          {

            value = (millis()-lastWeb)/1000;

            break;

          }

        }

        UserVar[event->BaseVarIndex] = value;

        String log = F("SYS  : ");

        log += value;

        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
#ifdef USES_P027
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
#define PLUGIN_027 

#define PLUGIN_ID_027 27

#define PLUGIN_NAME_027 "Energy (DC) - INA219"

#define PLUGIN_VALUENAME1_027 "Voltage"

#define PLUGIN_VALUENAME2_027 "Current"

#define PLUGIN_VALUENAME3_027 "Power"
# 31 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
#define INA219_ADDRESS (0x40)

#define INA219_ADDRESS2 (0x41)

#define INA219_ADDRESS3 (0x44)

#define INA219_ADDRESS4 (0x45)

#define INA219_READ (0x01)

#define INA219_REG_CONFIG (0x00)

#define INA219_CONFIG_RESET (0x8000)



#define INA219_CONFIG_BVOLTAGERANGE_MASK (0x2000)

#define INA219_CONFIG_BVOLTAGERANGE_16V (0x0000)

#define INA219_CONFIG_BVOLTAGERANGE_32V (0x2000)



#define INA219_CONFIG_GAIN_MASK (0x1800)

#define INA219_CONFIG_GAIN_1_40MV (0x0000)

#define INA219_CONFIG_GAIN_2_80MV (0x0800)

#define INA219_CONFIG_GAIN_4_160MV (0x1000)

#define INA219_CONFIG_GAIN_8_320MV (0x1800)



#define INA219_CONFIG_BADCRES_MASK (0x0780)

#define INA219_CONFIG_BADCRES_9BIT (0x0080)

#define INA219_CONFIG_BADCRES_10BIT (0x0100)

#define INA219_CONFIG_BADCRES_11BIT (0x0200)

#define INA219_CONFIG_BADCRES_12BIT (0x0400)



#define INA219_CONFIG_SADCRES_MASK (0x0078)

#define INA219_CONFIG_SADCRES_9BIT_1S_84US (0x0000)

#define INA219_CONFIG_SADCRES_10BIT_1S_148US (0x0008)

#define INA219_CONFIG_SADCRES_11BIT_1S_276US (0x0010)

#define INA219_CONFIG_SADCRES_12BIT_1S_532US (0x0018)

#define INA219_CONFIG_SADCRES_12BIT_2S_1060US (0x0048)

#define INA219_CONFIG_SADCRES_12BIT_4S_2130US (0x0050)

#define INA219_CONFIG_SADCRES_12BIT_8S_4260US (0x0058)

#define INA219_CONFIG_SADCRES_12BIT_16S_8510US (0x0060)

#define INA219_CONFIG_SADCRES_12BIT_32S_17MS (0x0068)

#define INA219_CONFIG_SADCRES_12BIT_64S_34MS (0x0070)

#define INA219_CONFIG_SADCRES_12BIT_128S_69MS (0x0078)



#define INA219_CONFIG_MODE_MASK (0x0007)

#define INA219_CONFIG_MODE_POWERDOWN (0x0000)

#define INA219_CONFIG_MODE_SVOLT_TRIGGERED (0x0001)

#define INA219_CONFIG_MODE_BVOLT_TRIGGERED (0x0002)

#define INA219_CONFIG_MODE_SANDBVOLT_TRIGGERED (0x0003)

#define INA219_CONFIG_MODE_ADCOFF (0x0004)

#define INA219_CONFIG_MODE_SVOLT_CONTINUOUS (0x0005)

#define INA219_CONFIG_MODE_BVOLT_CONTINUOUS (0x0006)

#define INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS (0x0007)



#define INA219_REG_SHUNTVOLTAGE (0x01)

#define INA219_REG_BUSVOLTAGE (0x02)

#define INA219_REG_POWER (0x03)

#define INA219_REG_CURRENT (0x04)

#define INA219_REG_CALIBRATION (0x05)



typedef struct {

  uint32_t calValue;





  uint32_t currentDivider_mA;

} ina219_data;



ina219_data _ina219_data[4];

int Plugin_27_i2c_addresses[4] = { INA219_ADDRESS, INA219_ADDRESS2, INA219_ADDRESS3, INA219_ADDRESS4 };



uint8_t Plugin_027_i2c_addr(struct EventStruct *event) {

   return (uint8_t)Settings.TaskDevicePluginConfig[event->TaskIndex][1];

}



uint8_t Plugin_027_device_index(const uint8_t i2caddr) {

  switch(i2caddr) {

    case INA219_ADDRESS: return 0u;

    case INA219_ADDRESS2: return 1u;

    case INA219_ADDRESS3: return 2u;

    case INA219_ADDRESS4: return 3u;

  }

  return 0u;

}



boolean Plugin_027(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_027;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_027);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_027));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_027));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_027));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String optionsMode[3];

        optionsMode[0] = F("32V, 2A");

        optionsMode[1] = F("32V, 1A");

        optionsMode[2] = F("16V, 0.4A");

        int optionValuesMode[3];

        optionValuesMode[0] = 0;

        optionValuesMode[1] = 1;

        optionValuesMode[2] = 2;

        addFormSelector(F("Measure range"), F("plugin_027_range"), 3, optionsMode, optionValuesMode, choiceMode);



        addFormSelectorI2C(F("plugin_027_i2c"), 4, Plugin_27_i2c_addresses, Plugin_027_i2c_addr(event));



        byte choiceMeasureType = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options[4] = { F("Voltage"), F("Current"), F("Power"), F("Voltage/Current/Power") };

        addFormSelector(F("Measurement Type"), F("plugin_027_measuretype"), 4, options, NULL, choiceMeasureType );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_027_range"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_027_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_027_measuretype"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

       const uint8_t i2caddr = Plugin_027_i2c_addr(event);

        const uint8_t idx = Plugin_027_device_index(i2caddr);

        _ina219_data[idx].currentDivider_mA = 0;

        String log = F("INA219 0x");

        log += String(i2caddr,HEX);

        log += F(" setting Range to: ");

        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

        case 0:

        {

            log += F("32V, 2A");

          Plugin_027_setCalibration_32V_2A(i2caddr);

         break;

        }

        case 1:

        {

            log += F("32V, 1A");

         Plugin_027_setCalibration_32V_1A(i2caddr);

         break;

        }

        case 2:

        {

            log += F("16V, 400mA");

         Plugin_027_setCalibration_16V_400mA(i2caddr);

         break;

        }

        }

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 403 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
        const uint8_t i2caddr = Plugin_027_i2c_addr(event);



    float voltage = Plugin_027_getBusVoltage_V(i2caddr) + (Plugin_027_getShuntVoltage_mV(i2caddr) / 1000);

    float current = Plugin_027_getCurrent_mA(i2caddr)/1000;

    float power = voltage * current;



        UserVar[event->BaseVarIndex] = voltage;

       UserVar[event->BaseVarIndex + 1] = current;

       UserVar[event->BaseVarIndex + 2] = power;



       String log = F("INA219 0x");

       log += String(i2caddr,HEX);







        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][2])

        {

          case 0:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = voltage;

           log += F(": Voltage: ");

           log += voltage;

            break;

          }

          case 1:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = current;

           log += F(" Current: ");

           log += current;

            break;

          }

          case 2:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = power;

           log += F(" Power: ");

           log += power;

            break;

          }

          case 3:

          {

            event->sensorType = SENSOR_TYPE_TRIPLE;

            UserVar[event->BaseVarIndex] = voltage;

            UserVar[event->BaseVarIndex+1] = current;

            UserVar[event->BaseVarIndex+2] = power;

           log += F(": Voltage: ");

           log += voltage;

           log += F(" Current: ");

           log += current;

           log += F(" Power: ");

           log += power;

            break;

          }

        }



        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}
# 539 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
void Plugin_027_wireWriteRegister (uint8_t i2caddr, uint8_t reg, uint16_t value)

{

  Wire.beginTransmission(i2caddr);

  Wire.write(reg);

  Wire.write((value >> 8) & 0xFF);

  Wire.write(value & 0xFF);

  Wire.endTransmission();

}
# 563 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
void Plugin_027_wireReadRegister(uint8_t i2caddr, uint8_t reg, uint16_t *value)

{



  Wire.beginTransmission(i2caddr);

  Wire.write(reg);

  Wire.endTransmission();



  delay(1);



  Wire.requestFrom(i2caddr, (uint8_t)2);



  *value = ((Wire.read() << 8) | Wire.read());

}
# 597 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
void Plugin_027_setCalibration_32V_2A(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  _ina219_data[idx].calValue = 4027;





  _ina219_data[idx].currentDivider_mA = 10;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_32V |

                    INA219_CONFIG_GAIN_8_320MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 641 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
void Plugin_027_setCalibration_32V_1A(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  _ina219_data[idx].calValue = 10240;





  _ina219_data[idx].currentDivider_mA = 25;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_32V |

                    INA219_CONFIG_GAIN_8_320MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 685 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
void Plugin_027_setCalibration_16V_400mA(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);



  _ina219_data[idx].calValue = 8192;





  _ina219_data[idx].currentDivider_mA = 20;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_16V |

                    INA219_CONFIG_GAIN_1_40MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 733 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
int16_t Plugin_027_getBusVoltage_raw(uint8_t i2caddr) {

  uint16_t value;

  Plugin_027_wireReadRegister(i2caddr, INA219_REG_BUSVOLTAGE, &value);





  return (int16_t)((value >> 3) * 4);

}
# 755 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
int16_t Plugin_027_getShuntVoltage_raw(uint8_t i2caddr) {

  uint16_t value;

  Plugin_027_wireReadRegister(i2caddr, INA219_REG_SHUNTVOLTAGE, &value);

  return (int16_t)value;

}
# 773 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
int16_t Plugin_027_getCurrent_raw(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  uint16_t value;
# 789 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  Plugin_027_wireReadRegister(i2caddr, INA219_REG_CURRENT, &value);



  return (int16_t)value;

}
# 811 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
float Plugin_027_getShuntVoltage_mV(uint8_t i2caddr) {

  int16_t value;

  value = Plugin_027_getShuntVoltage_raw(i2caddr);

  return value * 0.01;

}
# 829 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
float Plugin_027_getBusVoltage_V(uint8_t i2caddr) {

  int16_t value = Plugin_027_getBusVoltage_raw(i2caddr);

  return value * 0.001;

}
# 847 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P027_INA219.ino"
float Plugin_027_getCurrent_mA(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  float valueDec = Plugin_027_getCurrent_raw(i2caddr);

  valueDec /= _ina219_data[idx].currentDivider_mA;

  return valueDec;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
#ifdef USES_P028
# 15 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
#define PLUGIN_028 

#define PLUGIN_ID_028 28

#define PLUGIN_NAME_028 "Environment - BMx280"

#define PLUGIN_VALUENAME1_028 "Temperature"

#define PLUGIN_VALUENAME2_028 "Humidity"

#define PLUGIN_VALUENAME3_028 "Pressure"



#define PLUGIN_028_BME280_DEVICE "BME280"

#define PLUGIN_028_BMP280_DEVICE "BMP280"





#define BMx280_MEASUREMENT_INTERVAL_MSEC 50000



#define BMx280_REGISTER_DIG_T1 0x88

#define BMx280_REGISTER_DIG_T2 0x8A

#define BMx280_REGISTER_DIG_T3 0x8C



#define BMx280_REGISTER_DIG_P1 0x8E

#define BMx280_REGISTER_DIG_P2 0x90

#define BMx280_REGISTER_DIG_P3 0x92

#define BMx280_REGISTER_DIG_P4 0x94

#define BMx280_REGISTER_DIG_P5 0x96

#define BMx280_REGISTER_DIG_P6 0x98

#define BMx280_REGISTER_DIG_P7 0x9A

#define BMx280_REGISTER_DIG_P8 0x9C

#define BMx280_REGISTER_DIG_P9 0x9E



#define BMx280_REGISTER_DIG_H1 0xA1

#define BMx280_REGISTER_DIG_H2 0xE1

#define BMx280_REGISTER_DIG_H3 0xE3

#define BMx280_REGISTER_DIG_H4 0xE4

#define BMx280_REGISTER_DIG_H5 0xE5

#define BMx280_REGISTER_DIG_H6 0xE7



#define BMx280_REGISTER_CHIPID 0xD0

#define BMx280_REGISTER_VERSION 0xD1

#define BMx280_REGISTER_SOFTRESET 0xE0



#define BMx280_REGISTER_CAL26 0xE1



#define BMx280_REGISTER_CONTROLHUMID 0xF2

#define BMx280_REGISTER_STATUS 0xF3

#define BMx280_REGISTER_CONTROL 0xF4

#define BMx280_REGISTER_CONFIG 0xF5

#define BMx280_REGISTER_PRESSUREDATA 0xF7

#define BMx280_REGISTER_TEMPDATA 0xFA

#define BMx280_REGISTER_HUMIDDATA 0xFD



#define BME280_CONTROL_SETTING_HUMIDITY 0x02



typedef struct

{

  uint16_t dig_T1;

  int16_t dig_T2;

  int16_t dig_T3;



  uint16_t dig_P1;

  int16_t dig_P2;

  int16_t dig_P3;

  int16_t dig_P4;

  int16_t dig_P5;

  int16_t dig_P6;

  int16_t dig_P7;

  int16_t dig_P8;

  int16_t dig_P9;



  uint8_t dig_H1;

  int16_t dig_H2;

  uint8_t dig_H3;

  int16_t dig_H4;

  int16_t dig_H5;

  int8_t dig_H6;

} bme280_calib_data;



bme280_calib_data _bme280_calib[2];

boolean Plugin_028_init[2] = {false, false};

int Plugin_28_i2c_addresses[2] = { 0x76, 0x77 };



uint8_t _i2caddr;

int32_t t_fine;



static float last_hum_val[2] = {0.0, 0.0};

static float last_press_val[2] = {0.0, 0.0};

static float last_temp_val[2] = {0.0, 0.0};

static float last_dew_temp_val[2] = {0.0, 0.0};

static unsigned long last_measurement[2] = {0, 0};



enum BMx_ChipId {

  Unknown_DEVICE = 0,

  BMP280_DEVICE_SAMPLE1 = 0x56,

  BMP280_DEVICE_SAMPLE2 = 0x57,

  BMP280_DEVICE = 0x58,

  BME280_DEVICE = 0x60

};



BMx_ChipId _sensorID[2] = {Unknown_DEVICE, Unknown_DEVICE};



byte Plugin_028_get_config_settings() {

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  switch (_sensorID[idx]) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE: return 0x28;

    case BME280_DEVICE: return 0x28;

    default: return 0;

  }

}



byte Plugin_028_get_control_settings() {

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  switch (_sensorID[idx]) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE: return 0x93;

    case BME280_DEVICE: return 0x93;

    default: return 0;

  }

}



String Plugin_028_getFullDeviceName() {

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  String devicename = Plugin_028_getDeviceName();

  if (_sensorID[idx] == BMP280_DEVICE_SAMPLE1 ||

      _sensorID[idx] == BMP280_DEVICE_SAMPLE2)

  {

    devicename += F(" sample");

  }

  return devicename;

}



String Plugin_028_getDeviceName() {

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  switch (_sensorID[idx]) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE: return F(PLUGIN_028_BMP280_DEVICE);

    case BME280_DEVICE: return F(PLUGIN_028_BME280_DEVICE);

    default: return F("Unknown");

  }



}



boolean Plugin_028_hasHumidity() {

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  switch (_sensorID[idx]) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE: return false;

    case BME280_DEVICE: return true;

    default: return false;

  }



}



uint8_t Plugin_028_read8(byte reg, bool * is_ok = NULL);



uint8_t Plugin_028_i2c_addr(struct EventStruct *event) {

  _i2caddr = (uint8_t)Settings.TaskDevicePluginConfig[event->TaskIndex][0];

  if (_i2caddr != Plugin_28_i2c_addresses[0] && _i2caddr != Plugin_28_i2c_addresses[1]) {



    _i2caddr = Plugin_28_i2c_addresses[0];

  }

  return _i2caddr;

}



uint8_t Plugin_028_device_index(const uint8_t i2cAddress) {

  return i2cAddress & 0x1;

}



boolean Plugin_028(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_028;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_028);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_028));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_028));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_028));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        addFormSelectorI2C(F("plugin_028_bme280_i2c"), 2, Plugin_28_i2c_addresses, i2cAddress);

        const uint8_t idx = Plugin_028_device_index(i2cAddress);

        if (_sensorID[idx] != Unknown_DEVICE) {

          String detectedString = F("Detected: ");

          detectedString += Plugin_028_getFullDeviceName();

          addUnit(detectedString);

        }

        addFormNote(F("SDO Low=0x76, High=0x77"));



        addFormNumericBox(F("Altitude"), F("plugin_028_bme280_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("m"));



        addFormNumericBox(F("Temperature offset"), F("plugin_028_bme280_tempoffset"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        addUnit(F("x 0.1C"));

        String offsetNote = F("Offset in units of 0.1 degree Celcius");

        if (Plugin_028_hasHumidity()) {

          offsetNote += F(" (also correct humidity)");

        }

        addFormNote(offsetNote);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        const uint8_t i2cAddress = getFormItemInt(F("plugin_028_bme280_i2c"));

        Plugin_028_check(i2cAddress);

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = i2cAddress;

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_028_bme280_elev"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_028_bme280_tempoffset"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        const uint8_t idx = Plugin_028_device_index(i2cAddress);

        const float tempOffset = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 10.0;

        if (!Plugin_028_update_measurements(i2cAddress, tempOffset)) {

          success = false;

          break;

        }

        UserVar[event->BaseVarIndex] = last_temp_val[idx];

        UserVar[event->BaseVarIndex + 1] = last_hum_val[idx];

        const int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        if (elev) {

           UserVar[event->BaseVarIndex + 2] = Plugin_028_pressureElevation(last_press_val[idx], elev);

        } else {

           UserVar[event->BaseVarIndex + 2] = last_press_val[idx];

        }

        String log;

        log.reserve(40);

        log = Plugin_028_getDeviceName();

        log += F(" : Address: 0x");

        log += String(_i2caddr,HEX);

        addLog(LOG_LEVEL_INFO, log);

        log = Plugin_028_getDeviceName();

        log += F(" : Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        if (Plugin_028_hasHumidity()) {

          log = Plugin_028_getDeviceName();

          log += F(" : Humidity: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);

        }

        log = Plugin_028_getDeviceName();

        log += F(" : Barometric Pressure: ");

        log += UserVar[event->BaseVarIndex + 2];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



  }

  return success;

}





bool Plugin_028_update_measurements(uint8_t i2cAddress, float tempOffset) {

  const uint8_t idx = Plugin_028_device_index(i2cAddress);

  const unsigned long current_time = millis();

  if ((last_measurement[idx] > BMx280_MEASUREMENT_INTERVAL_MSEC) &&

      (current_time < (last_measurement[idx] + BMx280_MEASUREMENT_INTERVAL_MSEC)) &&

      (current_time > last_measurement[idx])) {



    return false;

  }

  Plugin_028_init[idx] &= Plugin_028_check(i2cAddress);

  if (!Plugin_028_init[idx]) {

    Plugin_028_init[idx] = Plugin_028_begin(i2cAddress);

  }



  if (Plugin_028_init[idx]) {

    last_measurement[idx] = current_time;



    Plugin_028_write8(BMx280_REGISTER_CONTROL, 0x00);

    if (Plugin_028_hasHumidity()) {

      Plugin_028_write8(BMx280_REGISTER_CONTROLHUMID, BME280_CONTROL_SETTING_HUMIDITY);

    }

    Plugin_028_write8(BMx280_REGISTER_CONFIG, Plugin_028_get_config_settings());

    Plugin_028_write8(BMx280_REGISTER_CONTROL, Plugin_028_get_control_settings());





    delay(1000);



    last_temp_val[idx] = Plugin_028_readTemperature(i2cAddress);

    last_press_val[idx] = ((float)Plugin_028_readPressure(i2cAddress)) / 100;

    last_hum_val[idx] = ((float)Plugin_028_readHumidity(i2cAddress));





    Plugin_028_write8(BMx280_REGISTER_CONTROL, 0x00);



    String log;

    log.reserve(120);

    log = Plugin_028_getDeviceName();

    log += F(":");

    boolean logAdded = false;

    if (Plugin_028_hasHumidity()) {





      last_dew_temp_val[idx] = compute_dew_point_temp(last_temp_val[idx] + (tempOffset / 2.0), last_hum_val[idx]);

    } else {



      last_dew_temp_val[idx] = last_temp_val[idx];

    }

    if (tempOffset > 0.1 || tempOffset < -0.1) {



      log += F(" Apply temp offset ");

      log += tempOffset;

      log += F("C");

      if (Plugin_028_hasHumidity()) {

        log += F(" humidity ");

        log += last_hum_val[idx];

        last_hum_val[idx] = compute_humidity_from_dewpoint(last_temp_val[idx] + tempOffset, last_dew_temp_val[idx]);

        log += F("% => ");

        log += last_hum_val[idx];

        log += F("%");

      }

      log += F(" temperature ");

      log += last_temp_val[idx];

      last_temp_val[idx] = last_temp_val[idx] + tempOffset;

      log += F("C => ");

      log += last_temp_val[idx];

      log += F("C");

      logAdded = true;

    }

    if (Plugin_028_hasHumidity()) {

      log += F(" dew point ");

      log += last_dew_temp_val[idx];

      log += F("C");

      logAdded = true;

    }

    if (logAdded)

      addLog(LOG_LEVEL_INFO, log);

    return true;

  }

  return false;

}
# 763 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
bool Plugin_028_check(uint8_t a) {

  _i2caddr = a?a:0x76;

  const uint8_t idx = Plugin_028_device_index(_i2caddr);

  bool wire_status = false;

  const uint8_t chip_id = Plugin_028_read8(BMx280_REGISTER_CHIPID, &wire_status);

  switch (chip_id) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE:

    case BME280_DEVICE: {

      if (wire_status) {



        if (_sensorID[idx] != chip_id) {

          _sensorID[idx] = static_cast<BMx_ChipId>(chip_id);

          String log = F("BMx280 : Detected ");

          log += Plugin_028_getFullDeviceName();

          addLog(LOG_LEVEL_INFO, log);

        }

      } else {

        _sensorID[idx] = Unknown_DEVICE;

      }

      break;

    }

    default:

      _sensorID[idx] = Unknown_DEVICE;

      break;

  }

  if (_sensorID[idx] == Unknown_DEVICE) {

    String log = F("BMx280 : Unable to detect chip ID");

    addLog(LOG_LEVEL_INFO, log);

    return false;

  }

  return wire_status;

}
# 839 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
bool Plugin_028_begin(uint8_t a) {

  if (! Plugin_028_check(a))

    return false;



  Plugin_028_write8(BMx280_REGISTER_SOFTRESET, 0xB6);

  delay(2);

  Plugin_028_readCoefficients(a);

  delay(65);

  return true;

}
# 867 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
void Plugin_028_write8(byte reg, byte value)

{

  Wire.beginTransmission((uint8_t)_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.write((uint8_t)value);

  Wire.endTransmission();

}
# 889 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
uint8_t Plugin_028_read8(byte reg, bool * is_ok)

{

  uint8_t value;



  Wire.beginTransmission((uint8_t)_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  byte count = Wire.requestFrom((uint8_t)_i2caddr, (byte)1);

  if (is_ok != NULL) { *is_ok = (count == 1); }

  value = Wire.read();

  Wire.endTransmission();

  return value;

}
# 923 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
uint16_t Plugin_028_read16(byte reg)

{

  uint16_t value;



  Wire.beginTransmission((uint8_t)_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)_i2caddr, (byte)2);

  value = (Wire.read() << 8) | Wire.read();

  Wire.endTransmission();



  return value;

}
# 957 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
int32_t Plugin_028_read24(byte reg)

{

  int32_t value;



  Wire.beginTransmission((uint8_t)_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)_i2caddr, (byte)3);

  value = (((int32_t)Wire.read()) << 16) | (Wire.read() << 8) | Wire.read();

  Wire.endTransmission();



  return value;

}
# 991 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
uint16_t Plugin_028_read16_LE(byte reg) {

  uint16_t temp = Plugin_028_read16(reg);

  return (temp >> 8) | (temp << 8);



}
# 1009 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
int16_t Plugin_028_readS16(byte reg)

{

  return (int16_t)Plugin_028_read16(reg);



}



int16_t Plugin_028_readS16_LE(byte reg)

{

  return (int16_t)Plugin_028_read16_LE(reg);



}
# 1039 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
void Plugin_028_readCoefficients(uint8_t i2cAddress)

{

  const uint8_t idx = Plugin_028_device_index(i2cAddress);



  _bme280_calib[idx].dig_T1 = Plugin_028_read16_LE(BMx280_REGISTER_DIG_T1);

  _bme280_calib[idx].dig_T2 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_T2);

  _bme280_calib[idx].dig_T3 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_T3);



  _bme280_calib[idx].dig_P1 = Plugin_028_read16_LE(BMx280_REGISTER_DIG_P1);

  _bme280_calib[idx].dig_P2 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P2);

  _bme280_calib[idx].dig_P3 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P3);

  _bme280_calib[idx].dig_P4 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P4);

  _bme280_calib[idx].dig_P5 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P5);

  _bme280_calib[idx].dig_P6 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P6);

  _bme280_calib[idx].dig_P7 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P7);

  _bme280_calib[idx].dig_P8 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P8);

  _bme280_calib[idx].dig_P9 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_P9);



  if (Plugin_028_hasHumidity()) {

    _bme280_calib[idx].dig_H1 = Plugin_028_read8(BMx280_REGISTER_DIG_H1);

    _bme280_calib[idx].dig_H2 = Plugin_028_readS16_LE(BMx280_REGISTER_DIG_H2);

    _bme280_calib[idx].dig_H3 = Plugin_028_read8(BMx280_REGISTER_DIG_H3);

    _bme280_calib[idx].dig_H4 = (Plugin_028_read8(BMx280_REGISTER_DIG_H4) << 4) | (Plugin_028_read8(BMx280_REGISTER_DIG_H4 + 1) & 0xF);

    _bme280_calib[idx].dig_H5 = (Plugin_028_read8(BMx280_REGISTER_DIG_H5 + 1) << 4) | (Plugin_028_read8(BMx280_REGISTER_DIG_H5) >> 4);

    _bme280_calib[idx].dig_H6 = (int8_t)Plugin_028_read8(BMx280_REGISTER_DIG_H6);

  }

}
# 1101 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
float Plugin_028_readTemperature(uint8_t i2cAddress)

{

  const uint8_t idx = Plugin_028_device_index(i2cAddress);

  int32_t var1, var2;







  while (Plugin_028_read8(BMx280_REGISTER_STATUS) & 0x08)

    delay(1);



  int32_t adc_T = Plugin_028_read24(BMx280_REGISTER_TEMPDATA);

  adc_T >>= 4;



  var1 = ((((adc_T >> 3) - ((int32_t)_bme280_calib[idx].dig_T1 << 1))) *

           ((int32_t)_bme280_calib[idx].dig_T2)) >> 11;



  var2 = (((((adc_T >> 4) - ((int32_t)_bme280_calib[idx].dig_T1)) *

             ((adc_T >> 4) - ((int32_t)_bme280_calib[idx].dig_T1))) >> 12) *

           ((int32_t)_bme280_calib[idx].dig_T3)) >> 14;



  t_fine = var1 + var2;



  float T = (t_fine * 5 + 128) >> 8;

  return T / 100;

}
# 1159 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
float Plugin_028_readPressure(uint8_t i2cAddress)

{

  const uint8_t idx = Plugin_028_device_index(i2cAddress);

  int64_t var1, var2, p;



  int32_t adc_P = Plugin_028_read24(BMx280_REGISTER_PRESSUREDATA);

  adc_P >>= 4;



  var1 = ((int64_t)t_fine) - 128000;

  var2 = var1 * var1 * (int64_t)_bme280_calib[idx].dig_P6;

  var2 = var2 + ((var1 * (int64_t)_bme280_calib[idx].dig_P5) << 17);

  var2 = var2 + (((int64_t)_bme280_calib[idx].dig_P4) << 35);

  var1 = ((var1 * var1 * (int64_t)_bme280_calib[idx].dig_P3) >> 8) +

         ((var1 * (int64_t)_bme280_calib[idx].dig_P2) << 12);

  var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)_bme280_calib[idx].dig_P1) >> 33;



  if (var1 == 0) {

    return 0;

  }

  p = 1048576 - adc_P;

  p = (((p << 31) - var2) * 3125) / var1;

  var1 = (((int64_t)_bme280_calib[idx].dig_P9) * (p >> 13) * (p >> 13)) >> 25;

  var2 = (((int64_t)_bme280_calib[idx].dig_P8) * p) >> 19;



  p = ((p + var1 + var2) >> 8) + (((int64_t)_bme280_calib[idx].dig_P7) << 4);

  return (float)p / 256;

}
# 1221 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
float Plugin_028_readHumidity(uint8_t i2cAddress)

{

  if (!Plugin_028_hasHumidity()) {



    return 0.0;

  }







  const uint8_t idx = Plugin_028_device_index(i2cAddress);

  unsigned long difTime = millis() - last_measurement[idx];

  if (difTime < 1587) {

    delay(1587 - difTime);

  }

  int32_t adc_H = Plugin_028_read16(BMx280_REGISTER_HUMIDDATA);



  int32_t v_x1_u32r;



  v_x1_u32r = (t_fine - ((int32_t)76800));



  v_x1_u32r = (((((adc_H << 14) - (((int32_t)_bme280_calib[idx].dig_H4) << 20) -

                  (((int32_t)_bme280_calib[idx].dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *

               (((((((v_x1_u32r * ((int32_t)_bme280_calib[idx].dig_H6)) >> 10) *

                    (((v_x1_u32r * ((int32_t)_bme280_calib[idx].dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +

                  ((int32_t)2097152)) * ((int32_t)_bme280_calib[idx].dig_H2) + 8192) >> 14));



  v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *

                             ((int32_t)_bme280_calib[idx].dig_H1)) >> 4));



  v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;

  v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;

  float h = (v_x1_u32r >> 12);

  return h / 1024.0;

}
# 1303 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
float Plugin_028_readAltitude(float seaLevel)

{
# 1321 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
  float atmospheric = Plugin_028_readPressure(_i2caddr) / 100.0F;

  return 44330.0 * (1.0 - pow(atmospheric / seaLevel, 0.1903));

}
# 1335 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P028_BME280.ino"
float Plugin_028_pressureElevation(float atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P029_Output.ino"
#ifdef USES_P029
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P029_Output.ino"
#define PLUGIN_029 

#define PLUGIN_ID_029 29

#define PLUGIN_NAME_029 "Output - Domoticz MQTT Helper"

#define PLUGIN_VALUENAME1_029 "Output"

boolean Plugin_029(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_029;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_029);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_029));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        byte controllerNr = 0;

          for (byte i=0; i < CONTROLLER_MAX; i++)

          {



            if (Settings.Protocol[i] == 2) { controllerNr = i; }

          }



        addHtml(F("<TR><TD>IDX:<TD>"));

        String id = F("TDID");

        id += controllerNr + 1;

        addNumericBox(id, Settings.TaskDeviceID[controllerNr][event->TaskIndex], 0, 9999);

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
#ifdef USES_P030
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
#define PLUGIN_030 

#define PLUGIN_ID_030 30

#define PLUGIN_NAME_030 "Environment - BMP280"

#define PLUGIN_VALUENAME1_030 "Temperature"

#define PLUGIN_VALUENAME2_030 "Pressure"



enum

{

  BMP280_REGISTER_DIG_T1 = 0x88,

  BMP280_REGISTER_DIG_T2 = 0x8A,

  BMP280_REGISTER_DIG_T3 = 0x8C,



  BMP280_REGISTER_DIG_P1 = 0x8E,

  BMP280_REGISTER_DIG_P2 = 0x90,

  BMP280_REGISTER_DIG_P3 = 0x92,

  BMP280_REGISTER_DIG_P4 = 0x94,

  BMP280_REGISTER_DIG_P5 = 0x96,

  BMP280_REGISTER_DIG_P6 = 0x98,

  BMP280_REGISTER_DIG_P7 = 0x9A,

  BMP280_REGISTER_DIG_P8 = 0x9C,

  BMP280_REGISTER_DIG_P9 = 0x9E,



  BMP280_REGISTER_CHIPID = 0xD0,

  BMP280_REGISTER_VERSION = 0xD1,

  BMP280_REGISTER_SOFTRESET = 0xE0,



  BMP280_REGISTER_CAL26 = 0xE1,



  BMP280_REGISTER_CONTROL = 0xF4,

  BMP280_REGISTER_CONFIG = 0xF5,

  BMP280_REGISTER_PRESSUREDATA = 0xF7,

  BMP280_REGISTER_TEMPDATA = 0xFA,



  BMP280_CONTROL_SETTING = 0x57,

  BMP280_CONFIG_SETTING = 0xE0,

};



typedef struct

{

  uint16_t dig_T1;

  int16_t dig_T2;

  int16_t dig_T3;



  uint16_t dig_P1;

  int16_t dig_P2;

  int16_t dig_P3;

  int16_t dig_P4;

  int16_t dig_P5;

  int16_t dig_P6;

  int16_t dig_P7;

  int16_t dig_P8;

  int16_t dig_P9;

} bmp280_calib_data;



bmp280_calib_data _bmp280_calib[2];



uint8_t bmp280_i2caddr;

int32_t bmp280_sensorID;

int32_t bmp280_t_fine;



uint8_t Plugin_030_read8(byte reg, bool * is_ok = NULL);



boolean Plugin_030_init[2] = {false, false};



boolean Plugin_030(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_030;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_030);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_030));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_030));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x76, 0x77 };

        addFormSelectorI2C(F("plugin_030_bmp280_i2c"), 2, optionValues, choice);

        addFormNote(F("SDO Low=0x76, High=0x77"));



        addFormNumericBox(F("Altitude"), F("plugin_030_bmp280_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("m"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_030_bmp280_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_030_bmp280_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        uint8_t idx = Settings.TaskDevicePluginConfig[event->TaskIndex][0] & 0x1;

        Plugin_030_init[idx] &= Plugin_030_check(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        Plugin_030_init[idx] &= (Plugin_030_read8(BMP280_REGISTER_CONTROL) == BMP280_CONTROL_SETTING);



        if (!Plugin_030_init[idx])

        {

          Plugin_030_init[idx] = Plugin_030_begin(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

          delay(65);

        }



        if (Plugin_030_init[idx])

        {

          UserVar[event->BaseVarIndex] = Plugin_030_readTemperature(idx);

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_030_pressureElevation((float)Plugin_030_readPressure(idx) / 100, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ((float)Plugin_030_readPressure(idx)) / 100;

          }



          String log = F("BMP280  : Address: 0x");

          log += String(bmp280_i2caddr,HEX);

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP280  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP280  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);
# 373 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
          success = true;

        }

        break;

      }



  }

  return success;

}
# 397 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
bool Plugin_030_check(uint8_t a) {

  bmp280_i2caddr = a?a:0x76;

  bool wire_status = false;

  if (Plugin_030_read8(BMP280_REGISTER_CHIPID, &wire_status) != 0x58) {

      return false;

  } else {

      return wire_status;

  }

}
# 423 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
bool Plugin_030_begin(uint8_t a) {

  if (! Plugin_030_check(a))

    return false;



  Plugin_030_readCoefficients(a & 0x1);

  Plugin_030_write8(BMP280_REGISTER_CONTROL, BMP280_CONTROL_SETTING);

  Plugin_030_write8(BMP280_REGISTER_CONFIG, BMP280_CONFIG_SETTING);

  return true;

}
# 449 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
void Plugin_030_write8(byte reg, byte value)

{

  Wire.beginTransmission((uint8_t)bmp280_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.write((uint8_t)value);

  Wire.endTransmission();

}
# 471 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
uint8_t Plugin_030_read8(byte reg, bool * is_ok)

{

  uint8_t value;



  Wire.beginTransmission((uint8_t)bmp280_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  byte count = Wire.requestFrom((uint8_t)bmp280_i2caddr, (byte)1);

  if (is_ok != NULL) { *is_ok = (count == 1); }

  value = Wire.read();

  Wire.endTransmission();

  return value;

}
# 505 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
uint16_t Plugin_030_read16(byte reg)

{

  uint16_t value;



  Wire.beginTransmission((uint8_t)bmp280_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)bmp280_i2caddr, (byte)2);

  value = (Wire.read() << 8) | Wire.read();

  Wire.endTransmission();



  return value;

}
# 539 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
int32_t Plugin_030_read24(byte reg)

{

  int32_t value;



  Wire.beginTransmission((uint8_t)bmp280_i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)bmp280_i2caddr, (byte)3);

  value = (((int32_t)Wire.read()) << 16) | (Wire.read() << 8) | Wire.read();

  Wire.endTransmission();



  return value;

}
# 573 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
uint16_t Plugin_030_read16_LE(byte reg) {

  uint16_t temp = Plugin_030_read16(reg);

  return (temp >> 8) | (temp << 8);



}
# 591 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
int16_t Plugin_030_readS16(byte reg)

{

  return (int16_t)Plugin_030_read16(reg);



}



int16_t Plugin_030_readS16_LE(byte reg)

{

  return (int16_t)Plugin_030_read16_LE(reg);



}
# 621 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
void Plugin_030_readCoefficients(uint8_t idx)

{

  _bmp280_calib[idx].dig_T1 = Plugin_030_read16_LE(BMP280_REGISTER_DIG_T1);

  _bmp280_calib[idx].dig_T2 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_T2);

  _bmp280_calib[idx].dig_T3 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_T3);



  _bmp280_calib[idx].dig_P1 = Plugin_030_read16_LE(BMP280_REGISTER_DIG_P1);

  _bmp280_calib[idx].dig_P2 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P2);

  _bmp280_calib[idx].dig_P3 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P3);

  _bmp280_calib[idx].dig_P4 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P4);

  _bmp280_calib[idx].dig_P5 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P5);

  _bmp280_calib[idx].dig_P6 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P6);

  _bmp280_calib[idx].dig_P7 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P7);

  _bmp280_calib[idx].dig_P8 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P8);

  _bmp280_calib[idx].dig_P9 = Plugin_030_readS16_LE(BMP280_REGISTER_DIG_P9);

}
# 661 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
float Plugin_030_readTemperature(uint8_t idx)

{

  int32_t var1, var2;



  int32_t adc_T = Plugin_030_read24(BMP280_REGISTER_TEMPDATA);

  adc_T >>= 4;



  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib[idx].dig_T1 << 1))) *

           ((int32_t)_bmp280_calib[idx].dig_T2)) >> 11;



  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib[idx].dig_T1)) *

             ((adc_T >> 4) - ((int32_t)_bmp280_calib[idx].dig_T1))) >> 12) *

           ((int32_t)_bmp280_calib[idx].dig_T3)) >> 14;



  bmp280_t_fine = var1 + var2;



  float T = (bmp280_t_fine * 5 + 128) >> 8;

  return T / 100;

}
# 707 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
float Plugin_030_readPressure(uint8_t idx) {

  int64_t var1, var2, p;



  int32_t adc_P = Plugin_030_read24(BMP280_REGISTER_PRESSUREDATA);

  adc_P >>= 4;



  var1 = ((int64_t)bmp280_t_fine) - 128000;

  var2 = var1 * var1 * (int64_t)_bmp280_calib[idx].dig_P6;

  var2 = var2 + ((var1 * (int64_t)_bmp280_calib[idx].dig_P5) << 17);

  var2 = var2 + (((int64_t)_bmp280_calib[idx].dig_P4) << 35);

  var1 = ((var1 * var1 * (int64_t)_bmp280_calib[idx].dig_P3) >> 8) +

         ((var1 * (int64_t)_bmp280_calib[idx].dig_P2) << 12);

  var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib[idx].dig_P1) >> 33;



  if (var1 == 0) {

    return 0;

  }

  p = 1048576 - adc_P;

  p = (((p << 31) - var2) * 3125) / var1;

  var1 = (((int64_t)_bmp280_calib[idx].dig_P9) * (p >> 13) * (p >> 13)) >> 25;

  var2 = (((int64_t)_bmp280_calib[idx].dig_P8) * p) >> 19;



  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib[idx].dig_P7) << 4);

  return (float)p / 256;

}
# 771 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
float Plugin_030_readAltitude(float seaLevel)

{

  float atmospheric = Plugin_030_readPressure(bmp280_i2caddr & 0x01) / 100.0F;

  return 44330.0 * (1.0 - pow(atmospheric / seaLevel, 0.1903));

}
# 789 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P030_BMP280.ino"
float Plugin_030_pressureElevation(float atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P031_SHT1X.ino"
#ifdef USES_P031
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P031_SHT1X.ino"
#define PLUGIN_031 

#define PLUGIN_ID_031 31

#define PLUGIN_NAME_031 "Environment - SHT1X"

#define PLUGIN_VALUENAME1_031 "Temperature"

#define PLUGIN_VALUENAME2_031 "Humidity"



boolean Plugin_031_init = false;

byte Plugin_031_DATA_Pin = 0;

byte Plugin_031_CLOCK_Pin = 0;

int input_mode;



enum {

  SHT1X_CMD_MEASURE_TEMP = B00000011,

  SHT1X_CMD_MEASURE_RH = B00000101,

  SHT1X_CMD_READ_STATUS = B00000111,

  SHT1X_CMD_SOFT_RESET = B00011110

};



boolean Plugin_031(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_031;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_031);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_031));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_031));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_031_init = true;

        Plugin_031_DATA_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        Plugin_031_CLOCK_Pin = Settings.TaskDevicePin2[event->TaskIndex];

        if (Settings.TaskDevicePin1PullUp[event->TaskIndex]) {

          input_mode = INPUT_PULLUP;

          String log = F("SHT1X: Setting PullUp on pin ");

          log += String(Plugin_031_DATA_Pin);

          addLog(LOG_LEVEL_DEBUG, log);

        }

        else {

          input_mode = INPUT;

        }

        pinMode(Plugin_031_DATA_Pin, input_mode);

        pinMode(Plugin_031_CLOCK_Pin, OUTPUT);

        Plugin_031_reset();

        byte status = Plugin_031_readStatus();

        String log = F("SHT1X : Status byte: ");

        log += String(status, HEX);

        log += F(" - resolution: ");

        log += (status & 1 ? F("low") : F("high"));

        log += F(" reload from OTP: ");

        log += ((status >> 1) & 1 ? F("yes") : F("no"));

        log += F(", heater: ");

        log += ((status >> 2) & 1 ? F("on") : F("off"));

        addLog(LOG_LEVEL_DEBUG, log);

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_031_init) {

          addLog(LOG_LEVEL_ERROR, F("SHT1X : not yet initialized!"));

          break;

        }

        UserVar[event->BaseVarIndex] = Plugin_031_readTemperature();

        UserVar[event->BaseVarIndex+1] = Plugin_031_readRelHumidity(UserVar[event->BaseVarIndex]);

        success = true;

        break;

      }

  }

  return success;

}



float Plugin_031_readTemperature()

{

  float tempRaw, tempC;



  Plugin_031_sendCommand(SHT1X_CMD_MEASURE_TEMP);

  Plugin_031_awaitResult();

  tempRaw = Plugin_031_readData(16);





  const float d1 = -39.7;

  const float d2 = 0.01;



  tempC = d1 + (tempRaw * d2);



  String log = F("SHT1X : Read temperature (raw): ");

  log += String(tempRaw);

  log += F(" (Celcius): ");

  log += String(tempC);

  addLog(LOG_LEVEL_DEBUG, log);



  return tempC;

}



float Plugin_031_readRelHumidity(float tempC)

{

  float raw, rhLinear, rhTrue;



  Plugin_031_sendCommand(SHT1X_CMD_MEASURE_RH);

  Plugin_031_awaitResult();

  raw = Plugin_031_readData(16);





  const float c1 = -2.0468;

  const float c2 = 0.0367;

  const float c3 = -1.5955E-6;

  const float t1 = 0.01;

  const float t2 = 0.00008;



  rhLinear = c1 + c2 * raw + c3 * raw * raw;

  rhTrue = (tempC - 25) * (t1 + t2 * raw) + rhLinear;



  String log = F("SHT1X : Read humidity (raw): ");

  log += String(raw);

  log += F(" (Linear): ");

  log += String(rhLinear);

  log += F(" (True): ");

  log += String(rhTrue);

  addLog(LOG_LEVEL_DEBUG, log);



  return rhTrue;

}





void Plugin_031_reset()

{

  delay(11);

  for (int i=0; i<9; i++) {

    digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

    digitalWrite(Plugin_031_CLOCK_Pin, LOW);

  }

  Plugin_031_sendCommand(SHT1X_CMD_SOFT_RESET);

  delay(11);

}



byte Plugin_031_readStatus()

{

  Plugin_031_sendCommand(SHT1X_CMD_READ_STATUS);

  return Plugin_031_readData(8);

}



void Plugin_031_sendCommand(const byte cmd)

{

  pinMode(Plugin_031_DATA_Pin, OUTPUT);





  digitalWrite(Plugin_031_DATA_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_DATA_Pin, LOW);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_DATA_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);





  shiftOut(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, MSBFIRST, cmd);





  bool ackerror = false;

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  pinMode(Plugin_031_DATA_Pin, input_mode);

  if (digitalRead(Plugin_031_DATA_Pin) != LOW) ackerror = true;

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);



  if (cmd == SHT1X_CMD_MEASURE_TEMP || cmd == SHT1X_CMD_MEASURE_RH) {

    delayMicroseconds(1);

    if (digitalRead(Plugin_031_DATA_Pin) != HIGH) ackerror = true;

  }



  if (ackerror) {

    addLog(LOG_LEVEL_ERROR, F("SHT1X : Sensor did not ACK command"));

  }

}



void Plugin_031_awaitResult()

{



  for (int i=0; i<16; i++) {

    if (digitalRead(Plugin_031_DATA_Pin) == LOW) return;

    delay(20);

  }

  if (digitalRead(Plugin_031_DATA_Pin) != LOW) {

    addLog(LOG_LEVEL_ERROR, F("SHT1X : Data not ready"));

  }

}



int Plugin_031_readData(const int bits)

{

  int val = 0;



  if (bits == 16) {



    val = shiftIn(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, 8);

    val <<= 8;





    pinMode(Plugin_031_DATA_Pin, OUTPUT);

    digitalWrite(Plugin_031_DATA_Pin, LOW);

    digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

    digitalWrite(Plugin_031_CLOCK_Pin, LOW);

    pinMode(Plugin_031_DATA_Pin, input_mode);

  }





  val |= shiftIn(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, 8);





  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);



  return val;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
#ifdef USES_P032
# 13 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
#define PLUGIN_032 

#define PLUGIN_ID_032 32

#define PLUGIN_NAME_032 "Environment - MS5611 (GY-63)"

#define PLUGIN_VALUENAME1_032 "Temperature"

#define PLUGIN_VALUENAME2_032 "Pressure"



enum

{

  MS5xxx_CMD_RESET = 0x1E,

  MS5xxx_CMD_ADC_READ = 0x00,

  MS5xxx_CMD_ADC_CONV = 0x40,

  MS5xxx_CMD_ADC_D1 = 0x00,

  MS5xxx_CMD_ADC_D2 = 0x10,

  MS5xxx_CMD_ADC_256 = 0x00,

  MS5xxx_CMD_ADC_512 = 0x02,

  MS5xxx_CMD_ADC_1024 = 0x04,

  MS5xxx_CMD_ADC_2048 = 0x06,

  MS5xxx_CMD_ADC_4096 = 0x08,

  MS5xxx_CMD_PROM_RD = 0xA0

};







uint8_t ms5611_i2caddr;

unsigned int ms5611_prom[8];

double ms5611_pressure;

double ms5611_temperature;



boolean Plugin_032_init = false;



boolean Plugin_032(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_032;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_032);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_032));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_032));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x77, 0x76 };

        addFormSelectorI2C(F("plugin_032_ms5611_i2c"), 2, optionValues, choice);



        addFormNumericBox(F("Altitude [m]"), F("plugin_032_ms5611_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_032_ms5611_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_032_ms5611_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_032_init)

        {

          Plugin_032_init = Plugin_032_begin(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        }



        if (Plugin_032_init) {

          Plugin_032_read_prom();

          Plugin_032_readout();



          UserVar[event->BaseVarIndex] = ms5611_temperature / 100;

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_032_pressureElevation(ms5611_pressure, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ms5611_pressure;

          }



          String log = F("MS5611  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("MS5611  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}
# 259 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
bool Plugin_032_begin(uint8_t a) {

  ms5611_i2caddr = a;



  Wire.beginTransmission((uint8_t)ms5611_i2caddr);

  uint8_t ret=Wire.endTransmission(true);

  return ret==0;

}
# 281 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
byte Plugin_032_send_cmd(byte aCMD)

{

  Wire.beginTransmission((uint8_t)ms5611_i2caddr);

  Wire.write(aCMD);

  uint8_t ret=Wire.endTransmission(true);

  return ret;

}
# 313 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
void Plugin_032_read_prom() {

  Plugin_032_send_cmd(MS5xxx_CMD_RESET);

  delay(3);



  for(uint8_t i=0;i<8;i++)

  {

      ms5611_prom[i]=0x0000;

      Plugin_032_send_cmd(MS5xxx_CMD_PROM_RD+2*i);

      Wire.requestFrom((uint8_t)ms5611_i2caddr, (uint8_t)2);



      unsigned int c = Wire.read();

      ms5611_prom[i] = (c << 8);

      c = Wire.read();

      ms5611_prom[i] += c;

      Wire.endTransmission(true);

  }

}
# 355 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
unsigned long Plugin_032_read_adc(unsigned char aCMD)

{

  unsigned long value=0;

  unsigned long c=0;



  Plugin_032_send_cmd(MS5xxx_CMD_ADC_CONV+aCMD);

  switch (aCMD & 0x0f)

  {

    case MS5xxx_CMD_ADC_256 : delayMicroseconds(900);

    break;

    case MS5xxx_CMD_ADC_512 : delay(3);

    break;

    case MS5xxx_CMD_ADC_1024: delay(4);

    break;

    case MS5xxx_CMD_ADC_2048: delay(6);

    break;

    case MS5xxx_CMD_ADC_4096: delay(10);

    break;

  }

  Plugin_032_send_cmd(MS5xxx_CMD_ADC_READ);

  Wire.requestFrom((uint8_t)ms5611_i2caddr, (uint8_t)3);

  c = Wire.read();

  value = (c<<16);

  c = Wire.read();

  value += (c<<8);

  c = Wire.read();

  value += c;

  Wire.endTransmission(true);



  return value;

}
# 427 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
void Plugin_032_readout() {



  unsigned long D1=0, D2=0;



  double dT;

  double OFF;

  double SENS;



  D2=Plugin_032_read_adc(MS5xxx_CMD_ADC_D2+MS5xxx_CMD_ADC_4096);

  D1=Plugin_032_read_adc(MS5xxx_CMD_ADC_D1+MS5xxx_CMD_ADC_4096);





  dT=D2-ms5611_prom[5]*pow(2,8);

  OFF=ms5611_prom[2]*pow(2,16)+dT*ms5611_prom[4]/pow(2,7);

  SENS=ms5611_prom[1]*pow(2,15)+dT*ms5611_prom[3]/pow(2,8);

  ms5611_temperature=(2000+(dT*ms5611_prom[6])/pow(2,23));

  ms5611_pressure=(((D1*SENS)/pow(2,21)-OFF)/pow(2,15));





  double T2=0., OFF2=0., SENS2=0.;

  if(ms5611_temperature<2000) {

    T2=dT*dT/pow(2,31);

    OFF2=5*(ms5611_temperature-2000)*(ms5611_temperature-2000)/pow(2,1);

    SENS2=5*(ms5611_temperature-2000)*(ms5611_temperature-2000)/pow(2,2);

    if(ms5611_temperature<-1500) {

      OFF2+=7*(ms5611_temperature+1500)*(ms5611_temperature+1500);

      SENS2+=11*(ms5611_temperature+1500)*(ms5611_temperature+1500)/pow(2,1);

    }

  }



  ms5611_temperature-=T2;

  OFF-=OFF2;

  SENS-=SENS2;

  ms5611_pressure=(((D1*SENS)/pow(2,21)-OFF)/pow(2,15));

}
# 505 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P032_MS5611.ino"
double Plugin_032_pressureElevation(double atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P033_Dummy.ino"
#ifdef USES_P033
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P033_Dummy.ino"
#define PLUGIN_033 

#define PLUGIN_ID_033 33

#define PLUGIN_NAME_033 "Generic - Dummy Device"

#define PLUGIN_VALUENAME1_033 "Dummy"

boolean Plugin_033(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_033;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].DecimalsOnly = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_033);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_033));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[11];

        options[0] = F("SENSOR_TYPE_SINGLE");

        options[1] = F("SENSOR_TYPE_TEMP_HUM");

        options[2] = F("SENSOR_TYPE_TEMP_BARO");

        options[3] = F("SENSOR_TYPE_TEMP_HUM_BARO");

        options[4] = F("SENSOR_TYPE_DUAL");

        options[5] = F("SENSOR_TYPE_TRIPLE");

        options[6] = F("SENSOR_TYPE_QUAD");

        options[7] = F("SENSOR_TYPE_SWITCH");

        options[8] = F("SENSOR_TYPE_DIMMER");

        options[9] = F("SENSOR_TYPE_LONG");

        options[10] = F("SENSOR_TYPE_WIND");

        int optionValues[11];

        optionValues[0] = SENSOR_TYPE_SINGLE;

        optionValues[1] = SENSOR_TYPE_TEMP_HUM;

        optionValues[2] = SENSOR_TYPE_TEMP_BARO;

        optionValues[3] = SENSOR_TYPE_TEMP_HUM_BARO;

        optionValues[4] = SENSOR_TYPE_DUAL;

        optionValues[5] = SENSOR_TYPE_TRIPLE;

        optionValues[6] = SENSOR_TYPE_QUAD;

        optionValues[7] = SENSOR_TYPE_SWITCH;

        optionValues[8] = SENSOR_TYPE_DIMMER;

        optionValues[9] = SENSOR_TYPE_LONG;

        optionValues[10] = SENSOR_TYPE_WIND;



        addFormSelector(F("Simulate Data Type"), F("plugin_033_sensortype"), 11, options, optionValues, choice );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_033_sensortype"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        event->sensorType = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        for (byte x=0; x<4;x++)

        {

          String log = F("Dummy: value ");

          log += x+1;

          log += F(": ");

          log += UserVar[event->BaseVarIndex+x];

          addLog(LOG_LEVEL_INFO,log);

        }

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P034_DHT12.ino"
#ifdef USES_P034
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P034_DHT12.ino"
#define PLUGIN_034 

#define PLUGIN_ID_034 34

#define PLUGIN_NAME_034 "Environment - DHT12 (I2C)"

#define PLUGIN_VALUENAME1_034 "Temperature"

#define PLUGIN_VALUENAME2_034 "Humidity"



boolean Plugin_034_init = false;



#define DHT12_I2C_ADDRESS 0x5C



boolean Plugin_034(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_034;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_034);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_034));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_034));

        break;

      }



    case PLUGIN_READ:

      {

        byte dht_dat[5];



        byte i;



        boolean error = false;



        Wire.beginTransmission(DHT12_I2C_ADDRESS);

        Wire.write(0);

        Wire.endTransmission();



        Wire.beginTransmission(DHT12_I2C_ADDRESS);

        if (Wire.requestFrom(DHT12_I2C_ADDRESS, 5) == 5) {

          for (i = 0; i < 5; i++)

          {

            dht_dat[i] = Wire.read();

          }

        } else {

          error = true;

        }

        if (!error)

        {



          byte dht_check_sum = dht_dat[0] + dht_dat[1] + dht_dat[2] + dht_dat[3];



          if (dht_dat[4] == dht_check_sum)

          {

            float temperature = float(dht_dat[2]*10 + (dht_dat[3] & 0x7f)) / 10.0;

            if (dht_dat[3] & 0x80) { temperature = -temperature; }

            float humidity = float(dht_dat[0]*10+dht_dat[1]) / 10.0;



            UserVar[event->BaseVarIndex] = temperature;

            UserVar[event->BaseVarIndex + 1] = humidity;

            String log = F("DHT12: Temperature: ");

            log += UserVar[event->BaseVarIndex];

            addLog(LOG_LEVEL_INFO, log);

            log = F("DHT12: Humidity: ");

            log += UserVar[event->BaseVarIndex + 1];

            addLog(LOG_LEVEL_INFO, log);
# 199 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P034_DHT12.ino"
            success = true;

          }

        }

        if(!success)

        {

          addLog(LOG_LEVEL_INFO, F("DHT12: No reading!"));

          UserVar[event->BaseVarIndex] = NAN;

          UserVar[event->BaseVarIndex + 1] = NAN;

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P035_IRTX.ino"
#ifdef USES_P035
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P035_IRTX.ino"
#include <IRremoteESP8266.h>

IRsend *Plugin_035_irSender;



#define PLUGIN_035 

#define PLUGIN_ID_035 35

#define PLUGIN_NAME_035 "Communication - IR Transmit"



boolean Plugin_035(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_035;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_035);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        break;

      }



    case PLUGIN_INIT:

      {

        int irPin = Settings.TaskDevicePin1[event->TaskIndex];

        if (Plugin_035_irSender == 0 && irPin != -1)

        {

          addLog(LOG_LEVEL_INFO, F("INIT: IR TX"));

          Plugin_035_irSender = new IRsend(irPin);

          Plugin_035_irSender->begin();

        }

        if (Plugin_035_irSender != 0 && irPin == -1)

        {

          addLog(LOG_LEVEL_INFO, F("INIT: IR TX Removed"));

          delete Plugin_035_irSender;

          Plugin_035_irSender = 0;

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String IrType;

        unsigned long IrCode=0;

        unsigned int IrBits=0;





        char command[120];

        command[0] = 0;

        char TmpStr1[100];

        TmpStr1[0] = 0;

        string.toCharArray(command, 120);



        String cmdCode = string;

        int argIndex = cmdCode.indexOf(',');

        if (argIndex) cmdCode = cmdCode.substring(0, argIndex);



        if (cmdCode.equalsIgnoreCase(F("IRSEND")) && Plugin_035_irSender != 0)

        {

          success = true;

          #ifdef PLUGIN_016

          if (irReceiver != 0) irReceiver->disableIRIn();

          #endif



          if (GetArgv(command, TmpStr1, 2)) IrType = TmpStr1;



          if (IrType.equalsIgnoreCase(F("RAW"))) {

            String IrRaw;

            unsigned int IrHz=0;

            unsigned int IrPLen=0;

            unsigned int IrBLen=0;



            if (GetArgv(command, TmpStr1, 3)) IrRaw = TmpStr1;

            if (GetArgv(command, TmpStr1, 4)) IrHz = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 5)) IrPLen = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 6)) IrBLen = str2int(TmpStr1);



            printWebString += F("<a href='https://en.wikipedia.org/wiki/Base32#base32hex'>Base32Hex</a> RAW Code: ");

            printWebString += IrRaw;

            printWebString += F("<BR>");



            printWebString += F("kHz: ");

            printWebString += IrHz;

            printWebString += F("<BR>");



            printWebString += F("Pulse Len: ");

            printWebString += IrPLen;

            printWebString += F("<BR>");



            printWebString += F("Blank Len: ");

            printWebString += IrBLen;

            printWebString += F("<BR>");



            unsigned int buf[200];

            unsigned int idx = 0;

            unsigned int c0 = 0;

            unsigned int c1 = 0;



            printWebString += F("Interpreted RAW Code: ");



            for(unsigned int i = 0; i < IrRaw.length(); i++)

            {





              char c = ((IrRaw[i] | ('A' ^ 'a')) - '0') % 39;





              for (unsigned int shft = 1; shft < 6; shft++)

              {



                if ((c & 16) != 0) {



                  c1++;





                  if (c0 > 0) {





                    buf[idx++] = c0 * IrBLen;



                    for (uint t = 0; t < c0; t++)

                      printWebString += F("0");

                  }







                  c0 = 0;

                } else {







                  if (c0+c1 != 0) {



                    c0++;





                    if (c1 > 0) {





                      buf[idx++] = c1 * IrPLen;



                      for (uint t = 0; t < c1; t++)

                        printWebString += F("1");

                    }







                    c1 = 0;

                  }

                }





                c <<= 1;

              }

            }
# 353 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P035_IRTX.ino"
            if (c0 > 0) {

              buf[idx] = c0 * IrBLen;

              for (uint t = 0; t < c0; t++)

                printWebString += F("0");

            }



            if (c1 > 0) {

              buf[idx] = c1 * IrPLen;

              for (uint t = 0; t < c1; t++)

                printWebString += F("1");

            }



            printWebString += F("<BR>");



            Plugin_035_irSender->sendRaw(buf, idx+1, IrHz);
# 393 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P035_IRTX.ino"
          } else {

            unsigned int IrRepeat=0;

            unsigned long IrSecondCode=0UL;



            if (GetArgv(command, TmpStr1, 2)) IrType = TmpStr1;

            if (GetArgv(command, TmpStr1, 3)) IrCode = strtoul(TmpStr1, NULL, 16);

            if (GetArgv(command, TmpStr1, 4)) IrBits = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 5)) IrRepeat = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 6)) IrSecondCode = strtoul(TmpStr1, NULL, 16);



            if (IrType.equalsIgnoreCase(F("NEC"))) Plugin_035_irSender->sendNEC(IrCode, IrBits);

            if (IrType.equalsIgnoreCase(F("JVC"))) Plugin_035_irSender->sendJVC(IrCode, IrBits, 2);

            if (IrType.equalsIgnoreCase(F("RC5"))) Plugin_035_irSender->sendRC5(IrCode, IrBits);

            if (IrType.equalsIgnoreCase(F("RC6"))) Plugin_035_irSender->sendRC6(IrCode, IrBits);

            if (IrType.equalsIgnoreCase(F("SAMSUNG"))) Plugin_035_irSender->sendSAMSUNG(IrCode, IrBits);

            if (IrType.equalsIgnoreCase(F("SONY"))) Plugin_035_irSender->sendSony(IrCode, IrBits);

            if (IrType.equalsIgnoreCase(F("PANASONIC"))) Plugin_035_irSender->sendPanasonic(IrBits, IrCode);

            if (IrType.equalsIgnoreCase(F("PIONEER"))) Plugin_035_irSender->sendPioneer(IrCode, IrBits, IrRepeat, IrSecondCode);

          }



          addLog(LOG_LEVEL_INFO, F("IRTX :IR Code Sent"));

          if (printToWeb)

          {

            printWebString += F("IR Code Sent ");

            printWebString += IrType;

            printWebString += F("<BR>");

          }



          #ifdef PLUGIN_016

          if (irReceiver != 0) irReceiver->enableIRIn();

          #endif

        }

        break;

      }

  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
#ifdef USES_P036
# 29 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
#define PLUGIN_036 

#define PLUGIN_ID_036 36

#define PLUGIN_NAME_036 "Display - OLED SSD1306/SH1106 Framed"

#define PLUGIN_VALUENAME1_036 "OLED"



#define P36_Nlines 12

#define P36_Nchars 32



#define P36_CONTRAST_OFF 1

#define P36_CONTRAST_LOW 64

#define P36_CONTRAST_MED 0xCF

#define P36_CONTRAST_HIGH 0xFF





#include "SSD1306.h"

#include "SH1106Wire.h"

#include "OLED_SSD1306_SH1106_images.h"

#include "Dialog_Plain_12_font.h"



#define P36_WIFI_STATE_UNSET -2

#define P36_WIFI_STATE_NOT_CONNECTED -1



static int8_t lastWiFiState = P36_WIFI_STATE_UNSET;







OLEDDisplay *display=NULL;



char P036_deviceTemplate[P36_Nlines][P36_Nchars];



boolean Plugin_036(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  static byte displayTimer = 0;

  static byte frameCounter = 0;



  static byte nrFramesToDisplay = 0;

  static byte currentFrameToDisplay = 0;



  int linesPerFrame;

  int NFrames;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_036;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_036);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_036));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {





        byte choice5 = Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        String options5[2];

        options5[0] = F("SSD1306");

        options5[1] = F("SH1106");

        int optionValues5[2] = { 1, 2 };

        addFormSelector(F("Controler"), F("plugin_036_controler"), 2, options5, optionValues5, choice5);



        byte choice0 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 209 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
        int optionValues0[2];

        optionValues0[0] = 0x3C;

        optionValues0[1] = 0x3D;

        addFormSelectorI2C(F("plugin_036_adr"), 2, optionValues0, choice0);



        byte choice1 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options1[2];

        options1[0] = F("Normal");

        options1[1] = F("Rotated");

        int optionValues1[2] = { 1, 2 };

        addFormSelector(F("Rotation"), F("plugin_036_rotate"), 2, options1, optionValues1, choice1);



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options2[4];

        options2[0] = F("1");

        options2[1] = F("2");

        options2[2] = F("3");

        options2[3] = F("4");

        int optionValues2[4] = { 1, 2, 3, 4 };

        addFormSelector(F("Lines per Frame"), F("plugin_036_nlines"), 4, options2, optionValues2, choice2);



        byte choice3 = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        String options3[5];

        options3[0] = F("Very Slow");

        options3[1] = F("Slow");

        options3[2] = F("Fast");

        options3[3] = F("Very Fast");

        options3[4] = F("Instant");

        int optionValues3[5];

        optionValues3[0] = 1;

        optionValues3[1] = 2;

        optionValues3[2] = 4;

        optionValues3[3] = 8;

        optionValues3[4] = 32;

        addFormSelector(F("Scroll"), F("plugin_036_scroll"), 5, options3, optionValues3, choice3);



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));



        for (byte varNr = 0; varNr < P36_Nlines; varNr++)

        {

          addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_036_template")) + (varNr + 1), P036_deviceTemplate[varNr], P36_Nchars);

        }



        addFormPinSelect(F("Display button"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);



        addFormNumericBox(F("Display Timeout"), F("plugin_036_timer"), Settings.TaskDevicePluginConfig[event->TaskIndex][4]);



        byte choice6 = Settings.TaskDevicePluginConfig[event->TaskIndex][6];

        if (choice6 == 0) choice6 = P36_CONTRAST_HIGH;

        String options6[3];

        options6[0] = F("Low");

        options6[1] = F("Medium");

        options6[2] = F("High");

        int optionValues6[3];

        optionValues6[0] = P36_CONTRAST_LOW;

        optionValues6[1] = P36_CONTRAST_MED;

        optionValues6[2] = P36_CONTRAST_HIGH;

        addFormSelector(F("Contrast"), F("plugin_036_contrast"), 3, options6, optionValues6, choice6);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        timerSensor[event->TaskIndex] = millis() + (Settings.TaskDeviceTimer[event->TaskIndex] * 1000);

        frameCounter=0;



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_036_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_036_rotate"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_036_nlines"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_036_scroll"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_036_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("plugin_036_controler"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][6] = getFormItemInt(F("plugin_036_contrast"));



        String argName;



        for (byte varNr = 0; varNr < P36_Nlines; varNr++)

        {

          argName = F("Plugin_036_template");

          argName += varNr + 1;

          strncpy(P036_deviceTemplate[varNr], WebServer.arg(argName).c_str(), sizeof(P036_deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        lastWiFiState = P36_WIFI_STATE_UNSET;



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));





        if (display)

        {

          display->end();

          delete display;

        }



        uint8_t OLED_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][5] == 1) {

          display = new SSD1306Wire(OLED_address, Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

        } else {

          display = new SH1106Wire(OLED_address, Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

        }

        display->init();

        display->displayOn();



        uint8_t OLED_contrast = Settings.TaskDevicePluginConfig[event->TaskIndex][6];

        P36_setContrast(OLED_contrast);





        UserVar[event->BaseVarIndex] = 1;





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2)display->flipScreenVertically();





        display_header();

        display_logo();

        display->display();





        displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][4];



        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        }





        frameCounter = 0;

        nrFramesToDisplay = 1;

        currentFrameToDisplay = 0;



        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

          if (display)

          {

            display->end();

            delete display;

            display=NULL;

          }

          break;

      }





    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            display->displayOn();

            UserVar[event->BaseVarIndex] = 1;

            displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

          }

        }

        break;

      }





    case PLUGIN_ONCE_A_SECOND:

      {



        if ( displayTimer > 0)

        {

          displayTimer--;

          if (displayTimer == 0)

          {

            display->displayOff();

            UserVar[event->BaseVarIndex] = 0;

          }

        }

        if (UserVar[event->BaseVarIndex] == 1) {



          if (display && display_wifibars()) {



            display->display();

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 621 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
        linesPerFrame = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        NFrames = P36_Nlines / linesPerFrame;





        String tmpString;

        tmpString.reserve(P36_Nchars);

        String newString[4];

        String oldString[4];





        for (byte i = 0; i < linesPerFrame; i++)

        {

          tmpString = P036_deviceTemplate[(linesPerFrame * frameCounter) + i];

          oldString[i] = P36_parseTemplate(tmpString, 20);

          oldString[i].trim();

        }
# 661 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
        boolean foundText = false;

        int ntries = 0;

        while (!foundText) {





          ntries += 1;

          if (ntries > NFrames) break;





          frameCounter = frameCounter + 1;

          if ( frameCounter > NFrames - 1) {

            frameCounter = 0;

            currentFrameToDisplay = 0;

          }





          for (byte i = 0; i < linesPerFrame; i++)

          {

            tmpString = P036_deviceTemplate[(linesPerFrame * frameCounter) + i];

            newString[i] = P36_parseTemplate(tmpString, 20);

            newString[i].trim();

            if (newString[i].length() > 0) foundText = true;

          }

          if (foundText) {

            if (frameCounter != 0) {

              ++currentFrameToDisplay;

            }

          }

        }

        if ((currentFrameToDisplay + 1) > nrFramesToDisplay) {

          nrFramesToDisplay = currentFrameToDisplay + 1;

        }





        display_header();

        display_indicator(currentFrameToDisplay, nrFramesToDisplay);



        display->display();



        int scrollspeed = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        display_scroll(oldString, newString, linesPerFrame, scrollspeed);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);

        if (tmpString.equalsIgnoreCase(F("OLEDFRAMEDCMD")) && display)

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          if (tmpString.equalsIgnoreCase(F("Off")))

            P36_setContrast(P36_CONTRAST_OFF);

          else if (tmpString.equalsIgnoreCase(F("On")))

            display->displayOn();

          else if (tmpString.equalsIgnoreCase(F("Low")))

            P36_setContrast(P36_CONTRAST_LOW);

          else if (tmpString.equalsIgnoreCase(F("Med")))

            P36_setContrast(P36_CONTRAST_MED);

          else if (tmpString.equalsIgnoreCase(F("High")))

            P36_setContrast(P36_CONTRAST_HIGH);

        }

        break;

      }



  }

  return success;

}
# 817 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
void P36_setContrast(uint8_t OLED_contrast) {

  char contrast = 100;

  char precharge = 241;

  char comdetect = 64;

  switch (OLED_contrast) {

    case P36_CONTRAST_OFF:

      if (display) {

        display->displayOff();

      }

      return;

    case P36_CONTRAST_LOW:

      contrast = 10; precharge = 5; comdetect = 0;

      break;

    case P36_CONTRAST_MED:

      contrast = P36_CONTRAST_MED; precharge = 0x1F; comdetect = 64;

      break;

    case P36_CONTRAST_HIGH:

    default:

      contrast = P36_CONTRAST_HIGH; precharge = 241; comdetect = 64;

      break;

  }

  if (display) {

    display->displayOn();

    display->setContrast(contrast, precharge, comdetect);

  }

}





String P36_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);
# 927 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
  return result;

}







void display_header() {

  static boolean showWiFiName = true;

  if (showWiFiName && (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) ) {

    String newString = WiFi.SSID();

    newString.trim();

    display_title(newString);

  } else {

    String dtime = F("%sysname%");

    String newString = parseTemplate(dtime, 10);

    newString.trim();

    display_title(newString);

  }

  showWiFiName = !showWiFiName;



  display_time();

  display_wifibars();

}



void display_time() {

  String dtime = F("%systime%");

  String newString = parseTemplate(dtime, 10);

  display->setTextAlignment(TEXT_ALIGN_LEFT);

  display->setFont(ArialMT_Plain_10);

  display->setColor(BLACK);

  display->fillRect(0, 0, 28, 10);

  display->setColor(WHITE);

  display->drawString(0, 0, newString.substring(0, 5));

}



void display_title(String& title) {

  display->setTextAlignment(TEXT_ALIGN_CENTER);

  display->setFont(ArialMT_Plain_10);

  display->setColor(BLACK);

  display->fillRect(0, 0, 128, 13);

  display->setColor(WHITE);

  display->drawString(64, 0, title);

}



void display_logo() {

  display->setTextAlignment(TEXT_ALIGN_LEFT);

  display->setFont(ArialMT_Plain_16);

  display->setColor(BLACK);

  display->fillRect(0, 14, 128, 64);

  display->setColor(WHITE);

  display->drawString(65, 15, F("ESP"));

  display->drawString(65, 34, F("Easy"));

  display->drawXbm(24, 14, espeasy_logo_width, espeasy_logo_height, espeasy_logo_bits);

}







void display_indicator(int iframe, int frameCount) {







  display->setColor(BLACK);

  display->fillRect(0, 54, 128, 10);

  display->setColor(WHITE);





  if (frameCount <= 1) return;





  for (byte i = 0; i < frameCount; i++) {

    const char *image;

    if (iframe == i) {

      image = activeSymbole;

    } else {

      image = inactiveSymbole;

    }



    int x, y;



    y = 56;
# 1093 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
    const int number_spaces = frameCount - 1;

    if (number_spaces <= 0)

      return;

    int margin = 20;

    int spacing = (128 - 2 * margin) / number_spaces;



    if (spacing > 30) {

      spacing = 30;

      margin = (128 - number_spaces * spacing) / 2;

    }



    x = margin + (spacing * i);

    display->drawXbm(x, y, 8, 8, image);

  }

}



void display_scroll(String outString[], String inString[], int nlines, int scrollspeed)

{
# 1139 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
  int ypos[4];



  if (nlines == 1)

  {

    display->setFont(ArialMT_Plain_24);

    ypos[0] = 20;

  }



  if (nlines == 2)

  {

    display->setFont(ArialMT_Plain_16);

    ypos[0] = 15;

    ypos[1] = 34;

  }



  if (nlines == 3)

  {

    display->setFont(Dialog_plain_12);

    ypos[0] = 13;

    ypos[1] = 25;

    ypos[2] = 37;

  }



  if (nlines == 4)

  {

    display->setFont(ArialMT_Plain_10);

    ypos[0] = 12;

    ypos[1] = 22;

    ypos[2] = 32;

    ypos[3] = 42;

  }



  display->setTextAlignment(TEXT_ALIGN_CENTER);



  for (byte i = 0; i < 33; i = i + scrollspeed)

  {







    display->setColor(BLACK);



    display->fillRect(0, 12, 128, 42);

    display->setColor(WHITE);







    for (byte j = 0; j < nlines; j++)

    {



      display->drawString(64 + (4 * i), ypos[j], outString[j]);



      display->drawString(-64 + (4 * i), ypos[j], inString[j]);

    }



    display->display();



    delay(2);





  }

}





bool display_wifibars() {

  const bool connected = wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED;

  const int nbars_filled = (WiFi.RSSI() + 100) / 8;

  const int newState = connected ? nbars_filled : P36_WIFI_STATE_UNSET;

  if (newState == lastWiFiState)

    return false;



  int x = 105;

  int y = 0;

  int size_x = 15;

  int size_y = 10;

  int nbars = 5;

  int16_t width = (size_x / nbars);

  size_x = width * nbars - 1;
# 1305 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P036_FrameOLED.ino"
  display->setColor(BLACK);

  display->fillRect(x , y, size_x, size_y);

  display->setColor(WHITE);

  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {

    for (byte ibar = 0; ibar < nbars; ibar++) {

      int16_t height = size_y * (ibar + 1) / nbars;

      int16_t xpos = x + ibar * width;

      int16_t ypos = y + size_y - height;

      if (ibar <= nbars_filled) {



        display->fillRect(xpos, ypos, width - 1, height);

      } else {



        display->fillRect(xpos, ypos, width - 1, 1);

        display->fillRect(xpos, y + size_y - 1, width - 1, 1);

      }

    }

  } else {



  }

  return true;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
#ifdef USES_P037
# 19 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
#define PLUGIN_037 

#define PLUGIN_ID_037 37

#define PLUGIN_NAME_037 "Generic - MQTT Import"



#define PLUGIN_VALUENAME1_037 "Value1"

#define PLUGIN_VALUENAME2_037 "Value2"

#define PLUGIN_VALUENAME3_037 "Value3"

#define PLUGIN_VALUENAME4_037 "Value4"



#define PLUGIN_IMPORT 37
# 47 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
WiFiClient espclient_037;

PubSubClient *MQTTclient_037 = NULL;

bool MQTTclient_037_connected = false;



void Plugin_037_update_connect_status() {

  bool connected = false;

  if (MQTTclient_037 != NULL) {

    connected = MQTTclient_037->connected();

  }

  if (MQTTclient_037_connected != connected) {

    MQTTclient_037_connected = !MQTTclient_037_connected;

    if (Settings.UseRules) {

      String event = connected ? F("MQTTimport#Connected") : F("MQTTimport#Disconnected");

      rulesProcessing(event);

    }

    if (!connected) {



      espclient_037 = WiFiClient();

      addLog(LOG_LEVEL_ERROR, F("IMPT : MQTT 037 Connection lost"));

    }

  }

}



boolean Plugin_037(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  char deviceTemplate[4][41];







  String tmpClientName = F("%sysname%-Import");

  String ClientName = parseTemplate(tmpClientName, 20);



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_037;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_037);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_037));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte varNr = 0; varNr < 4; varNr++)

        {

         addFormTextBox(String(F("MQTT Topic ")) + (varNr + 1), String(F("Plugin_037_template")) +

           (varNr + 1), deviceTemplate[varNr], 40);

        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String argName;



        for (byte varNr = 0; varNr < 4; varNr++)

        {

          argName = F("Plugin_037_template");

          argName += varNr + 1;

          strncpy(deviceTemplate[varNr], WebServer.arg(argName).c_str(), sizeof(deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!MQTTclient_037) {

          MQTTclient_037 = new PubSubClient(espclient_037);

        }
# 261 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
        MQTTclient_037->disconnect();



        if (MQTTConnect_037(ClientName))

        {



          MQTTSubscribe_037();

          success = true;

        }

        else

        {

          success = false;

        }

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (!MQTTclient_037->loop()) {

          Plugin_037_update_connect_status();

        }

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {





        if (!MQTTclient_037->connected() || MQTTclient_should_reconnect) {

          if (MQTTclient_should_reconnect) {

            addLog(LOG_LEVEL_ERROR, F("IMPT : MQTT 037 Intentional reconnect"));

          }



          MQTTclient_037->disconnect();

          Plugin_037_update_connect_status();

          delay(250);



          if (! MQTTConnect_037(ClientName)) {

            success = false;

            break;

          }



          MQTTSubscribe_037();

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        success = false;

        break;

      }



    case PLUGIN_IMPORT:

      {







        LoadTaskSettings(event->TaskIndex);



        String Payload = event->String2;

        float floatPayload;

        if (!string2float(Payload, floatPayload)) {

          String log = F("IMPT : Bad Import MQTT Command ");

          log += event->String1;

          addLog(LOG_LEVEL_ERROR, log);

          log = F("ERR  : Illegal Payload ");

          log += Payload;

          log += "  ";

          log += ExtraTaskSettings.TaskDeviceName;

          addLog(LOG_LEVEL_INFO, log);

          success = false;

          break;

        }







        String Topic = event->String1;



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte x = 0; x < 4; x++)

        {

          String subscriptionTopic = deviceTemplate[x];

          subscriptionTopic.trim();

          if (subscriptionTopic.length() == 0) continue;







          if (MQTTCheckSubscription_037(Topic, subscriptionTopic))

          {

            UserVar[event->BaseVarIndex + x] = floatPayload;







            String log = F("IMPT : [");

            log += ExtraTaskSettings.TaskDeviceName;

            log += F("#");

            log += ExtraTaskSettings.TaskDeviceValueNames[x];

            log += F("] : ");

            log += floatPayload;

            addLog(LOG_LEVEL_INFO, log);







            if (Settings.UseRules)

            {

              String RuleEvent = F("");

              RuleEvent += ExtraTaskSettings.TaskDeviceName;

              RuleEvent += F("#");

              RuleEvent += ExtraTaskSettings.TaskDeviceValueNames[x];

              RuleEvent += F("=");

              RuleEvent += floatPayload;

              rulesProcessing(RuleEvent);

            }



            success = true;

          }

        }



        break;



      }

  }



  return success;

}

boolean MQTTSubscribe_037()

{
# 533 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
  char deviceTemplate[4][41];







  for (byte y = 0; y < TASKS_MAX; y++)

  {

    if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_037)

    {

      LoadCustomTaskSettings(y, (byte*)&deviceTemplate, sizeof(deviceTemplate));







      for (byte x = 0; x < 4; x++)

      {

        String subscribeTo = deviceTemplate[x];



        if (subscribeTo.length() > 0)

        {

          if (MQTTclient_037->subscribe(subscribeTo.c_str()))

          {

            String log = F("IMPT : [");

            LoadTaskSettings(y);

            log += ExtraTaskSettings.TaskDeviceName;

            log += F("#");

            log += ExtraTaskSettings.TaskDeviceValueNames[x];

            log += F("] subscribed to ");

            log += subscribeTo;

            addLog(LOG_LEVEL_INFO, log);

          }

          else

          {

            String log = F("IMPT : Error subscribing to ");

            log += subscribeTo;

            addLog(LOG_LEVEL_ERROR, log);

            return false;

          }



        }

      }

    }

  }

  return true;

}







void mqttcallback_037(char* c_topic, byte* b_payload, unsigned int length)

{



  String topic = c_topic;



  char cpayload[256];

  strncpy(cpayload, (char*)b_payload, length);

  cpayload[length] = 0;

  String payload = cpayload;

  payload.trim();



  byte DeviceIndex = getDeviceIndex(PLUGIN_ID_037);







  struct EventStruct TempEvent;



  TempEvent.String1 = topic;

  TempEvent.String2 = payload;







  for (byte y = 0; y < TASKS_MAX; y++)

  {

    if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_037)

    {

      TempEvent.TaskIndex = y;

      TempEvent.BaseVarIndex = y * VARS_PER_TASK;

      Plugin_ptr[DeviceIndex](PLUGIN_IMPORT, &TempEvent, payload);

    }

  }

}
# 701 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
boolean MQTTConnect_037(String clientid)

{

  boolean result = false;



  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController < 0) {



    return false;

  }



  if (MQTTclient_037->connected()) return true;





  if (!WiFiConnected(100)) {

    Plugin_037_update_connect_status();

    return false;

  }

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(enabledMqttController, (byte*)&ControllerSettings, sizeof(ControllerSettings));

  if (ControllerSettings.UseDNS) {

    MQTTclient_037->setServer(ControllerSettings.getHost().c_str(), ControllerSettings.Port);

  } else {

    MQTTclient_037->setServer(ControllerSettings.getIP(), ControllerSettings.Port);

  }

  MQTTclient_037->setCallback(mqttcallback_037);







  for (byte x = 1; x < 4; x++)

  {

    String log = "";



    if ((SecuritySettings.ControllerUser[enabledMqttController][0] != 0) && (SecuritySettings.ControllerPassword[enabledMqttController][0] != 0))

      result = MQTTclient_037->connect(clientid.c_str(), SecuritySettings.ControllerUser[enabledMqttController], SecuritySettings.ControllerPassword[enabledMqttController]);

    else

      result = MQTTclient_037->connect(clientid.c_str());





    if (result)

    {

      log = F("IMPT : Connected to MQTT broker with Client ID=");

      log += clientid;

      addLog(LOG_LEVEL_INFO, log);



      break;

    }

    else

    {

      log = F("IMPT : Failed to connect to MQTT broker - attempt ");

      log += x;

      addLog(LOG_LEVEL_ERROR, log);

    }



    delay(500);

  }

  Plugin_037_update_connect_status();

  return MQTTclient_037->connected();

}
# 825 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
boolean MQTTCheckSubscription_037(String Topic, String Subscription) {



  String tmpTopic = Topic;

  String tmpSub = Subscription;



  tmpTopic.trim();

  tmpSub.trim();







  if (tmpTopic.substring(0, 1) == "/")tmpTopic = tmpTopic.substring(1);

  if (tmpSub.substring(0, 1) == "/")tmpSub = tmpSub.substring(1);







  int lenTopic = tmpTopic.length();

  if (tmpTopic.substring(lenTopic - 1, lenTopic) != "/")tmpTopic += F("/");



  int lenSub = tmpSub.length();

  if (tmpSub.substring(lenSub - 1, lenSub) != "/")tmpSub += F("/");







  int SlashTopic;

  int SlashSub;

  int count = 0;



  String pTopic;

  String pSub;



  while (count < 10) {







    SlashTopic = tmpTopic.indexOf('/');

    SlashSub = tmpSub.indexOf('/');
# 905 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P037_MQTTImport.ino"
    if ((SlashTopic == -1) && (SlashSub == -1)) return true;

    if ((SlashTopic == -1) && (SlashSub != -1)) return false;

    if ((SlashTopic != -1) && (SlashSub == -1)) return false;







    pTopic = tmpTopic.substring(0, SlashTopic);

    pSub = tmpSub.substring(0, SlashSub);







    tmpTopic = tmpTopic.substring(SlashTopic + 1);

    tmpSub = tmpSub.substring(SlashSub + 1);





    if (pSub == "#") return true;

    if ((pTopic != pSub) && (pSub != "+"))return false;



    count = count + 1;

  }

  return false;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P038_NeoPixel.ino"
#ifdef USES_P038
# 47 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P038_NeoPixel.ino"
#include <Adafruit_NeoPixel.h>



Adafruit_NeoPixel *Plugin_038_pixels;



#define PLUGIN_038 

#define PLUGIN_ID_038 38

#define PLUGIN_NAME_038 "Output - NeoPixel (Basic)"

#define PLUGIN_VALUENAME1_038 ""



int MaxPixels = 0;



boolean Plugin_038(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_038;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_038);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_038));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const String options[] = { F("GRB"), F("GRBW") };

        int indices[] = { 1, 2 };



       addFormNumericBox(F("Led Count"), F("plugin_038_leds"), Settings.TaskDevicePluginConfig[event->TaskIndex][0],1,999);

       addFormPinSelect(F("GPIO"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);

        addFormSelector(F("Strip Type"), F("plugin_038_strip"), 2, options, indices, Settings.TaskDevicePluginConfig[event->TaskIndex][1] );



       success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_038_leds"));

        MaxPixels = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_038_strip"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_038_pixels)

        {

          byte striptype = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (striptype == 1)

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          else if (striptype == 2)

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRBW + NEO_KHZ800);

          else

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);



          Plugin_038_pixels->begin();

        }

        MaxPixels = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_038_pixels)

        {

          String tmpString = string;

          int argIndex = tmpString.indexOf(',');

          if (argIndex)

            tmpString = tmpString.substring(0, argIndex);



          if (tmpString.equalsIgnoreCase(F("NeoPixel")))

          {
# 241 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P038_NeoPixel.ino"
            Plugin_038_pixels->setPixelColor(event->Par1 - 1, Plugin_038_pixels->Color(event->Par2, event->Par3, event->Par4, event->Par5));

            Plugin_038_pixels->show();

            success = true;

          }



          if (tmpString.equalsIgnoreCase(F("NeoPixelAll")))

      {
# 263 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P038_NeoPixel.ino"
       for (int i = 0; i < MaxPixels; i++)

       {

                Plugin_038_pixels->setPixelColor(i, Plugin_038_pixels->Color(event->Par1, event->Par2, event->Par3, event->Par4));

       }

       Plugin_038_pixels->show();

       success = true;

          }



          if (tmpString.equalsIgnoreCase(F("NeoPixelLine")))

      {
# 299 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P038_NeoPixel.ino"
       for (int i = event->Par1 - 1; i < event->Par2; i++)

       {

        Plugin_038_pixels->setPixelColor(i, Plugin_038_pixels->Color(event->Par3, event->Par4, event->Par5));

       }

       Plugin_038_pixels->show();

       success = true;

          }

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P039_Thermocouple.ino"
#ifdef USES_P039
# 73 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P039_Thermocouple.ino"
#include <SPI.h>



#define PLUGIN_039 

#define PLUGIN_ID_039 39

#define PLUGIN_NAME_039 "Environment - Thermocouple"

#define PLUGIN_VALUENAME1_039 "Temperature"



uint8_t Plugin_039_SPI_CS_Pin = 15;

bool Plugin_039_SensorAttached = true;

uint32_t Plugin_039_Sensor_fault = 0;

double Plugin_039_Celsius = 0.0;



boolean Plugin_039(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_039;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_039);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_039));

        break;

      }



    case PLUGIN_INIT:

      {





        if (Settings.TaskDevicePin1[event->TaskIndex] != 0)

        {



          Plugin_039_SPI_CS_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        }





        pinMode(Plugin_039_SPI_CS_Pin, OUTPUT);



        SPI.setHwCs(false);

        SPI.begin();



        addLog(LOG_LEVEL_INFO, F("P039 : SPI Init"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("<b>1st GPIO</b> = CS (Usable GPIOs : 0, 2, 4, 5, 15)"));





        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2];

        options[0] = F("MAX 6675");

        options[1] = F("MAX 31855");



        int optionValues[2] = { 1, 2 };

        addFormSelector(F("Adapter IC"), F("plugin_039_maxtype"), 2, options, optionValues, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_039_maxtype"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        byte MaxType = Settings.TaskDevicePluginConfig[event->TaskIndex][0];







        Plugin_039_SPI_CS_Pin = Settings.TaskDevicePin1[event->TaskIndex];



        switch (MaxType) {

          case 1:

            Plugin_039_Celsius = readMax6675();

            break;

          case 2:

            Plugin_039_Celsius = readMax31855();

            break;

          case 3:



            break;

        }



        if (Plugin_039_Celsius != NAN)

        {

          UserVar[event->BaseVarIndex] = Plugin_039_Celsius;

          String log = F("P039 : Temperature ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        else

        {

          UserVar[event->BaseVarIndex] = NAN;

          UserVar[event->BaseVarIndex + 1] = NAN;

          addLog(LOG_LEVEL_INFO, F("P039 : No Sensor attached !"));

          success = false;

        }



        break;

      }

  }

  return success;

}



double readMax6675()

{

  uint16_t rawvalue = 0;



  digitalWrite(Plugin_039_SPI_CS_Pin, LOW);
# 363 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P039_Thermocouple.ino"
  rawvalue = SPI.transfer16(0x0);



  digitalWrite(Plugin_039_SPI_CS_Pin, HIGH);



  String log = F("P039 : MAX6675 : RAW - BIN:");

  log += String(rawvalue, BIN);

  log += " HEX:";

  log += String(rawvalue, HEX);

  log += " DEC:";

  log += String(rawvalue);

  addLog(LOG_LEVEL_DEBUG, log);
# 395 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P039_Thermocouple.ino"
  Plugin_039_SensorAttached = !(rawvalue & 0x0004);



  if (Plugin_039_SensorAttached)

  {



    rawvalue >>= 3;





    return rawvalue * 0.25;

  }

  else

  {

    return NAN;

  }

}



double readMax31855()

{

  uint32_t rawvalue = 0;



  digitalWrite(Plugin_039_SPI_CS_Pin, LOW);



  rawvalue = SPI.transfer16(0x0);



  rawvalue <<= 16;



  rawvalue |= SPI.transfer16(0x0);



  digitalWrite(Plugin_039_SPI_CS_Pin, HIGH);



  String log = F("P039 : MAX31855 : RAW - BIN:");

  log += String(rawvalue, BIN);

  log += " HEX:";

  log += String(rawvalue, HEX);

  log += " DEC:";

  log += String(rawvalue);

  addLog(LOG_LEVEL_DEBUG, log);



  if (Plugin_039_Sensor_fault != (rawvalue & 0x7)) {



    Plugin_039_Sensor_fault = (rawvalue & 0x7);

    log = F("P039 : MAX31855");

    if (Plugin_039_Sensor_fault == 0) {

      log += F("Fault resolved");

    } else {

      log += F("Fault code:");

      if (rawvalue & 0x01) {

        log += F(" Open (no connection)");

      }

      if (rawvalue & 0x02) {

        log += F(" Short-circuit to GND");

      }

      if (rawvalue & 0x04) {

        log += F(" Short-circuit to Vcc");

      }

    }

    addLog(LOG_LEVEL_DEBUG, log);

  }



  Plugin_039_SensorAttached = !(rawvalue & 0x00010000);

  if (Plugin_039_SensorAttached)

  {





    rawvalue >>= 18;
# 541 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P039_Thermocouple.ino"
    int temperature = Plugin_039_convert_two_complement(rawvalue, 14);



    return temperature * 0.25;

  }

  else

  {



    return NAN;

  }

}



int Plugin_039_convert_two_complement(uint32_t value, int nr_bits) {

  const bool negative = (value & (1 << (nr_bits - 1))) != 0;

  int nativeInt;

  if (negative) {



    nativeInt = value | ~((1 << nr_bits) - 1);

  } else {

    nativeInt = value;

  }

  return nativeInt;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P040_ID12.ino"
#ifdef USES_P040
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P040_ID12.ino"
#define PLUGIN_040 

#define PLUGIN_ID_040 40

#define PLUGIN_NAME_040 "RFID - ID12LA/RDM6300"

#define PLUGIN_VALUENAME1_040 "Tag"



boolean Plugin_040_init = false;



boolean Plugin_040(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_040;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_040);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_040));

        break;

      }





    case PLUGIN_INIT:

      {

        Plugin_040_init = true;

        Serial.begin(9600);

        success = true;

        break;

      }





    case PLUGIN_SERIAL_IN:

      {

        if (Plugin_040_init)

        {

          byte val = 0;

          byte code[6];

          byte checksum = 0;

          byte bytesread = 0;

          byte tempbyte = 0;



          if ((val = Serial.read()) == 2)

          {

            bytesread = 0;

            while (bytesread < 12) {

              if ( Serial.available() > 0) {

                val = Serial.read();

                if ((val == 0x0D) || (val == 0x0A) || (val == 0x03) || (val == 0x02)) {



                  break;

                }





                if ((val >= '0') && (val <= '9')) {

                  val = val - '0';

                }

                else if ((val >= 'A') && (val <= 'F')) {

                  val = 10 + val - 'A';

                }





                if ( (bytesread & 1) == 1) {





                  code[bytesread >> 1] = (val | (tempbyte << 4));



                  if (bytesread >> 1 != 5) {

                    checksum ^= code[bytesread >> 1];

                  };

                }

                else {

                  tempbyte = val;

                };

                bytesread++;

              }

            }

          }



          if (bytesread == 12)

          {

            if (code[5] == checksum)

            {



              byte index = 0;

              for (byte y = 0; y < TASKS_MAX; y++)

                if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_040)

                  index = y;

              byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[index]);

              event->TaskIndex = index;

              event->BaseVarIndex = index * VARS_PER_TASK;

              event->sensorType = Device[DeviceIndex].VType;





              unsigned long key = 0;

              for (byte i = 1; i < 5; i++) key = key | (((unsigned long) code[i] << ((4 - i) * 8)));

              UserVar[event->BaseVarIndex] = (key & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((key >> 16) & 0xFFFF);

              String log = F("RFID : Tag: ");

              log += key;

              addLog(LOG_LEVEL_INFO, log);

              sendData(event);

            }

          }

          success = true;

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P041_NeoClock.ino"
#ifdef USES_P041







#include <Adafruit_NeoPixel.h>



#define NUM_LEDS 114



byte Plugin_041_red = 0;

byte Plugin_041_green = 0;

byte Plugin_041_blue = 0;



Adafruit_NeoPixel *Plugin_041_pixels;



#define PLUGIN_041 

#define PLUGIN_ID_041 41

#define PLUGIN_NAME_041 "Output - NeoPixel (Word Clock)"

#define PLUGIN_VALUENAME1_041 "Clock"

boolean Plugin_041(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_041;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_041);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_041));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Red"), F("plugin_041_red"), Settings.TaskDevicePluginConfig[event->TaskIndex][0], 0, 255);

       addFormNumericBox(F("Green"), F("plugin_041_green"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], 0, 255);

       addFormNumericBox(F("Blue"), F("plugin_041_blue"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 255);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_041_red"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_041_green"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_041_blue"));

        Plugin_041_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_041_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_041_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_041_pixels)

        {

          Plugin_041_pixels = new Adafruit_NeoPixel(NUM_LEDS, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          Plugin_041_pixels->begin();

        }

        Plugin_041_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_041_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_041_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        success = true;

        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        Plugin_041_update();

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {
# 201 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P041_NeoClock.ino"
        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        if (tmpString.equalsIgnoreCase(F("NeoClockColor")))

        {

          Plugin_041_red = event->Par1;

          Plugin_041_green = event->Par2;

          Plugin_041_blue = event->Par3;

          Plugin_041_update();

          success = true;

        }



        if (tmpString.equalsIgnoreCase(F("NeoTestAll")))

        {

          for (int i = 0; i < NUM_LEDS; i++)

            Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));

          Plugin_041_pixels->show();

          success = true;

        }



        if (tmpString.equalsIgnoreCase(F("NeoTestLoop")))

        {

          for (int i = 0; i < NUM_LEDS; i++)

          {

            resetAndBlack();

            Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));

            Plugin_041_pixels->show();

            delay(200);

          }

          success = true;

        }



        break;

      }



  }

  return success;

}



void Plugin_041_update()

{

  byte Hours = hour();

  byte Minutes = minute();

  resetAndBlack();

  timeToStrip(Hours, Minutes);

  Plugin_041_pixels->show();

}





void resetAndBlack() {

  for (int i = 0; i < NUM_LEDS; i++) {

    Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(0, 0, 0));

  }

}



void pushToStrip(int ledId) {

  Plugin_041_pixels->setPixelColor(ledId, Plugin_041_pixels->Color(Plugin_041_red, Plugin_041_green, Plugin_041_blue));

}



void timeToStrip(uint8_t hours, uint8_t minutes)

{

  pushIT_IS();



  if (minutes >= 5 && minutes < 10) {

    pushFIVE1();

    pushAFTER();

  } else if (minutes >= 10 && minutes < 15) {

    pushTEN1();

    pushAFTER();

  } else if (minutes >= 15 && minutes < 20) {

    pushQUATER();

    pushAFTER();

  } else if (minutes >= 20 && minutes < 25) {

    pushTEN1();

    pushFOR();

    pushHALF();

  } else if (minutes >= 25 && minutes < 30) {

    pushFIVE1();

    pushFOR();

    pushHALF();

  } else if (minutes >= 30 && minutes < 35) {

    pushHALF();

  } else if (minutes >= 35 && minutes < 40) {

    pushFIVE1();

    pushAFTER();

    pushHALF();

  } else if (minutes >= 40 && minutes < 45) {

    pushTEN1();

    pushAFTER();

    pushHALF();

  } else if (minutes >= 45 && minutes < 50) {

    pushQUATER();

    pushFOR();

  } else if (minutes >= 50 && minutes < 55) {

    pushTEN1();

    pushFOR();

  } else if (minutes >= 55 && minutes < 60) {

    pushFIVE1();

    pushFOR();

  }



  int singleMinutes = minutes % 5;

  switch (singleMinutes) {

    case 1:

      pushM_ONE();

      break;

    case 2:

      pushM_ONE();

      pushM_TWO();

      break;

    case 3:

      pushM_ONE();

      pushM_TWO();

      pushM_THREE();

      break;

    case 4:

      pushM_ONE();

      pushM_TWO();

      pushM_THREE();

      pushM_FOUR();

      break;

  }

  if (hours >= 12) {

    hours -= 12;

  }

  if (hours == 12) {

    hours = 0;

  }

  if (minutes >= 20) {

    hours++;

  }





  switch (hours) {

    case 0:

      pushTWELVE();

      break;

    case 1:

      pushONE();

      break;

    case 2:

      pushTWO();

      break;

    case 3:

      pushTHREE();

      break;

    case 4:

      pushFOUR();

      break;

    case 5:

      pushFIVE2();

      break;

    case 6:

      pushSIX();

      break;

    case 7:

      pushSEVEN();

      break;

    case 8:

      pushEIGHT();

      break;

    case 9:

      pushNINE();

      break;

    case 10:

      pushTEN();

      break;

    case 11:

      pushELEVEN();

      break;

    case 12:

      pushTWELVE();

      break;

  }



  if (minutes < 5) {

    pushHOURE();

  }

}



void pushM_ONE() {

  pushToStrip(0);

}

void pushM_TWO() {

  pushToStrip(12);

}

void pushM_THREE() {

  pushToStrip(101);

}

void pushM_FOUR() {

  pushToStrip(113);

}

void pushIT_IS() {

  pushToStrip(1);

  pushToStrip(2);

  pushToStrip(3);

  pushToStrip(5);

  pushToStrip(6);

}

void pushAFTER() {

  pushToStrip(36);

  pushToStrip(37);

  pushToStrip(38);

  pushToStrip(39);

}

void pushQUATER() {

  pushToStrip(30);

  pushToStrip(31);

  pushToStrip(32);

  pushToStrip(33);

  pushToStrip(34);

}

void pushFOR() {

  pushToStrip(41);

  pushToStrip(42);

  pushToStrip(43);

  pushToStrip(44);

}

void pushHALF() {

  pushToStrip(50);

  pushToStrip(51);

  pushToStrip(52);

  pushToStrip(53);

}

void pushONE() {

  pushToStrip(63);

  pushToStrip(64);

  pushToStrip(65);

}

void pushTWO() {

  pushToStrip(64);

  pushToStrip(65);

  pushToStrip(66);

  pushToStrip(67);

}

void pushTHREE() {

  pushToStrip(109);

  pushToStrip(110);

  pushToStrip(111);

  pushToStrip(112);

}

void pushFOUR() {

  pushToStrip(57);

  pushToStrip(58);

  pushToStrip(59);

  pushToStrip(60);

}

void pushFIVE1() {

  pushToStrip(8);

  pushToStrip(9);

  pushToStrip(10);

  pushToStrip(11);

}

void pushFIVE2() {

  pushToStrip(92);

  pushToStrip(93);

  pushToStrip(94);

  pushToStrip(95);

}

void pushSIX() {

  pushToStrip(69);

  pushToStrip(88);

  pushToStrip(91);

}

void pushSEVEN() {

  pushToStrip(69);

  pushToStrip(70);

  pushToStrip(71);

  pushToStrip(72);

  pushToStrip(73);

}

void pushEIGHT() {

  pushToStrip(97);

  pushToStrip(98);

  pushToStrip(99);

  pushToStrip(100);

}

void pushNINE() {

  pushToStrip(73);

  pushToStrip(74);

  pushToStrip(75);

  pushToStrip(76);

  pushToStrip(77);

}

void pushTEN() {

  pushToStrip(54);

  pushToStrip(59);

  pushToStrip(76);

  pushToStrip(81);

}

void pushTEN1() {

  pushToStrip(25);

  pushToStrip(26);

  pushToStrip(27);

  pushToStrip(28);

}

void pushELEVEN() {

  pushToStrip(107);

  pushToStrip(108);

  pushToStrip(109);

}

void pushTWELVE() {

  pushToStrip(82);

  pushToStrip(83);

  pushToStrip(84);

  pushToStrip(85);

  pushToStrip(86);

  pushToStrip(87);

}

void pushTWENTY() {

  pushToStrip(16);

  pushToStrip(17);

  pushToStrip(18);

  pushToStrip(19);

  pushToStrip(20);

  pushToStrip(21);

  pushToStrip(22);

}

void pushHOURE() {

  pushToStrip(102);

  pushToStrip(103);

  pushToStrip(104);

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P042_Candle.ino"
#ifdef USES_P042
# 105 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P042_Candle.ino"
#include <Adafruit_NeoPixel.h>



#define NUM_PIXEL 20

#define NUM_PIXEL_ROW 5

#define RANDOM_PIXEL 70

#define BRIGHT_START 128

#define BASE_TEMP 21



enum SimType {

  TypeOff,

  TypeSimpleCandle,

  TypeAdvancedCandle,

  TypeStaticLight,

  TypePolice,

  TypeBlink,

  TypeStrobe,

  TypeColorFader

};



enum ColorType {

  ColorDefault,

  ColorSelected

};



byte Candle_red = 0;

byte Candle_green = 0;

byte Candle_blue = 0;

byte Candle_bright = 128;

SimType Candle_type = TypeSimpleCandle;

ColorType Candle_color = ColorDefault;





unsigned long Candle_Update = 0;

word Candle_Temp[4] = { 0, 0, 0 };

int Candle_Temp4 = 0;

boolean GPIO_Set = false;



Adafruit_NeoPixel *Candle_pixels;



#define PLUGIN_042 

#define PLUGIN_ID_042 42

#define PLUGIN_NAME_042 "Output - NeoPixel (Candle)"

#define PLUGIN_VALUENAME1_042 "Color"

#define PLUGIN_VALUENAME2_042 "Brightness"

#define PLUGIN_VALUENAME3_042 "Type"



boolean Plugin_042(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_042;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_042);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_042));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_042));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_042));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addHtml(F("<script src=\"jscolor.min.js\"></script>\n"));



        char tmpString[128];

        String options[8];





        options[0] = F("Off");

        options[1] = F("Static Light");

        options[2] = F("Simple Candle");

        options[3] = F("Advanced Candle");

        options[4] = F("Police");

        options[5] = F("Blink");

        options[6] = F("Strobe");

        options[7] = F("Color Fader");



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        if (choice > sizeof(options) - 1)

        {

          choice = 2;

        }





        addFormSelector(F("Flame Type"), F("web_Candle_Type"), 8, options, NULL, choice);





        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        addHtml(F("<TR><TD>Color Handling:<TD>"));

        addHtml(F("<input type='radio' id='web_Color_Default' name='web_Color_Type' value='0'"));

        if (Candle_color == ColorDefault) {

          addHtml(F(" checked>"));

        } else {

          addHtml(F(">"));

        }

        addHtml(F("<label for='web_Color_Default'> Use default color</label><br>"));

        addHtml(F("<input type='radio' id='web_Color_Selected' name='web_Color_Type' value='1'"));

        if (Candle_color == ColorSelected) {

          addHtml(F(" checked>"));

        } else {

          addHtml(F(">"));

        }

        addHtml(F("<label for='web_Color_Selected'> Use selected color</label><br>"));





        char hexvalue[7] = {0};

        sprintf(hexvalue, "%02X%02X%02X",

                Settings.TaskDevicePluginConfig[event->TaskIndex][0],

                Settings.TaskDevicePluginConfig[event->TaskIndex][1],

                Settings.TaskDevicePluginConfig[event->TaskIndex][2]);





        addHtml(F("<TR><TD>Color:<TD><input class=\"jscolor {onFineChange:'update(this)'}\" value='"));

        addHtml(hexvalue);

        addHtml(F("'>"));

        addFormNumericBox(F("RGB Color"), F("web_RGB_Red"), Settings.TaskDevicePluginConfig[event->TaskIndex][0], 0, 255);

        addNumericBox(F("web_RGB_Green"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], 0, 255);

        addNumericBox(F("web_RGB_Blue"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 255);





        addHtml(F("<TR><TD>Brightness:<TD>min<input type='range' id='web_Bright_Slide' min='0' max='255' value='"));

        addHtml(String(Settings.TaskDevicePluginConfig[event->TaskIndex][3]));

        addHtml(F("'> max"));



        sprintf_P(tmpString, PSTR("<TR><TD>Brightness Value:<TD><input type='text' name='web_Bright_Text' id='web_Bright_Text' size='3' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);

        addHtml(tmpString);





        addHtml(F("<script script type='text/javascript'>"));

        addHtml(F("function update(picker) {"));

        addHtml(F("    document.getElementById('web_RGB_Red').value = Math.round(picker.rgb[0]);"));

        addHtml(F("    document.getElementById('web_RGB_Green').value = Math.round(picker.rgb[1]);"));

        addHtml(F("    document.getElementById('web_RGB_Blue').value = Math.round(picker.rgb[2]);"));

        addHtml(F("}"));

        addHtml(F("</script>"));



        addHtml(F("<script type='text/javascript'>window.addEventListener('load', function(){"));

        addHtml(F("var slider = document.getElementById('web_Bright_Slide');"));

        addHtml(F("slider.addEventListener('change', function(){"));

        addHtml(F("document.getElementById('web_Bright_Text').value = this.value;"));

        addHtml(F("});"));

        addHtml(F("});</script>"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("web_RGB_Red"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("web_RGB_Green"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("web_RGB_Blue"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("web_Bright_Text"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("web_Candle_Type"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("web_Color_Type"));



        Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Candle_bright > 255) {

          Candle_bright = 255;

        }

        Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        if (Candle_red == 0 && Candle_green == 0 && Candle_blue == 0) {

          Candle_bright = BRIGHT_START;

        }

        Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



        if (!Candle_pixels || GPIO_Set == false)

        {

          GPIO_Set = Settings.TaskDevicePin1[event->TaskIndex] > -1;

          if (Candle_pixels) {

            delete Candle_pixels;

          }

          Candle_pixels = new Adafruit_NeoPixel(NUM_PIXEL, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          SetPixelsBlack();

          Candle_pixels->setBrightness(Candle_bright);

          Candle_pixels->begin();

          String log = F("CAND : Init WS2812 Pin : ");

          log += Settings.TaskDevicePin1[event->TaskIndex];

          addLog(LOG_LEVEL_DEBUG, log);

        }



        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        Candle_pixels->setBrightness(Candle_bright);

        Candle_pixels->show();

        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        switch (Candle_type)

        {

          case 0:

            {

              type_Off();

              break;

            }



          case 1:

            {

              type_Static_Light();

              break;

            }



          case 2:

          case 3:

            {

              if (timeOutReached(Candle_Update)) {

                if (Candle_type == 2) {

                  type_Simple_Candle();

                }

                if (Candle_type == 3) {

                  type_Advanced_Candle();

                }

                Candle_Update = millis() + random(25, 150);

              }

              break;

            }



          case 4:

            {

              if (timeOutReached(Candle_Update)) {

                type_Police();

                Candle_Update = millis() + 150;

              }

              break;

            }



          case 5:

            {

              if (timeOutReached(Candle_Update)) {

                type_BlinkStrobe();

                Candle_Update = millis() + 100;

              }

              break;

            }



          case 6:

            {

              type_BlinkStrobe();

              break;

            }

          case 7:

            {

              if (timeOutReached(Candle_Update)) {

                type_ColorFader();

                Candle_Update = millis() + 2000;

              }

              break;

            }

        }



        Candle_pixels->show();



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Candle_red * 65536 + Candle_green * 256 + Candle_blue;

        UserVar[event->BaseVarIndex + 1] = Candle_bright;

        UserVar[event->BaseVarIndex + 2] = Candle_type;



        success = true;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;
# 769 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P042_Candle.ino"
        if (tmpString.startsWith(F("CANDLE:"))){

          int idx1 = tmpString.indexOf(':');

          int idx2 = tmpString.indexOf(':', idx1+1);

          int idx3 = tmpString.indexOf(':', idx2+1);

          int idx4 = tmpString.indexOf(':', idx3+1);

          String val_Type = tmpString.substring(idx1+1, idx2);

          String val_Color = tmpString.substring(idx2+1, idx3);

          String val_Bright = tmpString.substring(idx3+1, idx4);



          if (val_Type != "") {

             if (val_Type.toInt() > -1 && val_Type.toInt() < 8) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][4] = val_Type.toInt();

                Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

                String log = F("CAND : CMD - Type : ");

                log += val_Type;

                addLog(LOG_LEVEL_DEBUG, log);

             }

          }



          if (val_Bright != "") {

             if (val_Bright.toInt() > -1 && val_Bright.toInt() < 256) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][3] = val_Bright.toInt();

                Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

                String log = F("CAND : CMD - Bright : ");

                log += val_Bright;

                addLog(LOG_LEVEL_DEBUG, log);

             }

          }



          if (val_Color != "") {

            long number = strtol( &val_Color[0], NULL, 16);



            byte r = number >> 16;

            byte g = number >> 8 & 0xFF;

            byte b = number & 0xFF;



            Settings.TaskDevicePluginConfig[event->TaskIndex][0] = r;

            Settings.TaskDevicePluginConfig[event->TaskIndex][1] = g;

            Settings.TaskDevicePluginConfig[event->TaskIndex][2] = b;

            Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

            Settings.TaskDevicePluginConfig[event->TaskIndex][5] = 1;

            Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



            String log = F("CAND : CMD - R ");

            log += r;

            log += F(" G ");

            log += g;

            log += F(" B ");

            log += b;

            addLog(LOG_LEVEL_DEBUG, log);

          } else {

            Settings.TaskDevicePluginConfig[event->TaskIndex][5] = 0;

            Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];

            addLog(LOG_LEVEL_DEBUG, F("CAND : CMD - Color : DEFAULT"));

          }
# 891 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P042_Candle.ino"
          success = true;

        }



        break;

      }



  }

  return success;

}



void SetPixelsBlack() {

  for (int i = 0; i < NUM_PIXEL; i++) {

    Candle_pixels->setPixelColor(i, Candle_pixels->Color(0, 0, 0));

  }

}



void SetPixelToColor(int PixelIdx) {

  Candle_pixels->setPixelColor(PixelIdx, Candle_pixels->Color(Candle_red, Candle_green, Candle_blue));

}



void type_Off() {

  SetPixelsBlack();

}



void type_Static_Light() {

  for (int i = 0; i < NUM_PIXEL; i++) {

    if (Candle_color == ColorDefault) {

      Candle_pixels->setPixelColor(i, 255, 255, 255);

    } else {

      Candle_pixels->setPixelColor(i, Candle_red, Candle_green, Candle_blue);

    }

  }

}



void type_Simple_Candle() {

  int r, g, b;

  if (Candle_color == ColorDefault) {

    r = 226, g = 042, b = 35;





  } else {

    r = Candle_red, g = Candle_green, b = Candle_blue;

  }





  for (int i = 0; i < NUM_PIXEL; i++) {

    int flicker = random(0, RANDOM_PIXEL);

    int r1 = r - flicker;

    int g1 = g - flicker;

    int b1 = b - flicker;

    if (g1 < 0) g1 = 0;

    if (r1 < 0) r1 = 0;

    if (b1 < 0) b1 = 0;

    Candle_pixels->setPixelColor(i, r1, g1, b1);

  }

}



void type_Advanced_Candle() {

  Candle_Temp[0] = random(1, 4);

  Candle_Temp[1] = random(1, 4) + Candle_Temp[0];

  Candle_Temp[2] = random(0, 2);



  int colorbase[3];

  int color1[3];

  int color2[3];

  int color3[3];



  if (Candle_color == ColorDefault) {

    colorbase[0] = 255; colorbase[1] = 120; colorbase[2] = 0;

    color1[0] = 115; color1[1] = 50; color1[2] = 0;

    color2[0] = 180; color2[1] = 80; color2[2] = 0;

    color3[0] = 70; color3[1] = 30; color3[2] = 0;

  } else {

    colorbase[0] = Candle_red; colorbase[1] = Candle_green; colorbase[2] = Candle_blue;

    double hsv[3];



    RGBtoHSV(Candle_red, Candle_green, Candle_blue, hsv);

    double newH = hsv[0] - 5;

    if (newH < 0) { newH += 359; }

    double newV = hsv[2] / 2;

    double newV2 = hsv[2] / 4;



    HSVtoRGB(newH, hsv[1], hsv[2], color1);

    HSVtoRGB(hsv[0], hsv[1], newV, color2);

    HSVtoRGB(newH, hsv[1], newV2, color3);

  }



  for (int j = 0; j < 4; j++) {

    for (unsigned int i = 1; i < 6; i++){

      if (i <= Candle_Temp[0]) {

        Candle_pixels->setPixelColor(j * 5 + i - 1, colorbase[0], colorbase[1], colorbase[2]);

      }

      if (i > Candle_Temp[0] && i <= Candle_Temp[1]) {

        if (Candle_Temp[2] == 0){

          Candle_pixels->setPixelColor(j * 5 + i - 1, color1[0], color1[1], color1[2]);

        } else {

          Candle_pixels->setPixelColor(j * 5 + i - 1, color2[0], color2[1], color2[2]);

        }

      }

      if (i > Candle_Temp[1]) {

        Candle_pixels->setPixelColor(j * 5 + i - 1, color3[0], color3[1], color3[2]);

      }

    }

  }

}



void type_Police() {

  Candle_Temp[0]++;

  if (Candle_Temp[0] > 3) {

    Candle_Temp[0] = 0;

  }



  for (unsigned int i = 0; i < 4; i++) {

    if (i == Candle_Temp[0])

    {

      for (int j = 0; j < 5; j++) {

        if (Candle_color == ColorDefault) {

          Candle_pixels->setPixelColor(i * 5 + j, 0, 0, 255);

        } else {

          Candle_pixels->setPixelColor(i * 5 + j, Candle_red, Candle_green, Candle_blue);

        }

      }

    } else {

      for (int j = 0; j < 5; j++) {

        Candle_pixels->setPixelColor(i * 5 + j, 0, 0, 0);

      }

    }

  }

}



void type_BlinkStrobe() {

  Candle_Temp[0]++;

  if (Candle_Temp[0] > 1) {

    Candle_Temp[0] = 0;

  }



  for (int i = 0; i < NUM_PIXEL; i++) {

    if (Candle_Temp[0] == 0) {

      Candle_pixels->setPixelColor(i, 0, 0, 0);

    } else {

      if (Candle_color == ColorDefault) {

        Candle_pixels->setPixelColor(i, 255, 255, 255);

      } else {

        Candle_pixels->setPixelColor(i, Candle_red, Candle_green, Candle_blue);

      }

    }

  }

}



void type_ColorFader() {

  int colors[3];

  double hsv[3];

  if (Candle_color != ColorDefault) {

    if (Candle_Temp[0] > 254 && Candle_Temp[1] == 1) {

      Candle_Temp[1] = 0;

    }

    if (Candle_Temp[0] < 55 && Candle_Temp[1] == 0) {

      Candle_Temp[1] = 1;

    }



    if (Candle_Temp[1] > 0) {

      Candle_Temp[0]++;

    } else {

      Candle_Temp[0]--;

    }







    RGBtoHSV(Candle_red, Candle_green, Candle_blue, hsv);
# 1237 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P042_Candle.ino"
    HSVtoRGB(hsv[0], hsv[1], Candle_Temp[0], colors);



    for (int i = 0; i < NUM_PIXEL; i++) {

      Candle_pixels->setPixelColor(i, colors[0], colors[1], colors[2]);

    }

  } else {

    Candle_Temp[0]++;

    if (Candle_Temp[0] > 359) {

      Candle_Temp[0] = 0;

    }





    HSVtoRGB(Candle_Temp[0], 255, 255, colors);



    for (int i = 0; i < NUM_PIXEL; i++) {

      Candle_pixels->setPixelColor(i, colors[0], colors[1], colors[2]);

    }

  }

}





void HSVtoRGB(int hue, int sat, int val, int colors[3]) {



  int r=0, g=0, b=0, base=0;



  if (sat == 0) {

    colors[0]=val;

    colors[1]=val;

    colors[2]=val;

  }

  else {

    base = ((255 - sat) * val)>>8;

    switch(hue/60) {

    case 0:

      r = val;

      g = (((val-base)*hue)/60)+base;

      b = base;

      break;

    case 1:

      r = (((val-base)*(60-(hue%60)))/60)+base;

      g = val;

      b = base;

      break;

    case 2:

      r = base;

      g = val;

      b = (((val-base)*(hue%60))/60)+base;

      break;

    case 3:

      r = base;

      g = (((val-base)*(60-(hue%60)))/60)+base;

      b = val;

      break;

    case 4:

      r = (((val-base)*(hue%60))/60)+base;

      g = base;

      b = val;

      break;

    case 5:

      r = val;

      g = base;

      b = (((val-base)*(60-(hue%60)))/60)+base;

      break;

    }

    colors[0]=r;

    colors[1]=g;

    colors[2]=b;

  }

}





void RGBtoHSV(byte r, byte g, byte b, double hsv[3]) {

    double rd = (double) r/255;

    double gd = (double) g/255;

    double bd = (double) b/255;

    double maxval = rd;

    if (gd > maxval) { maxval = gd; }

    if (bd > maxval) { maxval = bd; }

    double minval = rd;

    if (gd < minval) { minval = gd; }

    if (bd < minval) { minval = bd; }

    double h = 0, s, v = maxval;

    double d = maxval - minval;



    s = maxval == 0 ? 0 : d / maxval;



    if (maxval == minval) {

        h = 0;

    } else {

        if (maxval == rd) {

            h = (gd - bd) / d + (gd < bd ? 6 : 0);

        } else if (maxval == gd) {

            h = (bd - rd) / d + 2;

        } else if (maxval == bd) {

            h = (rd - gd) / d + 4;

        }

        h /= 6;

    }



    hsv[0] = h * 360;

    hsv[1] = s * 255;

    hsv[2] = v * 255;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P043_ClkOutput.ino"
#ifdef USES_P043







#define PLUGIN_043 

#define PLUGIN_ID_043 43

#define PLUGIN_NAME_043 "Output - Clock"

#define PLUGIN_VALUENAME1_043 "Output"

#define PLUGIN_043_MAX_SETTINGS 8



boolean Plugin_043(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_043;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_043);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_043));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        String options[3];

        options[0] = F("");

        options[1] = F("Off");

        options[2] = F("On");



        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

         addFormTextBox(String(F("Day,Time ")) + (x + 1), String(F("plugin_043_clock")) + (x), timeLong2String(ExtraTaskSettings.TaskDevicePluginConfigLong[x]), 32);
# 123 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P043_ClkOutput.ino"
          addHtml(F(" "));

          byte choice = ExtraTaskSettings.TaskDevicePluginConfig[x];

          addSelector(String(F("plugin_043_state")) + (x), 3, options, NULL, NULL, choice, false);

        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

          String argc = F("plugin_043_clock");

          argc += x;

          String plugin1 = WebServer.arg(argc);

          ExtraTaskSettings.TaskDevicePluginConfigLong[x] = string2TimeLong(plugin1);



          argc = F("plugin_043_state");

          argc += x;

          String plugin2 = WebServer.arg(argc);

          ExtraTaskSettings.TaskDevicePluginConfig[x] = plugin2.toInt();

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        success = true;

        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        LoadTaskSettings(event->TaskIndex);

        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

          unsigned long clockEvent = (unsigned long)minute() % 10 | (unsigned long)(minute() / 10) << 4 | (unsigned long)(hour() % 10) << 8 | (unsigned long)(hour() / 10) << 12 | (unsigned long)weekday() << 16;

          unsigned long clockSet = ExtraTaskSettings.TaskDevicePluginConfigLong[x];



          if (matchClockEvent(clockEvent,clockSet))

          {

            byte state = ExtraTaskSettings.TaskDevicePluginConfig[x];

            if (state != 0)

            {

              state--;

              pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

              digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], state);

              UserVar[event->BaseVarIndex] = state;

              String log = F("TCLK : State ");

              log += state;

              addLog(LOG_LEVEL_INFO, log);

              sendData(event);

            }

          }

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P044_P1WifiGateway.ino"
#ifdef USES_P044
# 23 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P044_P1WifiGateway.ino"
#define PLUGIN_044 

#define PLUGIN_ID_044 44

#define PLUGIN_NAME_044 "Communication - P1 Wifi Gateway"

#define PLUGIN_VALUENAME1_044 "P1WifiGateway"



#define STATUS_LED 12

#define P044_BUFFER_SIZE 1024

#define NETBUF_SIZE 600

#define DISABLED 0

#define WAITING 1

#define READING 2

#define CHECKSUM 3

#define DONE 4



boolean Plugin_044_init = false;

boolean serialdebug = false;

char* Plugin_044_serial_buf;

unsigned int bytes_read = 0;

boolean CRCcheck = false;

unsigned int currCRC = 0;

int checkI = 0;



WiFiServer *P1GatewayServer;

WiFiClient P1GatewayClient;



boolean Plugin_044(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte connectionState = 0;

  static int state = DISABLED;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_044;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_044);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_044));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("TCP Port"), F("plugin_044_port"), ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

       addFormNumericBox(F("Baud Rate"), F("plugin_044_baud"), ExtraTaskSettings.TaskDevicePluginConfigLong[1]);

       addFormNumericBox(F("Data bits"), F("plugin_044_data"), ExtraTaskSettings.TaskDevicePluginConfigLong[2]);



        byte choice = ExtraTaskSettings.TaskDevicePluginConfigLong[3];

        String options[3];

        options[0] = F("No parity");

        options[1] = F("Even");

        options[2] = F("Odd");

        int optionValues[3] = { 0, 2, 3 };

        addFormSelector(F("Parity"), F("plugin_044_parity"), 3, options, optionValues, choice);



       addFormNumericBox(F("Stop bits"), F("plugin_044_stop"), ExtraTaskSettings.TaskDevicePluginConfigLong[4]);



       addFormPinSelect(F("Reset target after boot"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);



       addFormNumericBox(F("RX Receive Timeout (mSec)"), F("plugin_044_rxwait"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        ExtraTaskSettings.TaskDevicePluginConfigLong[0] = getFormItemInt(F("plugin_044_port"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[1] = getFormItemInt(F("plugin_044_baud"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[2] = getFormItemInt(F("plugin_044_data"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[3] = getFormItemInt(F("plugin_044_parity"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[4] = getFormItemInt(F("plugin_044_stop"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_044_rxwait"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        pinMode(STATUS_LED, OUTPUT);

        digitalWrite(STATUS_LED, 0);



        LoadTaskSettings(event->TaskIndex);

        if ((ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0) && (ExtraTaskSettings.TaskDevicePluginConfigLong[1] != 0))

        {

          #if defined(ESP8266)

            byte serialconfig = 0x10;

          #endif

          #if defined(ESP32)

            uint32_t serialconfig = 0x8000010;

          #endif

          serialconfig += ExtraTaskSettings.TaskDevicePluginConfigLong[3];

          serialconfig += (ExtraTaskSettings.TaskDevicePluginConfigLong[2] - 5) << 2;

          if (ExtraTaskSettings.TaskDevicePluginConfigLong[4] == 2)

            serialconfig += 0x20;

          #if defined(ESP8266)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], (SerialConfig)serialconfig);

          #endif

          #if defined(ESP32)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], serialconfig);

          #endif

          if (P1GatewayServer) P1GatewayServer->close();

          P1GatewayServer = new WiFiServer(ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

          P1GatewayServer->begin();



          if (!Plugin_044_serial_buf)

            Plugin_044_serial_buf = (char *)malloc(P044_BUFFER_SIZE);



          if (Settings.TaskDevicePin1[event->TaskIndex] != -1)

          {

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], LOW);

            delay(500);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], HIGH);

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

          }



          Plugin_044_init = true;

        }



        blinkLED();



        if (ExtraTaskSettings.TaskDevicePluginConfigLong[1] == 115200) {

          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC on"));

          CRCcheck = true;

        } else {

          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC off"));

          CRCcheck = false;

        }





        state = WAITING;

        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

        if (P1GatewayServer) {

          P1GatewayServer->close();



          P1GatewayServer = NULL;

        }

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_044_init)

        {

          size_t bytes_read;

          if (P1GatewayServer->hasClient())

          {

            if (P1GatewayClient) P1GatewayClient.stop();

            P1GatewayClient = P1GatewayServer->available();

            addLog(LOG_LEVEL_ERROR, F("P1   : Client connected!"));

          }



          if (P1GatewayClient.connected())

          {

            connectionState = 1;

            uint8_t net_buf[P044_BUFFER_SIZE];

            int count = P1GatewayClient.available();

            if (count > 0)

            {

              if (count > P044_BUFFER_SIZE)

                count = P044_BUFFER_SIZE;

              bytes_read = P1GatewayClient.read(net_buf, count);

              Serial.write(net_buf, bytes_read);

              Serial.flush();



              if (count == P044_BUFFER_SIZE)

              {

                count--;



                addLog(LOG_LEVEL_ERROR, F("P1   : Error: network buffer full!"));

              }

              net_buf[count] = 0;

              char log[P044_BUFFER_SIZE + 40];

              sprintf_P(log, PSTR("P1   : Error: N>: %s"), (char*)net_buf);

              addLog(LOG_LEVEL_DEBUG, log);

            }

          }

          else

          {

            if (connectionState == 1)

            {

              connectionState = 0;

              addLog(LOG_LEVEL_ERROR, F("P1   : Client disconnected!"));

            }



            while (Serial.available())

              Serial.read();

          }



          success = true;

        }

        break;

      }



    case PLUGIN_SERIAL_IN:

      {

        if (Plugin_044_init)

        {

          if (P1GatewayClient.connected())

          {

            int RXWait = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            if (RXWait == 0)

              RXWait = 1;

            int timeOut = RXWait;

            while (timeOut > 0)

            {

              while (Serial.available() && state != DONE) {

                if (bytes_read < P044_BUFFER_SIZE - 5) {

                  char ch = Serial.read();

                  digitalWrite(STATUS_LED, 1);

                  switch (state) {

                    case DISABLED:

                      break;

                    case WAITING:

                      if (ch == '/') {

                        Plugin_044_serial_buf[0] = ch;

                        bytes_read=1;

                        state = READING;

                      }

                      break;

                    case READING:

                      if (ch == '!') {

                        if (CRCcheck) {

                          state = CHECKSUM;

                        } else {

                          state = DONE;

                        }

                      }

                      if (validP1char(ch)) {

                        Plugin_044_serial_buf[bytes_read] = ch;

                        bytes_read++;

                      } else if (ch=='/') {

                        addLog(LOG_LEVEL_DEBUG, F("P1   : Error: Start detected, discarded input."));

                        Plugin_044_serial_buf[0] = ch;

                        bytes_read = 1;

                      } else {

                        addLog(LOG_LEVEL_DEBUG, F("P1   : Error: DATA corrupt, discarded input."));

                        Serial.flush();

                        bytes_read = 0;

                        state = WAITING;

                      }

                      break;

                    case CHECKSUM:

                      checkI ++;

                      if (checkI == 4) {

                        checkI = 0;

                        state = DONE;

                      }

                      Plugin_044_serial_buf[bytes_read] = ch;

                      bytes_read++;

                      break;

                    case DONE:







                      break;

                  }

                }

                else

                {

                  Serial.read();

                  bytes_read = 0;

                  state = WAITING;

                }

                digitalWrite(STATUS_LED, 0);

                timeOut = RXWait;

              }

              delay(1);

              timeOut--;

            }



            if (state == DONE) {

              if (checkDatagram(bytes_read)) {

                Plugin_044_serial_buf[bytes_read] = '\r';

                bytes_read++;

                Plugin_044_serial_buf[bytes_read] = '\n';

                bytes_read++;

                Plugin_044_serial_buf[bytes_read] = 0;

                P1GatewayClient.write((const uint8_t*)Plugin_044_serial_buf, bytes_read);

                P1GatewayClient.flush();

                addLog(LOG_LEVEL_DEBUG, F("P1   : data send!"));

                blinkLED();



                if (Settings.UseRules)

                {

                  LoadTaskSettings(event->TaskIndex);

                  String eventString = ExtraTaskSettings.TaskDeviceName;

                  eventString += F("#Data");

                  rulesProcessing(eventString);

                }



              } else {

                addLog(LOG_LEVEL_DEBUG, F("P1   : Error: Invalid CRC, dropped data"));

              }



              bytes_read = 0;

              state = WAITING;

            }

          }

          success = true;

        }

        break;

      }



  }

  return success;

}

void blinkLED() {

  digitalWrite(STATUS_LED, 1);

  delay(500);

  digitalWrite(STATUS_LED, 0);

}
# 699 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P044_P1WifiGateway.ino"
bool validP1char(char ch) {

  if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '.') || (ch == '!') || (ch == ' ') || (ch == 92) || (ch == 13) || (ch == '\n') || (ch == '(') || (ch == ')') || (ch == '-') || (ch == '*') || (ch == ':') )

  {

    return true;

  } else {

    addLog(LOG_LEVEL_DEBUG, F("P1   : Error: invalid char read from P1"));

    if (serialdebug) {

      Serial.print(F("faulty char>"));

      Serial.print(ch);

      Serial.println(F("<"));

    }

    return false;

  }

}



int FindCharInArrayRev(char array[], char c, int len) {

  for (int i = len - 1; i >= 0; i--) {

    if (array[i] == c) {

      return i;

    }

  }

  return -1;

}
# 757 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P044_P1WifiGateway.ino"
unsigned int CRC16(unsigned int crc, unsigned char *buf, int len)

{

  for (int pos = 0; pos < len; pos++)

  {

    crc ^= (unsigned int)buf[pos];



    for (int i = 8; i != 0; i--) {

      if ((crc & 0x0001) != 0) {

        crc >>= 1;

        crc ^= 0xA001;

      }

      else

        crc >>= 1;

    }

  }



  return crc;

}
# 807 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P044_P1WifiGateway.ino"
bool checkDatagram(int len) {

  int startChar = FindCharInArrayRev(Plugin_044_serial_buf, '/', len);

  int endChar = FindCharInArrayRev(Plugin_044_serial_buf, '!', len);

  bool validCRCFound = false;



  if (!CRCcheck) return true;



  if (serialdebug) {

    Serial.print(F("input length: "));

    Serial.println(len);

    Serial.print("Start char \\ : ");

    Serial.println(startChar);

    Serial.print(F("End char ! : "));

    Serial.println(endChar);

  }



  if (endChar >= 0)

  {

    currCRC = CRC16(0x0000, (unsigned char *) Plugin_044_serial_buf, endChar - startChar + 1);



    char messageCRC[5];

    strncpy(messageCRC, Plugin_044_serial_buf + endChar + 1, 4);

    messageCRC[4] = 0;

    if (serialdebug) {

      for (int cnt = 0; cnt < len; cnt++)

        Serial.print(Plugin_044_serial_buf[cnt]);

    }



    validCRCFound = (strtoul(messageCRC, NULL, 16) == currCRC);

    if (!validCRCFound) {

      addLog(LOG_LEVEL_DEBUG, F("P1   : Error: invalid CRC found"));

    }

    currCRC = 0;

  }

  return validCRCFound;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
#ifdef USES_P045
# 117 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
#define MPU6050_RA_GYRO_CONFIG 0x1B

#define MPU6050_RA_ACCEL_CONFIG 0x1C

#define MPU6050_RA_ACCEL_XOUT_H 0x3B

#define MPU6050_RA_PWR_MGMT_1 0x6B

#define MPU6050_ACONFIG_AFS_SEL_BIT 4

#define MPU6050_ACONFIG_AFS_SEL_LENGTH 2

#define MPU6050_GCONFIG_FS_SEL_BIT 4

#define MPU6050_GCONFIG_FS_SEL_LENGTH 2

#define MPU6050_CLOCK_PLL_XGYRO 0x01

#define MPU6050_GYRO_FS_250 0x00

#define MPU6050_ACCEL_FS_2 0x00

#define MPU6050_PWR1_SLEEP_BIT 6

#define MPU6050_PWR1_CLKSEL_BIT 2

#define MPU6050_PWR1_CLKSEL_LENGTH 3



#define PLUGIN_045 

#define PLUGIN_ID_045 45

#define PLUGIN_NAME_045 "Gyro - MPU 6050 [TESTING]"

#define PLUGIN_VALUENAME1_045 ""



int16_t _P045_axis[3][5][2];

unsigned long _P045_time[2];



boolean Plugin_045(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_045;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].FormulaOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_045);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_045));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 243 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
        int optionValues[2];

        optionValues[0] = 0x68;

        optionValues[1] = 0x69;

        addFormSelectorI2C(F("plugin_045_address"), 2, optionValues, choice);

        addFormNote(F("ADDR Low=0x68, High=0x69"));



        choice = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options[10];

        options[0] = F("Movement detection");

        options[1] = F("Range acceleration X");

        options[2] = F("Range acceleration Y");

        options[3] = F("Range acceleration Z");

        options[4] = F("Acceleration X");

        options[5] = F("Acceleration Y");

        options[6] = F("Acceleration Z");

        options[7] = F("G-force X");

        options[8] = F("G-force Y");

        options[9] = F("G-force Z");

        addFormSelector(F("Function"), F("plugin_045_function"), 10, options, NULL, choice);



        if (choice == 0) {





          addHtml(F("<TR><TD><TD>The thresholdvalues (0-65535) can be used to set a threshold for one or more<br>"));

          addHtml(F("axis. The axis will trigger when the range for that axis exceeds the threshold<br>"));

          addHtml(F("value. A value of 0 disables movement detection for that axis."));



         addFormNumericBox(F("Detection threshold X"), F("plugin_045_threshold_x"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 65535);

         addFormNumericBox(F("Detection threshold Y"), F("plugin_045_threshold_y"), Settings.TaskDevicePluginConfig[event->TaskIndex][3], 0, 65535);

         addFormNumericBox(F("Detection threshold Z"), F("plugin_045_threshold_z"), Settings.TaskDevicePluginConfig[event->TaskIndex][4], 0, 65535);



          addHtml(F("<TR><TD><TD>Each 30 seconds a counter for the detection window is increased plus all axis<br>"));

          addHtml(F("are checked and if they *all* exceeded the threshold values, a counter is increased.<br>"));

          addHtml(F("Each period, defined by the [detection window], the counter is checked against<br>"));

          addHtml(F("the [min. detection count] and if found equal or larger, movement is detected.<br>"));

          addHtml(F("If in the next window the [min. detection count] value is not met, movement has stopped."));

          addHtml(F("The [detection window] cannot be smaller than the [min. detection count]."));



         addFormNumericBox(F("Min. detection count"), F("plugin_045_threshold_counter"), Settings.TaskDevicePluginConfig[event->TaskIndex][5], 0, 999999);

         addFormNumericBox(F("Detection window"), F("plugin_045_threshold_window"), Settings.TaskDevicePluginConfig[event->TaskIndex][6], 0, 999999);



        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_045_address"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_045_function"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_045_threshold_x"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_045_threshold_y"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_045_threshold_z"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("plugin_045_threshold_counter"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][6] = getFormItemInt(F("plugin_045_threshold_window"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][6] < Settings.TaskDevicePluginConfig[event->TaskIndex][5]) {

          Settings.TaskDevicePluginConfig[event->TaskIndex][6] = Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {





        uint8_t devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if ((devAddr < 0x68) || (devAddr > 0x69)) {

          devAddr = 0x68;

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = devAddr;

        }



        _P045_writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_XGYRO);

        _P045_writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_250);

        _P045_writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, MPU6050_ACCEL_FS_2);

        _P045_writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, 0);





        int16_t ax, ay, az, gx, gy, gz;

        _P045_getMotion6(devAddr, &ax, &ay, &az, &gx, &gy, &gz);





        Settings.TaskDevicePluginConfig[event->TaskIndex][7] = 0;

        UserVar[event->BaseVarIndex] = 0;

        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = 0;

        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = 0;

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        uint8_t devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte dev = devAddr & 1;





        _P045_getMotion6(devAddr, &_P045_axis[0][3][dev], &_P045_axis[1][3][dev], &_P045_axis[2][3][dev], &_P045_axis[0][4][dev], &_P045_axis[1][4][dev], &_P045_axis[2][4][dev]);



        _P045_trackMinMax(_P045_axis[0][3][dev], &_P045_axis[0][0][dev], &_P045_axis[0][1][dev]);

        _P045_trackMinMax(_P045_axis[1][3][dev], &_P045_axis[1][0][dev], &_P045_axis[1][1][dev]);

        _P045_trackMinMax(_P045_axis[2][3][dev], &_P045_axis[2][0][dev], &_P045_axis[2][1][dev]);
# 483 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
        if (timeOutReached(_P045_time[dev] + 5000))

        {

          _P045_time[dev] = millis();





          for (uint8_t i=0; i<3; i++) {

            _P045_axis[i][2][dev] = abs(_P045_axis[i][1][dev] - _P045_axis[i][0][dev]);

            _P045_axis[i][0][dev] = _P045_axis[i][3][dev];

            _P045_axis[i][1][dev] = _P045_axis[i][3][dev];

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        int devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte dev = devAddr & 1;

        int _P045_Function = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        switch (_P045_Function)

        {



          case 0:

          {



            boolean thresexceed = true;

            byte count = 0;

            for (byte i=0; i<3; i++)

            {



              if (Settings.TaskDevicePluginConfig[event->TaskIndex][i + 2] != 0) {

                if (_P045_axis[i][2][dev] < Settings.TaskDevicePluginConfig[event->TaskIndex][i + 2]) { thresexceed = false; }

              } else { count++; }

            }

            if (count == 3) { thresexceed = false; }





            if (thresexceed) { Settings.TaskDevicePluginConfigLong[event->TaskIndex][0]++; }



            Settings.TaskDevicePluginConfigLong[event->TaskIndex][1]++;



            if (Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] >= Settings.TaskDevicePluginConfig[event->TaskIndex][6]) {



              Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = 0;





              if (Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] >= Settings.TaskDevicePluginConfig[event->TaskIndex][5]) {

                UserVar[event->BaseVarIndex] = 1;

              } else {

                UserVar[event->BaseVarIndex] = 0;

              }





              if (Settings.TaskDevicePluginConfig[event->TaskIndex][7] != UserVar[event->BaseVarIndex]) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][7] = UserVar[event->BaseVarIndex];

                success = true;

              } else {

                success = false;

              }

              Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = 0;

            }





            event->sensorType = SENSOR_TYPE_SWITCH;

            break;

          }



          default:

          {

            uint8_t reqaxis = (_P045_Function - 1) % 3;

            uint8_t reqvar = ((_P045_Function - 1) / 3) + 2;

            UserVar[event->BaseVarIndex] = float(_P045_axis[reqaxis][reqvar][dev]);

            success = true;

            break;

          }

        }

        break;

      }

  }

  return success;

}



void _P045_trackMinMax(int16_t current, int16_t *min, int16_t *max)



{

  if (current > *max)

  {

    *max = current;

  }

  else if (current < *min)

  {

    *min = current;

  }

}
# 697 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
void _P045_getMotion6(uint8_t devAddr, int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {



    uint8_t buffer[14];

    uint8_t count = 0;

    Wire.beginTransmission(devAddr);

    Wire.write(MPU6050_RA_ACCEL_XOUT_H);

    Wire.endTransmission();

    Wire.beginTransmission(devAddr);

    Wire.requestFrom(devAddr, (uint8_t)14);

    for (; Wire.available(); count++) {

        buffer[count] = Wire.read();

    }

    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];

    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];

    *az = (((int16_t)buffer[4]) << 8) | buffer[5];

    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];

    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];

    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];

}
# 751 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
void _P045_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
# 769 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P045_MPU6050.ino"
    uint8_t b;

    Wire.beginTransmission(devAddr);

    Wire.write(regAddr);

    Wire.endTransmission();

    Wire.requestFrom(devAddr, uint8_t(1));

    if (Wire.available()) {

      b = Wire.read();

      uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);

      data <<= (bitStart - length + 1);

      data &= mask;

      b &= ~(mask);

      b |= data;

      Wire.beginTransmission(devAddr);

      Wire.write(regAddr);

      Wire.write(b);

      Wire.endTransmission();

    }

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P046_VentusW266.ino"
#ifdef USES_P046
# 159 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P046_VentusW266.ino"
#ifdef PLUGIN_BUILD_DISABLED



#define PLUGIN_046_DEBUG true



#define PLUGIN_046 

#define PLUGIN_ID_046 46

#define PLUGIN_NAME_046 "Hardware - Ventus W266 [TESTING]"

#define PLUGIN_VALUENAME1_046 ""

#define PLUGIN_VALUENAME2_046 ""

#define PLUGIN_VALUENAME3_046 ""



#define Plugin_046_MagicByte 0x7F

#define Plugin_046_RAW_BUFFER_SIZE 24

#define Plugin_046_Payload 23



int8_t Plugin_046_MOSIpin = -1;

int8_t Plugin_046_SCLKpin = -1;

int8_t Plugin_046_nSELpin = -1;

int8_t Plugin_046_MISOpin = -1;



byte Plugin_046_ISR_Buffer[Plugin_046_RAW_BUFFER_SIZE];



byte Plugin_046_databuffer[Plugin_046_RAW_BUFFER_SIZE];

boolean Plugin_046_ReceiveActive = false;

boolean Plugin_046_MasterSlave = false;

boolean Plugin_046_newData = false;

byte Plugin_046_bitpointer;

byte Plugin_046_bytepointer;

byte Plugin_046_receivedData;





volatile unsigned long Plugin_046_lastrainctr;

volatile int Plugin_046_lastraincount;

volatile float Plugin_046_rainmmph = 0;

volatile unsigned long Plugin_046_laststrikectr;

volatile unsigned int Plugin_046_laststrikecount;

volatile int Plugin_046_strikesph = 0;



void Plugin_046_ISR_nSEL() ICACHE_RAM_ATTR;

void Plugin_046_ISR_SCLK() ICACHE_RAM_ATTR;



boolean Plugin_046(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_046;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].ValueCount = 3;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte nrchoices = 9;

        String options[nrchoices];

        options[0] = F("Main + Temp/Hygro");

        options[1] = F("Wind");

        options[2] = F("Rain");

        options[3] = F("UV");

        options[4] = F("Lightning strikes");

        options[5] = F("Lightning distance");



        options[6] = F("Unknown 1, byte 6");

        options[7] = F("Unknown 2, byte 16");

        options[8] = F("Unknown 3, byte 19");



        addFormSelector(F("Plugin function"), F("plugin_046"), nrchoices, options, NULL, choice);



        if (choice==0) {

          addHtml(F("<TR><TD>1st GPIO (5-MOSI):<TD>"));

          addPinSelect(false, "taskdevicepin1", Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

          addHtml(F("<TR><TD>2nd GPIO (6-SCLK):<TD>"));

          addPinSelect(false, "taskdevicepin2", Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

          addHtml(F("<TR><TD>3rd GPIO (7-nSEL):<TD>"));

          addPinSelect(false, "taskdevicepin3", Settings.TaskDevicePluginConfig[event->TaskIndex][3]);

          addHtml(F("<TR><TD>4th GPIO (8-MISO):<TD>"));

          addPinSelect(false, "taskdeviceport", Settings.TaskDevicePluginConfig[event->TaskIndex][4]);

        }



        switch (choice)

        {

          case (0):

          {

            addHtml(F("<TR><TD><B>Be sure you only have 1 main plugin!</B></TD>"));

            addHtml(F("<TR><TD>Value 1: Temperature, 1 decimal<BR>Value 2: Humidity, 0 decimals"));

            addHtml(F("<BR>Value 3: not used</TD>"));

            break;

          }

          case (1):

          {

            addHtml(F("<TR><TD>Value 1: Direction, 0 decimals<BR>"));

            addHtml(F("Value 2: Average, 1 decimal<Br>Value 3: Gust, 1 decimal</TD>"));

            break;

          }

          case (2):

          {

            addHtml(F("<TR><TD>Value 1: Rain in mm per hour<BR>Value 2: Total rain in mm"));

            addHtml(F("<BR>Value 3: not used</TD>"));

            break;

          }

          case (3):

          {

            addHtml(F("<TR><TD>Value 1: UV, 1 decimal"));

            addHtml(F("<BR>Values 2, 3</TD>"));

            break;

          }

          case (4):

          {

            addHtml(F("<TR><TD>Value 1: Strikes this hour, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (5):

          {

            addHtml(F("<TR><TD>Value 1: Distance in km, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (6):

          {

            addHtml(F("<TR><TD>Value 1: Batterybyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (7):

          {

            addHtml(F("<TR><TD>Value 1: Last rainbyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (8):

          {

            addHtml(F("<TR><TD>Value 1: Last lightningbyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

        }



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_046"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0) {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("taskdevicepin1"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("taskdevicepin2"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("taskdevicepin3"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("taskdeviceport"));

        }

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_046);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_046));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_046));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_046));

        break;

      }



    case PLUGIN_INIT:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        switch (choice)

        {

          case (0):

          {

            Plugin_046_MOSIpin = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Plugin_046_SCLKpin = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

            Plugin_046_nSELpin = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

            Plugin_046_MISOpin = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

            int8_t total = Plugin_046_MOSIpin + Plugin_046_SCLKpin + Plugin_046_nSELpin + Plugin_046_MISOpin;

            if (total > 6) {

              pinMode(Plugin_046_MOSIpin, INPUT);

              pinMode(Plugin_046_SCLKpin, INPUT);

              pinMode(Plugin_046_nSELpin, INPUT);

              pinMode(Plugin_046_MISOpin, INPUT);

              Plugin_046_databuffer[0] = 0;

              Plugin_046_lastrainctr = 0;

              Plugin_046_lastraincount = -1;

              Plugin_046_laststrikectr = 0;

              Plugin_046_laststrikecount = -1;

              attachInterrupt(Plugin_046_SCLKpin, Plugin_046_ISR_SCLK, RISING);

              attachInterrupt(Plugin_046_nSELpin, Plugin_046_ISR_nSEL, CHANGE);

            }

            break;

          }

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0) {

          if (Plugin_046_newData) {

            uint8_t crc = 0xff;

            char data;



            Plugin_046_databuffer[0] = Plugin_046_ISR_Buffer[0];

            for (int i = 1; i < Plugin_046_bytepointer; i++) {

              data = Plugin_046_ISR_Buffer[i];

              Plugin_046_databuffer[i] = data;

              for (int j = 0; j < 8; j++)

              {

                uint8_t mix = (crc ^ data) & 0x01;

                crc >>= 1;

                if (mix) crc ^= 0x8C;

                  data >>= 1;

              }

            }

            Plugin_046_MasterSlave = false;

            Plugin_046_newData = false;

            if (PLUGIN_046_DEBUG) {

              String log = F("Ventus W266 Rcvd(");

              log += getTimeString(':');

              log += F(") ");

              for (int i = 0; i < Plugin_046_Payload; i++) {

                if ((i==2)||(i==3)||(i==4)||(i==9)||(i==10)||(i==14)||(i==17)||(i==18)||(i==20)) {

                  log += F(":");

                }

                char myHex = (Plugin_046_databuffer[i] >> 4) + 0x30;

                if (myHex > 0x39) { myHex += 7; }

                log += myHex;

                myHex = (Plugin_046_databuffer[i] & 0x0f) + 0x30;

                if (myHex > 0x39) { myHex += 7; }

                log += myHex;

              }

              log += F(" > ");

              char myHex = (crc >> 4) + 0x30;

              if (myHex > 0x39) { myHex += 7; }

              log += myHex;

              myHex = (crc & 0x0f) + 0x30;

              if (myHex > 0x39) { myHex += 7; }

              log += myHex;

              addLog(LOG_LEVEL_INFO, log);

            }

            if (crc != 00)

            {

              Plugin_046_databuffer[0] = 0;

            }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_046_databuffer[0] == Plugin_046_MagicByte)

        {

          UserVar[event->BaseVarIndex + 1] = 0;

          byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          switch (choice)

          {

            case (0):

            {

              int myTemp = int((Plugin_046_databuffer[5] * 256) + Plugin_046_databuffer[4]);

              if (myTemp > 0x8000) { myTemp |= 0xffff0000; }

              float temperature = float(myTemp) / 10.0;

              byte myHum = (Plugin_046_databuffer[2] >> 4) * 10 + (Plugin_046_databuffer[2] & 0x0f);

              float humidity = float(myHum);

              UserVar[event->BaseVarIndex] = temperature;

              UserVar[event->BaseVarIndex + 1] = humidity;

              event->sensorType = SENSOR_TYPE_TEMP_HUM;

              break;

            }

            case (1):

            {

              float average = float((Plugin_046_databuffer[11] << 8) + Plugin_046_databuffer[10]) / 10;

              float gust = float((Plugin_046_databuffer[13] << 8) + Plugin_046_databuffer[12]) / 10;

              float bearing = float(Plugin_046_databuffer[9] & 0x0f) * 22.5;

              UserVar[event->BaseVarIndex] = bearing;

              UserVar[event->BaseVarIndex + 1] = average;

              UserVar[event->BaseVarIndex + 2] = gust;

              event->sensorType = SENSOR_TYPE_WIND;

              break;

            }

            case (2):

            {

              float raincnt = float(((Plugin_046_databuffer[15]) * 256 + Plugin_046_databuffer[14]) / 4);

              int rainnow = int(raincnt);

              if (wdcounter < Plugin_046_lastrainctr) { Plugin_046_lastrainctr = wdcounter; }

              if (Plugin_046_lastrainctr > (wdcounter + 10))

              {

                Plugin_046_lastrainctr = wdcounter;

                if (rainnow > Plugin_046_lastraincount)

                {

                  Plugin_046_rainmmph = float(rainnow - Plugin_046_lastraincount) * 12;

                  Plugin_046_lastraincount = rainnow;

                } else {

                  Plugin_046_rainmmph = 0;

                }

              }

              UserVar[event->BaseVarIndex] = Plugin_046_rainmmph;

              UserVar[event->BaseVarIndex + 1] = raincnt;

              break;

            }

            case (3):

            {

              float uvindex = float((Plugin_046_databuffer[17]) / 10);

              UserVar[event->BaseVarIndex] = uvindex;

              break;

            }

            case (4):

            {



              unsigned int strikesnow = int((Plugin_046_databuffer[21]) * 256 + Plugin_046_databuffer[20]);

              if (wdcounter < Plugin_046_laststrikectr) { Plugin_046_laststrikectr = wdcounter; }

              if (Plugin_046_laststrikectr > (wdcounter + 10))

              {

                Plugin_046_laststrikectr = wdcounter;

                if (strikesnow > Plugin_046_laststrikecount)

                {

                  Plugin_046_strikesph = strikesnow - Plugin_046_laststrikecount;

                  Plugin_046_laststrikecount = strikesnow;

                } else {

                  Plugin_046_strikesph = 0;

                }

              }

              UserVar[event->BaseVarIndex] = float(Plugin_046_strikesph);

              break;

            }

            case (5):

            {

              float distance = float(-1);

              if (Plugin_046_databuffer[18] != 0x3F )

              {

                distance = float(Plugin_046_databuffer[18]);

              }

              UserVar[event->BaseVarIndex] = distance;

              break;

            }

            case (6):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[6]);

              break;

            }

            case (7):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[16]);

              break;

            }

            case (8):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[19]);

              break;

            }

          }

          success = true;

        } else {

          success = false;

        }

        break;

      }

    }

    return success;

}



void Plugin_046_ISR_nSEL()

  {

    if (digitalRead(Plugin_046_nSELpin)) {

      Plugin_046_ReceiveActive = false;

      if (Plugin_046_MasterSlave) {

        if (Plugin_046_bytepointer == Plugin_046_Payload) {

          Plugin_046_newData = true;

        }

      }

    } else {

      if (!Plugin_046_newData) {

        Plugin_046_bitpointer = 7;

        Plugin_046_bytepointer = 0;

        Plugin_046_MasterSlave = false;

        Plugin_046_ReceiveActive = true;

      }

    }

  }



void Plugin_046_ISR_SCLK()

  {

    if (Plugin_046_ReceiveActive) {

      if (Plugin_046_MasterSlave) {

        bitWrite(Plugin_046_receivedData, Plugin_046_bitpointer, digitalRead(Plugin_046_MISOpin));

      } else {

        bitWrite(Plugin_046_receivedData, Plugin_046_bitpointer, digitalRead(Plugin_046_MOSIpin));

      }

      if (Plugin_046_bitpointer == 0) {

        Plugin_046_bitpointer = 7;

        if (Plugin_046_receivedData==Plugin_046_MagicByte) {

          Plugin_046_MasterSlave = true;

        }

        Plugin_046_ISR_Buffer[Plugin_046_bytepointer] = Plugin_046_receivedData;

        Plugin_046_bytepointer++;

        if (Plugin_046_bytepointer > Plugin_046_RAW_BUFFER_SIZE) {

          Plugin_046_ReceiveActive = false;

          Plugin_046_MasterSlave = false;

        }

      } else {

        Plugin_046_bitpointer--;

      }

    }

  }

#endif

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
#ifdef USES_P047
# 25 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
#define PLUGIN_047 

#define PLUGIN_ID_047 47

#define PLUGIN_NAME_047 "Environment - Soil moisture sensor [TESTING]"

#define PLUGIN_VALUENAME1_047 "Temperature"

#define PLUGIN_VALUENAME2_047 "Moisture"

#define PLUGIN_VALUENAME3_047 "Light"







#define SOILMOISTURESENSOR_DEFAULT_ADDR 0x20





#define SOILMOISTURESENSOR_GET_CAPACITANCE 0x00

#define SOILMOISTURESENSOR_SET_ADDRESS 0x01

#define SOILMOISTURESENSOR_GET_ADDRESS 0x02

#define SOILMOISTURESENSOR_MEASURE_LIGHT 0x03

#define SOILMOISTURESENSOR_GET_LIGHT 0x04

#define SOILMOISTURESENSOR_GET_TEMPERATURE 0x05

#define SOILMOISTURESENSOR_RESET 0x06

#define SOILMOISTURESENSOR_GET_VERSION 0x07

#define SOILMOISTURESENSOR_SLEEP 0x08

#define SOILMOISTURESENSOR_GET_BUSY 0x09







uint8_t _i2caddrP47;



boolean Plugin_047(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_047;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_047);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_047));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_047));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_047));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormTextBox(F("I2C Address (Hex)"), F("plugin_047_i2cSoilMoisture_i2cAddress"), String(F("0x")) +

         String(Settings.TaskDevicePluginConfig[event->TaskIndex][0],HEX), 4);



        addFormCheckBox(F("Send sensor to sleep"), F("plugin_047_sleep"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



        addFormCheckBox(F("Check sensor version") ,F("plugin_047_version"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addFormSeparator(2);



        addFormCheckBox(F("Change Sensor address"),F("plugin_047_changeAddr"), false);

       addFormTextBox(F("Change I2C Addr. to (Hex)"), F("plugin_047_i2cSoilMoisture_changeAddr"), String(F("0x")) +

         String(Settings.TaskDevicePluginConfig[event->TaskIndex][0],HEX), 4);



        addFormSeparator(2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String plugin1 = WebServer.arg(F("plugin_047_i2cSoilMoisture_i2cAddress"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = (int) strtol(plugin1.c_str(), 0, 16);



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = isFormItemChecked(F("plugin_047_sleep"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_047_version"));



        String plugin4 = WebServer.arg(F("plugin_047_i2cSoilMoisture_changeAddr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = (int) strtol(plugin4.c_str(), 0, 16);



        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = isFormItemChecked(F("plugin_047_changeAddr"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        _i2caddrP47 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]) {



         Plugin_047_getVersion();

          delayBackground(20);

          addLog(LOG_LEVEL_DEBUG, F("SoilMoisture->wake"));

        }



        uint8_t sensorVersion = 0;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {



          sensorVersion = Plugin_047_getVersion();

          if (sensorVersion==0x22 || sensorVersion==0x23) {



          }

          else {

            addLog(LOG_LEVEL_INFO, F("SoilMoisture: Bad Version, no Sensor?"));

            Plugin_047_write8(SOILMOISTURESENSOR_RESET);

            break;

          }

        }





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][4]) {

         addLog(LOG_LEVEL_INFO, String(F("SoilMoisture: Change Address: 0x")) + String(_i2caddrP47,HEX) + String(F("->0x")) +

           String(Settings.TaskDevicePluginConfig[event->TaskIndex][3],HEX));

         if (Plugin_047_setAddress(Settings.TaskDevicePluginConfig[event->TaskIndex][3])) {

           Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

         }

         Settings.TaskDevicePluginConfig[event->TaskIndex][4] = false;

        }





        Plugin_047_write8(SOILMOISTURESENSOR_MEASURE_LIGHT);





        delayBackground(2000);



        float temperature = ((float)Plugin_047_readTemperature()) / 10;

        float moisture = ((float)Plugin_047_readMoisture());

        float light = ((float)Plugin_047_readLight());



        if (temperature>100 || temperature < -40 || moisture > 800 || moisture < 1 || light > 65535 || light < 0) {

            addLog(LOG_LEVEL_INFO, F("SoilMoisture: Bad Reading, resetting Sensor..."));

            Plugin_047_write8(SOILMOISTURESENSOR_RESET);

            success = false;

            break;

        }

        else {

         UserVar[event->BaseVarIndex] = temperature;

         UserVar[event->BaseVarIndex + 1] = moisture;

         UserVar[event->BaseVarIndex + 2] = light;



         String log = F("SoilMoisture: Address: 0x");

         log += String(_i2caddrP47,HEX);

         if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

          log += F(" Version: 0x");

          log += String(sensorVersion,HEX);

         }

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Temperature: ");

         log += temperature;

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Moisture: ");

         log += moisture;

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Light: ");

         log += light;

         addLog(LOG_LEVEL_INFO, log);



         if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]) {



          Plugin_047_write8(SOILMOISTURESENSOR_SLEEP);

          addLog(LOG_LEVEL_DEBUG, F("SoilMoisture->sleep"));

         }

         success = true;

         break;

        }

      }

  }

  return success;

}
# 405 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
void Plugin_047_write8(byte value) {

 Wire.beginTransmission((uint8_t)_i2caddrP47);

 Wire.write(value);

 Wire.endTransmission();

}
# 425 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
void Plugin_047_write8(int reg, int value) {

 Wire.beginTransmission((uint8_t)_i2caddrP47);

 Wire.write(reg);

 Wire.write(value);

 Wire.endTransmission();

}
# 449 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
uint8_t Plugin_047_read8(byte reg)

{

  Wire.beginTransmission((uint8_t)_i2caddrP47);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)_i2caddrP47, (byte)1);

  return Wire.read();

}
# 473 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
uint16_t Plugin_047_read16(byte reg)

{

  uint16_t value;



  Wire.beginTransmission((uint8_t)_i2caddrP47);

  Wire.write((uint8_t)reg);

  Wire.endTransmission();

  Wire.requestFrom((uint8_t)_i2caddrP47, (byte)2);

  value = (Wire.read() << 8) | Wire.read();

  Wire.endTransmission();



  return value;

}
# 509 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
int16_t Plugin_047_readS16(byte reg)

{

  return (int16_t)Plugin_047_read16(reg);

}
# 527 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
float Plugin_047_readTemperature()

{

  return Plugin_047_readS16(SOILMOISTURESENSOR_GET_TEMPERATURE);

}
# 543 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
float Plugin_047_readLight() {

  return Plugin_047_read16(SOILMOISTURESENSOR_GET_LIGHT);

}
# 557 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
unsigned int Plugin_047_readMoisture() {

  return Plugin_047_read16(SOILMOISTURESENSOR_GET_CAPACITANCE);

}





uint8_t Plugin_047_getVersion() {

  return Plugin_047_read8(SOILMOISTURESENSOR_GET_VERSION);

}
# 589 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P047_i2c-soil-moisture-sensor.ino"
bool Plugin_047_setAddress(int addr) {

 Plugin_047_write8(SOILMOISTURESENSOR_SET_ADDRESS, addr);

 Plugin_047_write8(SOILMOISTURESENSOR_RESET);

 delayBackground(1000);

  _i2caddrP47=addr;

  return (Plugin_047_read8(SOILMOISTURESENSOR_GET_ADDRESS) == addr);

}





#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P048_Motorshield_v2.ino"
#ifdef USES_P048
# 25 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P048_Motorshield_v2.ino"
#include <Adafruit_MotorShield.h>



#define PLUGIN_048 

#define PLUGIN_ID_048 48

#define PLUGIN_NAME_048 "Motor - Adafruit Motorshield v2 [TESTING]"

#define PLUGIN_VALUENAME1_048 "MotorShield v2"



uint8_t Plugin_048_MotorShield_address = 0x60;



int Plugin_048_MotorStepsPerRevolution = 200;

int Plugin_048_StepperSpeed = 10;



boolean Plugin_048(byte function, struct EventStruct *event, String& string) {

 boolean success = false;



 Adafruit_MotorShield AFMS;







 switch (function) {



  case PLUGIN_DEVICE_ADD: {

   Device[++deviceCount].Number = PLUGIN_ID_048;

   Device[deviceCount].Type = DEVICE_TYPE_I2C;

   Device[deviceCount].VType = SENSOR_TYPE_NONE;

   Device[deviceCount].Ports = 0;

   Device[deviceCount].PullUpOption = false;

   Device[deviceCount].InverseLogicOption = false;

   Device[deviceCount].FormulaOption = false;

   Device[deviceCount].ValueCount = 0;

   Device[deviceCount].SendDataOption = false;

   Device[deviceCount].TimerOption = false;

   break;

  }



  case PLUGIN_GET_DEVICENAME: {

   string = F(PLUGIN_NAME_048);

   break;

  }



  case PLUGIN_GET_DEVICEVALUENAMES: {

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],

     PSTR(PLUGIN_VALUENAME1_048));

   break;

  }



  case PLUGIN_WEBFORM_LOAD: {



     addFormTextBox(F("I2C Address (Hex)"), F("plugin_048_adr"), String(F("0x")) +

       String(Settings.TaskDevicePluginConfig[event->TaskIndex][0],HEX), 4);



     addFormNumericBox(F("Stepper: steps per revolution"), F("plugin_048_MotorStepsPerRevolution")

       , Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



     addFormNumericBox(F("Stepper speed (rpm)"), F("plugin_048_StepperSpeed")

       , Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



   success = true;

   break;

  }



  case PLUGIN_WEBFORM_SAVE: {

   String plugin1 = WebServer.arg(F("plugin_048_adr"));

   Settings.TaskDevicePluginConfig[event->TaskIndex][0] = (int) strtol(plugin1.c_str(), 0, 16);



   Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_048_MotorStepsPerRevolution"));



   Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_048_StepperSpeed"));

   success = true;

   break;

  }



  case PLUGIN_INIT: {

   Plugin_048_MotorShield_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

   Plugin_048_MotorStepsPerRevolution = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

   Plugin_048_StepperSpeed = Settings.TaskDevicePluginConfig[event->TaskIndex][2];



   success = true;

   break;

  }



  case PLUGIN_READ: {



   success = false;

   break;

  }



  case PLUGIN_WRITE: {



   String tmpString = string;



   String cmd = parseString(tmpString, 1);
# 217 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P048_Motorshield_v2.ino"
   if (cmd.equalsIgnoreCase(F("MotorShieldCMD")))

   {

                                String param1 = parseString(tmpString, 2);

                                String param2 = parseString(tmpString, 3);

                                String param3 = parseString(tmpString, 4);

                                String param4 = parseString(tmpString, 5);

                                String param5 = parseString(tmpString, 6);





    AFMS = Adafruit_MotorShield(Plugin_048_MotorShield_address);

    String log = F("MotorShield: Address: 0x");

    log += String(Plugin_048_MotorShield_address,HEX);

    addLog(LOG_LEVEL_DEBUG, log);



    if (param1.equalsIgnoreCase(F("DCMotor"))) {

     if (param2.toInt() > 0 && param2.toInt() < 5)

     {

      Adafruit_DCMotor *myMotor;

      myMotor = AFMS.getMotor(param2.toInt());

      if (param3.equalsIgnoreCase(F("Forward")))

      {

       byte speed = 255;

       if (param4.toInt() >= 0 && param4.toInt() <= 255)

        speed = param4.toInt();

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Forward Speed: ")) + String(speed));

       myMotor->setSpeed(speed);

       myMotor->run(FORWARD);

       success = true;

      }

      if (param3.equalsIgnoreCase(F("Backward")))

      {

       byte speed = 255;

       if (param4.toInt() >= 0 && param4.toInt() <= 255)

        speed = param4.toInt();

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Backward Speed: ")) + String(speed));

       myMotor->setSpeed(speed);

       myMotor->run(BACKWARD);

       success = true;

      }

      if (param3.equalsIgnoreCase(F("Release")))

      {

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Release")));

       myMotor->run(RELEASE);

       success = true;

      }

     }

    }





    if (param1.equalsIgnoreCase(F("Stepper")))

    {





     if (param2.toInt() > 0 && param2.toInt() < 3)

     {

      Adafruit_StepperMotor *myStepper;

      myStepper = AFMS.getStepper(Plugin_048_MotorStepsPerRevolution, param2.toInt());

      myStepper->setSpeed(Plugin_048_StepperSpeed);

      String log = F("MotorShield: StepsPerRevolution: ");

      log += String(Plugin_048_MotorStepsPerRevolution);

      log += F(" Stepperspeed: ");

      log += String(Plugin_048_StepperSpeed);

      addLog(LOG_LEVEL_DEBUG_MORE, log);



      if (param3.equalsIgnoreCase(F("Forward")))

      {

       if (param4.toInt())

       {

        int steps = param4.toInt();

        if (param5.equalsIgnoreCase(F("SINGLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" SINGLE")));

         myStepper->step(steps, FORWARD, SINGLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("DOUBLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" DOUBLE")));

         myStepper->step(steps, FORWARD, DOUBLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("INTERLEAVE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" INTERLEAVE")));

         myStepper->step(steps, FORWARD, INTERLEAVE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("MICROSTEP")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" MICROSTEP")));

         myStepper->step(steps, FORWARD, MICROSTEP);

         success = true;

        }

       }

      }



      if (param3.equalsIgnoreCase(F("Backward")))

      {

       if (param4.toInt())

       {

        int steps = param4.toInt();

        if (param5.equalsIgnoreCase(F("SINGLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" SINGLE")));

         myStepper->step(steps, BACKWARD, SINGLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("DOUBLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" DOUBLE")));

         myStepper->step(steps, BACKWARD, DOUBLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("INTERLEAVE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" INTERLEAVE")));

         myStepper->step(steps, BACKWARD, INTERLEAVE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("MICROSTEP")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" MICROSTEP")));

         myStepper->step(steps, BACKWARD, MICROSTEP);

         success = true;

        }



       }

      }



      if (param3.equalsIgnoreCase(F("Release")))

      {

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Release.")));

       myStepper->release();

       success = true;

      }



     }

    }



   }



   break;

  }



 }

 return success;

}





#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P049_MHZ19.ino"
#ifdef USES_P049
# 55 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P049_MHZ19.ino"
#define PLUGIN_049 

#define PLUGIN_ID_049 49

#define PLUGIN_NAME_049 "Gases - CO2 MH-Z19"

#define PLUGIN_VALUENAME1_049 "PPM"

#define PLUGIN_VALUENAME2_049 "Temperature"

#define PLUGIN_VALUENAME3_049 "U"

#define PLUGIN_READ_TIMEOUT 3000



#define PLUGIN_049_FILTER_OFF 1

#define PLUGIN_049_FILTER_OFF_ALLSAMPLES 2

#define PLUGIN_049_FILTER_FAST 3

#define PLUGIN_049_FILTER_MEDIUM 4

#define PLUGIN_049_FILTER_SLOW 5



boolean Plugin_049_init = false;



boolean Plugin_049_ABC_Disable = false;

boolean Plugin_049_ABC_MustApply = false;



#include <ESPeasySoftwareSerial.h>

ESPeasySoftwareSerial *Plugin_049_SoftSerial;



enum mhzCommands : byte { mhzCmdReadPPM,

                          mhzCmdCalibrateZero,

                          mhzCmdABCEnable,

                          mhzCmdABCDisable,

                          mhzCmdReset,

#ifdef ENABLE_DETECTION_RANGE_COMMANDS

                          mhzCmdMeasurementRange1000,

                          mhzCmdMeasurementRange2000,

                          mhzCmdMeasurementRange3000,

                          mhzCmdMeasurementRange5000

#endif

                        };
# 183 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P049_MHZ19.ino"
const PROGMEM byte mhzCmdData[][3] = {

  {0x86,0x00,0x00},

  {0x87,0x00,0x00},

  {0x79,0xA0,0x00},

  {0x79,0x00,0x00},

  {0x8d,0x00,0x00},

#ifdef ENABLE_DETECTION_RANGE_COMMANDS

  {0x99,0x03,0xE8},

  {0x99,0x07,0xD0},

  {0x99,0x0B,0xB8},

  {0x99,0x13,0x88}

#endif

  };



byte mhzResp[9];



enum

{

  ABC_enabled = 0x01,

  ABC_disabled = 0x02

};



boolean Plugin_049_Check_and_ApplyFilter(unsigned int prevVal, unsigned int &newVal, uint32_t s, const int filterValue, String& log) {

  if (s == 1) {



    return false;

  }

  if (prevVal < 400 || prevVal > 5000) {





    return true;

  }

  boolean filterApplied = filterValue > PLUGIN_049_FILTER_OFF_ALLSAMPLES;

  int32_t difference = newVal - prevVal;

  if (s > 0 && s < 64 && filterValue != PLUGIN_049_FILTER_OFF) {
# 269 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P049_MHZ19.ino"
    difference = difference * s;

    difference /= 64;

    log += F("Compensate Unstable ");

    filterApplied = true;

  }

  switch (filterValue) {

    case PLUGIN_049_FILTER_OFF: {

      if (s != 0 && s != 64) {

        log += F("Skip Unstable ");

        return false;

      }

      filterApplied = false;

      break;

    }



    case PLUGIN_049_FILTER_OFF_ALLSAMPLES: filterApplied = false; break;

    case PLUGIN_049_FILTER_FAST: difference /= 2; break;

    case PLUGIN_049_FILTER_MEDIUM: difference /= 4; break;

    case PLUGIN_049_FILTER_SLOW: difference /= 8; break;

  }

  if (filterApplied) {

    log += F("Raw PPM: ");

    log += newVal;

    log += F(" Filtered ");

  }

  newVal = static_cast<unsigned int>(prevVal + difference);

  return true;

}



boolean Plugin_049(byte function, struct EventStruct *event, String& string)

{

  bool success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_049;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_049);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_049));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_049));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_049));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2] = { F("Normal"), F("ABC disabled") };

        int optionValues[2] = { ABC_enabled, ABC_disabled };

        addFormSelector(F("Auto Base Calibration"), F("plugin_049_abcdisable"), 2, options, optionValues, choice);

        byte choiceFilter = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String filteroptions[5] = { F("Skip Unstable"), F("Use Unstable"), F("Fast Response"), F("Medium Response"), F("Slow Response") };

        int filteroptionValues[5] = {

          PLUGIN_049_FILTER_OFF,

          PLUGIN_049_FILTER_OFF_ALLSAMPLES,

          PLUGIN_049_FILTER_FAST,

          PLUGIN_049_FILTER_MEDIUM,

          PLUGIN_049_FILTER_SLOW };

        addFormSelector(F("Filter"), F("plugin_049_filter"), 5, filteroptions, filteroptionValues, choiceFilter);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        const int formValue = getFormItemInt(F("plugin_049_abcdisable"));

        boolean new_ABC_disable = (formValue == ABC_disabled);

        if (Plugin_049_ABC_Disable != new_ABC_disable) {



          Plugin_049_ABC_MustApply = true;

          Plugin_049_ABC_Disable = new_ABC_disable;

        }

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = formValue;

        const int filterValue = getFormItemInt(F("plugin_049_filter"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = filterValue;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_049_ABC_Disable = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == ABC_disabled;

        if (Plugin_049_ABC_Disable) {



          Plugin_049_ABC_MustApply = true;

        }

        Plugin_049_SoftSerial = new ESPeasySoftwareSerial(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex]);

        Plugin_049_SoftSerial->begin(9600);

        addLog(LOG_LEVEL_INFO, F("MHZ19: Init OK "));







        timerSensor[event->TaskIndex] = millis() + 15000;



        Plugin_049_init = true;

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String command = parseString(string, 1);



        if (command == F("mhzcalibratezero"))

        {

          _P049_send_mhzCmd(mhzCmdCalibrateZero);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Calibrated zero point!"));

          success = true;

        }



        if (command == F("mhzreset"))

        {

          _P049_send_mhzCmd(mhzCmdReset);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor reset!"));

          success = true;

        }



        if (command == F("mhzabcenable"))

        {

          _P049_send_mhzCmd(mhzCmdABCEnable);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Enable!"));

          success = true;

        }



        if (command == F("mhzabcdisable"))

        {

          _P049_send_mhzCmd(mhzCmdABCDisable);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Disable!"));

          success = true;

        }



#ifdef ENABLE_DETECTION_RANGE_COMMANDS

        if (command == F("mhzmeasurementrange1000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange1000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-1000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange2000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange2000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-2000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange3000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange3000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-3000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange5000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange5000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-5000PPM!"));

          success = true;

        }

#endif

        break;



      }



    case PLUGIN_READ:

      {



        if (Plugin_049_init)

        {



          byte nbBytesSent = _P049_send_mhzCmd(mhzCmdReadPPM);

          if (nbBytesSent != 9) {

            String log = F("MHZ19: Error, nb bytes sent != 9 : ");

              log += nbBytesSent;

              addLog(LOG_LEVEL_INFO, log);

          }





          memset(mhzResp, 0, sizeof(mhzResp));



          long timer = millis() + PLUGIN_READ_TIMEOUT;

          int counter = 0;

          while (!timeOutReached(timer) && (counter < 9)) {

            if (Plugin_049_SoftSerial->available() > 0) {

              mhzResp[counter++] = Plugin_049_SoftSerial->read();

            } else {

              delay(10);

            }

          }

          if (counter < 9){

              addLog(LOG_LEVEL_INFO, F("MHZ19: Error, timeout while trying to read"));

          }



          unsigned int ppm = 0;

          signed int temp = 0;

          unsigned int s = 0;

          float u = 0;

          byte checksum = _P049_calculateChecksum(mhzResp);



          if ( !(mhzResp[8] == checksum) ) {

             String log = F("MHZ19: Read error: checksum = ");

             log += String(checksum); log += " / "; log += String(mhzResp[8]);

             log += " bytes read  => ";for (byte i = 0; i < 9; i++) {log += mhzResp[i];log += "/" ;}

             addLog(LOG_LEVEL_ERROR, log);
# 735 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P049_MHZ19.ino"
             byte checksum_shift;

             for (byte i = 1; i < 8; i++) {

                checksum_shift = Plugin_049_SoftSerial->peek();

                if (checksum_shift == 0xFF) {

                  String log = F("MHZ19: Shifted ");

                  log += i;

                  log += F(" bytes to attempt to fix buffer alignment");

                  addLog(LOG_LEVEL_ERROR, log);

                  break;

                } else {

                 checksum_shift = Plugin_049_SoftSerial->read();

                }

             }

             success = false;

             break;





          } else if (mhzResp[0] == 0xFF && mhzResp[1] == 0x86 && mhzResp[8] == checksum) {





              unsigned int mhzRespHigh = (unsigned int) mhzResp[2];

              unsigned int mhzRespLow = (unsigned int) mhzResp[3];

              ppm = (256*mhzRespHigh) + mhzRespLow;





              unsigned int mhzRespTemp = (unsigned int) mhzResp[4];

              temp = mhzRespTemp - 40;





              unsigned int mhzRespS = (unsigned int) mhzResp[5];

              s = mhzRespS;





              unsigned int mhzRespUHigh = (unsigned int) mhzResp[6];

              unsigned int mhzRespULow = (unsigned int) mhzResp[7];

              u = (256*mhzRespUHigh) + mhzRespULow;



              String log = F("MHZ19: ");







              if (u == 15000) {



                log += F("Bootup detected! ");

                if (Plugin_049_ABC_Disable) {





                  Plugin_049_ABC_MustApply = true;

                  log += F("Will disable ABC when bootup complete. ");

                }

                success = false;



              } else {

                const int filterValue = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

                if (Plugin_049_Check_and_ApplyFilter(UserVar[event->BaseVarIndex], ppm, s, filterValue, log)) {

                  UserVar[event->BaseVarIndex] = (float)ppm;

                  UserVar[event->BaseVarIndex + 1] = (float)temp;

                  UserVar[event->BaseVarIndex + 2] = (float)u;

                  if (s==0 || s==64) {



                    if (Plugin_049_ABC_MustApply) {



                      if (Plugin_049_ABC_Disable) {

                        _P049_send_mhzCmd(mhzCmdABCDisable);

                        addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Disable!"));

                      } else {

                        _P049_send_mhzCmd(mhzCmdABCEnable);

                        addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Enable!"));

                      }

                      Plugin_049_ABC_MustApply = false;

                    }

                  }

                  success = true;

                } else {

                  success = false;

                }

              }





              log += F("PPM value: ");

              log += ppm;

              log += F(" Temp/S/U values: ");

              log += temp;

              log += F("/");

              log += s;

              log += F("/");

              log += u;

              addLog(LOG_LEVEL_INFO, log);

              break;







          } else if (mhzResp[0] == 0xFF && mhzResp[1] == 0x99 && mhzResp[8] == checksum) {



            addLog(LOG_LEVEL_INFO, F("MHZ19: Received measurement range acknowledgment! "));

            addLog(LOG_LEVEL_INFO, F("Expecting sensor reset..."));

            success = false;

            break;







          } else {



              String log = F("MHZ19: Unknown response:");

              for (int i = 0; i < 9; ++i) {

                log += F(" ");

                log += String(mhzResp[i], HEX);

              }

              addLog(LOG_LEVEL_INFO, log);

              success = false;

              break;



          }



        }

        break;

      }

  }

  return success;

}



byte _P049_calculateChecksum(byte *array)

{

  byte checksum = 0;

  for (byte i = 1; i < 8; i++)

    checksum+=array[i];

  checksum = 0xFF - checksum;

  return (checksum+1);

}



size_t _P049_send_mhzCmd(byte CommandId)

{



  mhzResp[0] = 0xFF;

  mhzResp[1] = 0x01;

  memcpy_P(&mhzResp[2], mhzCmdData[CommandId], sizeof(mhzCmdData[0]));

  mhzResp[6] = mhzResp[3]; mhzResp[7] = mhzResp[4];

  mhzResp[3] = mhzResp[4] = mhzResp[5] = 0x00;

  mhzResp[8] = _P049_calculateChecksum(mhzResp);



  return Plugin_049_SoftSerial->write(mhzResp, sizeof(mhzResp));

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P050_TCS34725.ino"
#ifdef USES_P050
# 25 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P050_TCS34725.ino"
#include "Adafruit_TCS34725.h"



#define PLUGIN_050 

#define PLUGIN_ID_050 50

#define PLUGIN_NAME_050 "Color - TCS34725  [DEVELOPMENT]"

#define PLUGIN_VALUENAME1_050 "Red"

#define PLUGIN_VALUENAME2_050 "Green"

#define PLUGIN_VALUENAME3_050 "Blue"

#define PLUGIN_VALUENAME4_050 "Color Temperature"
# 51 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P050_TCS34725.ino"
boolean Plugin_050(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_050;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_050);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_050));

        break;

      }





    case PLUGIN_WEBFORM_LOAD:

      {

        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String optionsMode[6];

        optionsMode[0] = F("TCS34725_INTEGRATIONTIME_2_4MS");

        optionsMode[1] = F("TCS34725_INTEGRATIONTIME_24MS");

        optionsMode[2] = F("TCS34725_INTEGRATIONTIME_50MS");

        optionsMode[3] = F("TCS34725_INTEGRATIONTIME_101MS");

        optionsMode[4] = F("TCS34725_INTEGRATIONTIME_154MS");

        optionsMode[5] = F("TCS34725_INTEGRATIONTIME_700MS");

        int optionValuesMode[6];

        optionValuesMode[0] = TCS34725_INTEGRATIONTIME_2_4MS;

        optionValuesMode[1] = TCS34725_INTEGRATIONTIME_24MS;

        optionValuesMode[2] = TCS34725_INTEGRATIONTIME_50MS;

        optionValuesMode[3] = TCS34725_INTEGRATIONTIME_101MS;

        optionValuesMode[4] = TCS34725_INTEGRATIONTIME_154MS;

        optionValuesMode[5] = TCS34725_INTEGRATIONTIME_700MS;

        addFormSelector(F("Integration Time"), F("plugin_050_integrationTime"), 6, optionsMode, optionValuesMode, choiceMode);



        byte choiceMode2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String optionsMode2[4];

        optionsMode2[0] = F("TCS34725_GAIN_1X");

        optionsMode2[1] = F("TCS34725_GAIN_4X");

        optionsMode2[2] = F("TCS34725_GAIN_16X");

        optionsMode2[3] = F("TCS34725_GAIN_60X");

        int optionValuesMode2[4];

        optionValuesMode2[0] = TCS34725_GAIN_1X;

        optionValuesMode2[1] = TCS34725_GAIN_4X;

        optionValuesMode2[2] = TCS34725_GAIN_16X;

        optionValuesMode2[3] = TCS34725_GAIN_60X;

        addFormSelector(F("Gain"), F("plugin_050_gain"), 4, optionsMode2, optionValuesMode2, choiceMode2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String plugin1 = WebServer.arg(F("plugin_050_integrationTime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = plugin1.toInt();

        String plugin2 = WebServer.arg(F("plugin_050_gain"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = plugin2.toInt();



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       tcs34725IntegrationTime_t integrationTime;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_2_4MS)

         integrationTime = TCS34725_INTEGRATIONTIME_2_4MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_24MS)

         integrationTime = TCS34725_INTEGRATIONTIME_24MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_50MS)

         integrationTime = TCS34725_INTEGRATIONTIME_50MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_101MS)

         integrationTime = TCS34725_INTEGRATIONTIME_101MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_154MS)

         integrationTime = TCS34725_INTEGRATIONTIME_154MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_700MS)

         integrationTime = TCS34725_INTEGRATIONTIME_700MS;



        tcs34725Gain_t gain;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_1X)

         gain = TCS34725_GAIN_1X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_4X)

         gain = TCS34725_GAIN_4X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_16X)

         gain = TCS34725_GAIN_16X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_60X)

         gain = TCS34725_GAIN_60X;





       Adafruit_TCS34725 tcs = Adafruit_TCS34725(integrationTime, gain);

        if (tcs.begin()) {



         addLog(LOG_LEVEL_DEBUG, F("Found TCS34725 sensor"));



          uint16_t r, g, b, c;



          tcs.getRawData(&r, &g, &b, &c);

          tcs.calculateColorTemperature(r, g, b);

          tcs.calculateLux(r, g, b);



          UserVar[event->BaseVarIndex] = r;

          UserVar[event->BaseVarIndex + 1] = g;

          UserVar[event->BaseVarIndex + 2] = b;

          UserVar[event->BaseVarIndex + 3] = tcs.calculateColorTemperature(r, g, b);



          String log = F("TCS34725: Color Temp (K): ");

          log += String(UserVar[event->BaseVarIndex + 3], DEC);

          log += F(" R: ");

          log += String(UserVar[event->BaseVarIndex], DEC);

          log += F(" G: ");

          log += String(UserVar[event->BaseVarIndex + 1], DEC);

          log += F(" B: ");

          log += String(UserVar[event->BaseVarIndex + 2], DEC);

          addLog(LOG_LEVEL_INFO, log);

          success = true;



        } else {

         addLog(LOG_LEVEL_DEBUG, F("No TCS34725 found"));

         success = false;

        }



        break;

      }



  }

  return success;

}





#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P051_AM2320.ino"
#ifdef USES_P051
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P051_AM2320.ino"
#include <AM2320.h>



#define PLUGIN_051 

#define PLUGIN_ID_051 51

#define PLUGIN_NAME_051 "Environment - AM2320 [TESTING]"

#define PLUGIN_VALUENAME1_051 "Temperature"

#define PLUGIN_VALUENAME2_051 "Humidity"
# 49 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P051_AM2320.ino"
boolean Plugin_051(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_051;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_051);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_051));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_051));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       AM2320 th;



        switch(th.Read()) {

          case 2:

           addLog(LOG_LEVEL_ERROR, F("AM2320: CRC failed"));

            break;

          case 1:

           addLog(LOG_LEVEL_ERROR, F("AM2320: Sensor offline"));

            break;

          case 0:

           UserVar[event->BaseVarIndex] = th.t;

           UserVar[event->BaseVarIndex + 1] = th.h;



           String log = F("AM2320: Temperature: ");

           log += UserVar[event->BaseVarIndex];

           addLog(LOG_LEVEL_INFO, log);

           log = F("AM2320: Humidity: ");

           log += UserVar[event->BaseVarIndex + 1];

           addLog(LOG_LEVEL_INFO, log);

            success = true;

            break;

        }





      }

  }

  return success;

}





#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
#ifdef USES_P052
# 21 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
#define PLUGIN_052 
#define PLUGIN_ID_052 52
#define PLUGIN_NAME_052 "Gases - CO2 Senseair"
#define PLUGIN_VALUENAME1_052 ""

boolean Plugin_052_init = false;

#include <ESPeasySoftwareSerial.h>
ESPeasySoftwareSerial *Plugin_052_SoftSerial;

boolean Plugin_052(byte function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_052;
        Device[deviceCount].Type = DEVICE_TYPE_DUAL;
        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_052);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_052));
        break;
      }

      case PLUGIN_WRITE:
          {
            String tmpString = string;

         String cmd = parseString(tmpString, 1);
         String param1 = parseString(tmpString, 2);


            if (cmd.equalsIgnoreCase(F("senseair_setrelay")))
            {
              if (param1.toInt() == 0 || param1.toInt() == 1 || param1.toInt() == -1) {
                Plugin_052_setRelayStatus(param1.toInt());
                addLog(LOG_LEVEL_INFO, String(F("Senseair command: relay=")) + param1);
              }
              success = true;
            }
# 96 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
            break;
          }

    case PLUGIN_WEBFORM_LOAD:
      {
          byte choiceSensor = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          String optionsSensor[7] = { F("Error Status"), F("Carbon Dioxide"), F("Temperature"), F("Humidity"), F("Relay Status"), F("Temperature Adjustment"), F("ABC period") };
          addFormSelector(F("Sensor"), F("plugin_052_sensor"), 7, optionsSensor, NULL, choiceSensor);
# 114 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
          success = true;
          break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_052_sensor"));






        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        Plugin_052_init = true;
        Plugin_052_SoftSerial = new ESPeasySoftwareSerial(Settings.TaskDevicePin1[event->TaskIndex],
                                                   Settings.TaskDevicePin2[event->TaskIndex]);
# 146 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
        success = true;
        break;
      }

    case PLUGIN_READ:
      {

        if (Plugin_052_init)
        {

          String log = F("Senseair: ");
          switch(Settings.TaskDevicePluginConfig[event->TaskIndex][0])
          {
              case 0:
              {
                  int errorWord = Plugin_052_readErrorStatus();
                  for (size_t i = 0; i < 9; i++) {
                    if (bitRead(errorWord,i)) {
                      UserVar[event->BaseVarIndex] = i;
                      log += F("error code = ");
                      log += i;
                      break;
                    }
                  }

                  UserVar[event->BaseVarIndex] = -1;
                  log += F("error code = ");
                  log += -1;
                  break;
              }
              case 1:
              {
                  int co2 = Plugin_052_readCo2();
                  UserVar[event->BaseVarIndex] = co2;
                  log += F("co2 = ");
                  log += co2;
                  break;
              }
              case 2:
              {
                  float temperature = Plugin_052_readTemperature();
                  UserVar[event->BaseVarIndex] = (float)temperature;
                  log += F("temperature = ");
                  log += (float)temperature;
                  break;
              }
              case 3:
              {
                  float relativeHumidity = Plugin_052_readRelativeHumidity();
                  UserVar[event->BaseVarIndex] = (float)relativeHumidity;
                  log += F("humidity = ");
                  log += (float)relativeHumidity;
                  break;
              }
              case 4:
              {
                  int relayStatus = Plugin_052_readRelayStatus();
                  UserVar[event->BaseVarIndex] = relayStatus;
                  log += F("relay status = ");
                  log += relayStatus;
                  break;
              }
              case 5:
              {
                  int temperatureAdjustment = Plugin_052_readTemperatureAdjustment();
                  UserVar[event->BaseVarIndex] = temperatureAdjustment;
                  log += F("temperature adjustment = ");
                  log += temperatureAdjustment;
                  break;
              }
              case 6:
              {
                  int period = Plugin_052_readABCperiod();
                  UserVar[event->BaseVarIndex] = period;
                  log += F("ABC period = ");
                  log += period;
                  break;
              }
          }
          addLog(LOG_LEVEL_INFO, log);

          success = true;
          break;
        }
        break;
      }
  }
  return success;
}

void Plugin_052_buildFrame(byte slaveAddress,
              byte functionCode,
              short startAddress,
              short numberOfRegisters,
              byte frame[8])
{
  frame[0] = slaveAddress;
  frame[1] = functionCode;
  frame[2] = (byte)(startAddress >> 8);
  frame[3] = (byte)(startAddress);
  frame[4] = (byte)(numberOfRegisters >> 8);
  frame[5] = (byte)(numberOfRegisters);

  byte checkSum[2] = {0};
  Plugin_052_ModRTU_CRC(frame, 6, checkSum);
  frame[6] = checkSum[0];
  frame[7] = checkSum[1];
}

int Plugin_052_sendCommand(byte command[])
{
  byte recv_buf[7] = {0xff};
  byte data_buf[2] = {0xff};
  long value = -1;

  Plugin_052_SoftSerial->write(command, 8);
  delay(50);


  int ByteCounter = 0;
  while(Plugin_052_SoftSerial->available()) {
    recv_buf[ByteCounter] = Plugin_052_SoftSerial->read();
    ByteCounter++;
  }

  data_buf[0] = recv_buf[3];
  data_buf[1] = recv_buf[4];
  value = (data_buf[0] << 8) | (data_buf[1]);

  return value;
}

int Plugin_052_readErrorStatus(void)
{
  int errorBits = 0;
  int error_Status = -1;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x00, 1, frame);
  errorBits = Plugin_052_sendCommand(frame);
  for (size_t i = 0; i < 15; i++) {
    if (getBitOfInt(errorBits, i) == 1) {
      error_Status = i;
    }
  }
  return error_Status;
}

int Plugin_052_readCo2(void)
{
  int co2 = 0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x03, 1, frame);
  co2 = Plugin_052_sendCommand(frame);
  return co2;
}

float Plugin_052_readTemperature(void)
{
  int temperatureX100 = 0;
  float temperature = 0.0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x04, 1, frame);
  temperatureX100 = Plugin_052_sendCommand(frame);
  temperature = (float)temperatureX100/100;
  return temperature;
}

float Plugin_052_readRelativeHumidity(void)
{
  int rhX100 = 0;
  float rh = 0.0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x05, 1, frame);
  rhX100 = Plugin_052_sendCommand(frame);
  rh = (float)rhX100/100;
  return rh;
}

int Plugin_052_readRelayStatus(void)
{
  int status = 0;
  bool result;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x04, 0x1C, 1, frame);
  status = Plugin_052_sendCommand(frame);
  result = status >> 8 & 0x1;

  return result;
}

int Plugin_052_readTemperatureAdjustment(void)
{
  int value = 0;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x04, 0x0A, 1, frame);
  value = Plugin_052_sendCommand(frame);

  return value;
}

void Plugin_052_setRelayStatus(int status) {

  byte frame[8] = {0};
  if (status == 0) {
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x0000, frame);
  } else if (status == 1){
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x3FFF, frame);
  } else {
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x7FFF, frame);
  }
  Plugin_052_sendCommand(frame);
}

int Plugin_052_readABCperiod(void)
{
  int period = 0;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x03, 0x001F, 0x0001, frame);
  period = Plugin_052_sendCommand(frame);

  return period;
}
# 385 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P052_SenseAir.ino"
unsigned int Plugin_052_ModRTU_CRC(byte buf[], int len, byte checkSum[2])
{
  unsigned int crc = 0xFFFF;

  for (int pos = 0; pos < len; pos++) {
    crc ^= (unsigned int)buf[pos];

    for (int i = 8; i != 0; i--) {
      if ((crc & 0x0001) != 0) {
        crc >>= 1;
        crc ^= 0xA001;
      }
      else
        crc >>= 1;
    }
  }

  checkSum[1] = (byte)((crc >> 8) & 0xFF);
  checkSum[0] = (byte)(crc & 0xFF);
  return crc;
}

int getBitOfInt(int reg, int pos)
{

  int mask = 0x01 << pos;


  int masked_register = mask & reg;


  int result = masked_register >> pos;

  return result;
}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P053_PMSx003.ino"
#ifdef USES_P053
# 25 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P053_PMSx003.ino"
#include <ESPeasySoftwareSerial.h>



#define PLUGIN_053 

#define PLUGIN_ID_053 53

#define PLUGIN_NAME_053 "Dust - PMSx003"

#define PLUGIN_VALUENAME1_053 "pm1.0"

#define PLUGIN_VALUENAME2_053 "pm2.5"

#define PLUGIN_VALUENAME3_053 "pm10"

#define PMSx003_SIG1 0X42

#define PMSx003_SIG2 0X4d

#define PMSx003_SIZE 32



ESPeasySoftwareSerial *swSerial = NULL;

boolean Plugin_053_init = false;

boolean values_received = false;
# 63 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P053_PMSx003.ino"
void SerialRead16(uint16_t* value, uint16_t* checksum)

{

  uint8_t data_high, data_low;





  if (swSerial != NULL)

  {

    data_high = swSerial->read();

    data_low = swSerial->read();

  }

  else

  {

    data_high = Serial.read();

    data_low = Serial.read();

  }



  *value = data_low;

  *value |= (data_high << 8);



  if (checksum != NULL)

  {

    *checksum += data_high;

    *checksum += data_low;

  }



#if 0



  String log = F("PMSx003 : byte high=0x");

  log += String(data_high,HEX);

  log += F(" byte low=0x");

  log += String(data_low,HEX);

  log += F(" result=0x");

  log += String(*value,HEX);

  addLog(LOG_LEVEL_INFO, log);

#endif

}



void SerialFlush() {

  if (swSerial != NULL) {

    swSerial->flush();

  } else {

    Serial.flush();

  }

}



boolean PacketAvailable(void)

{

  if (swSerial != NULL)

  {





    if (!swSerial->available()) return false;

    while ((swSerial->peek() != PMSx003_SIG1) && swSerial->available()) {

      swSerial->read();

    }

    if (swSerial->available() < PMSx003_SIZE) return false;

  }

  else

  {





    if (!Serial.available()) return false;

    while ((Serial.peek() != PMSx003_SIG1) && Serial.available()) {

      Serial.read();

    }

    if (Serial.available() < PMSx003_SIZE) return false;

  }

  return true;

}



boolean Plugin_053_process_data(struct EventStruct *event) {

  String log;

  uint16_t checksum = 0, checksum2 = 0;

  uint16_t framelength = 0;

  uint16 packet_header = 0;

  SerialRead16(&packet_header, &checksum);

  if (packet_header != ((PMSx003_SIG1 << 8) | PMSx003_SIG2)) {



    return false;

  }



  SerialRead16(&framelength, &checksum);

  if (framelength != (PMSx003_SIZE - 4))

  {

    log = F("PMSx003 : invalid framelength - ");

    log += framelength;

    addLog(LOG_LEVEL_ERROR, log);

    return false;

  }



  uint16_t data[13];

  for (int i = 0; i < 13; i++)

    SerialRead16(&data[i], &checksum);



  log = F("PMSx003 : pm1.0=");

  log += data[0];

  log += F(", pm2.5=");

  log += data[1];

  log += F(", pm10=");

  log += data[2];

  log += F(", pm1.0a=");

  log += data[3];

  log += F(", pm2.5a=");

  log += data[4];

  log += F(", pm10a=");

  log += data[5];

  addLog(LOG_LEVEL_DEBUG, log);



  log = F("PMSx003 : count/0.1L : 0.3um=");

  log += data[6];

  log += F(", 0.5um=");

  log += data[7];

  log += F(", 1.0um=");

  log += data[8];

  log += F(", 2.5um=");

  log += data[9];

  log += F(", 5.0um=");

  log += data[10];

  log += F(", 10um=");

  log += data[11];

  addLog(LOG_LEVEL_DEBUG_MORE, log);





  SerialRead16(&checksum2, NULL);

  SerialFlush();

  if (checksum == checksum2)

  {



    UserVar[event->BaseVarIndex] = data[3];

    UserVar[event->BaseVarIndex + 1] = data[4];

    UserVar[event->BaseVarIndex + 2] = data[5];

    values_received = true;

    return true;

  }

  return false;

}



boolean Plugin_053(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_053;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_053);

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_053));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_053));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_053));

        success = true;

        break;

      }



      case PLUGIN_GET_DEVICEGPIONAMES:

        {

          event->String1 = F("GPIO &larr; TX");

          event->String2 = F("GPIO &rarr; RX");

          event->String3 = F("GPIO &rarr; Reset");

          break;

        }



    case PLUGIN_INIT:

      {

        int rxPin = Settings.TaskDevicePin1[event->TaskIndex];

        int txPin = Settings.TaskDevicePin2[event->TaskIndex];

        int resetPin = Settings.TaskDevicePin3[event->TaskIndex];



        String log = F("PMSx003 : config ");

        log += rxPin;

        log += txPin;

        log += resetPin;

        addLog(LOG_LEVEL_DEBUG, log);



        if (swSerial != NULL) {



          delete swSerial;

          swSerial = NULL;

        }





        if (rxPin == 3 && txPin == 1)

        {

          log = F("PMSx003 : using hardware serial");

          addLog(LOG_LEVEL_INFO, log);

          Serial.begin(9600);

          Serial.flush();

        }

        else

        {

          log = F("PMSx003: using software serial");

          addLog(LOG_LEVEL_INFO, log);

          swSerial = new ESPeasySoftwareSerial(rxPin, txPin, false, 96);

          swSerial->begin(9600);

          swSerial->flush();

        }



        if (resetPin >= 0)

        {



          log = F("PMSx003: resetting module");

          addLog(LOG_LEVEL_INFO, log);

          pinMode(resetPin, OUTPUT);

          digitalWrite(resetPin, LOW);

          delay(250);

          digitalWrite(resetPin, HIGH);

          pinMode(resetPin, INPUT_PULLUP);

        }



        Plugin_053_init = true;

        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

          if (swSerial)

          {

            delete swSerial;

            swSerial=NULL;

          }

          break;

      }
# 561 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P053_PMSx003.ino"
    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_053_init)

        {



          if (PacketAvailable())

          {

            addLog(LOG_LEVEL_DEBUG_MORE, F("PMSx003 : Packet available"));

            success = Plugin_053_process_data(event);

          }

        }

        break;

      }

    case PLUGIN_READ:

      {



        success = values_received;

        values_received = false;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P054_DMX512.ino"
#ifdef USES_P054
# 106 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P054_DMX512.ino"
#define PLUGIN_054 

#define PLUGIN_ID_054 54

#define PLUGIN_NAME_054 "Communication - DMX512 TX [TESTING]"



byte* Plugin_054_DMXBuffer = 0;

int16_t Plugin_054_DMXSize = 32;



static inline void PLUGIN_054_Limit(int16_t& value, int16_t min, int16_t max)

{

  if (value < min)

    value = min;

  if (value > max)

    value = max;

}





boolean Plugin_054(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_054;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_054);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Plugin_054_DMXSize;

        addFormNote(F("Only GPIO-2 (D4) can be used as TX1!"));

        addFormNumericBox(F("Channels"), F("channels"), Plugin_054_DMXSize, 1, 512);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        if (Settings.Pin_status_led == 2)

          Settings.Pin_status_led = -1;

        Plugin_054_DMXSize = getFormItemInt(F("channels"));

        PLUGIN_054_Limit (Plugin_054_DMXSize, 1, 512);

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Plugin_054_DMXSize;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        Plugin_054_DMXSize = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (Plugin_054_DMXBuffer)

          delete [] Plugin_054_DMXBuffer;

        Plugin_054_DMXBuffer = new byte[Plugin_054_DMXSize];

        memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);



        if (command == F("dmx"))

        {

          String param;

          String paramKey;

          String paramVal;

          byte paramIdx = 2;

          int16_t channel = 1;

          int16_t value = 0;



          lowerString.replace(F("  "), " ");

          lowerString.replace(F(" ="), "=");

          lowerString.replace(F("= "), "=");



          param = parseString(lowerString, paramIdx++);

          if (param.length())

          {

            while (param.length())

            {

              addLog(LOG_LEVEL_DEBUG_MORE, param);



              if (param == F("log"))

              {

                String log = F("DMX  : ");

                for (int16_t i = 0; i < Plugin_054_DMXSize; i++)

                {

                  log += Plugin_054_DMXBuffer[i];

                  log += F(", ");

                }

                addLog(LOG_LEVEL_INFO, log);

                success = true;

              }



              else if (param == F("test"))

              {

                for (int16_t i = 0; i < Plugin_054_DMXSize; i++)



                  Plugin_054_DMXBuffer[i] = rand()&255;

                success = true;

              }



              else if (param == F("on"))

              {

                memset(Plugin_054_DMXBuffer, 255, Plugin_054_DMXSize);

                success = true;

              }



              else if (param == F("off"))

              {

                memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);

                success = true;

              }



              else

              {

                int16_t index = param.indexOf('=');

                if (index > 0)

                {

                  paramKey = param.substring(0, index);

                  paramVal = param.substring(index+1);

                  channel = paramKey.toInt();

                }

                else

                {

                  paramVal = param;

                }



                value = paramVal.toInt();

                PLUGIN_054_Limit (value, 0, 255);



                if (channel > 0 && channel <= Plugin_054_DMXSize)

                  Plugin_054_DMXBuffer[channel-1] = value;

                channel++;

              }



              param = parseString(lowerString, paramIdx++);

            }

          }

          else

          {



          }



          success = true;

        }



        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_054_DMXBuffer)

        {

          int16_t sendPin = 2;





          Serial1.flush();





          Serial1.end();

          pinMode(sendPin, OUTPUT);

          digitalWrite(sendPin, LOW);

          delayMicroseconds(120);

          digitalWrite(sendPin, HIGH);

          delayMicroseconds(12);





          Serial1.begin(250000, SERIAL_8N2);

          Serial1.write(0);

          Serial1.write(Plugin_054_DMXBuffer, Plugin_054_DMXSize);

        }

        break;

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P055_Chiming.ino"
#ifdef USES_P055
# 103 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P055_Chiming.ino"
#define PLUGIN_055 

#define PLUGIN_ID_055 55

#define PLUGIN_NAME_055 "Notify - Chiming [TESTING]"



#define PLUGIN_055_FIFO_SIZE 64

#define PLUGIN_055_FIFO_MASK (PLUGIN_055_FIFO_SIZE-1)



class CPlugin_055_Data

{

public:

  long millisStateEnd;

  long millisChimeTime;

  long millisPauseTime;



  int pin[4];

  byte lowActive;

  byte chimeClock;



  char FIFO[PLUGIN_055_FIFO_SIZE];

  byte FIFO_IndexR;

  byte FIFO_IndexW;



  void Plugin_055_Data()

  {

    millisStateEnd = 0;

    millisChimeTime = 60;

    millisPauseTime = 400;



    for (byte i=0; i<4; i++)

      pin[i] = -1;

    lowActive = false;

    chimeClock = true;



    FIFO_IndexR = 0;

    FIFO_IndexW = 0;

  }

};



static CPlugin_055_Data* Plugin_055_Data = NULL;





boolean Plugin_055(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_055;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_055);

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; Driver#1");

        event->String2 = F("GPIO &rarr; Driver#2");

        event->String3 = F("GPIO &rarr; Driver#4");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] <= 0)

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = 60;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] <= 0)

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = 400;



        addFormPinSelect(F("GPIO &rarr; Driver#8"), F("TDP4"), (int)(Settings.TaskDevicePin[3][event->TaskIndex]));





        addFormSubHeader(F("Timing"));



        addFormNumericBox(F("Chiming/Strike Time (ct)"), F("chimetime"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        addUnit(F("ms"));



        addFormNumericBox(F("Normal Pause Time (t)"), F("pausetime"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("ms"));



        addFormNote(F("'1=1'&rArr;3t, '1-1' or '11'&rArr;1t, '1.1'&rArr;&#8531;t, '1|1'&rArr;&frac12;ct"));





        addFormSubHeader(F("Chiming Clock"));



        addFormCheckBox(F("Hourly Chiming Clock Strike"), F("chimeclock"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addButton(F("'control?cmd=chimeplay,hours'"), F("Test 1&hellip;12"));



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][2] && !Settings.UseNTP)

          addFormNote(F("Enable and configure NTP!"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePin[3][event->TaskIndex] = (int8_t)getFormItemInt(F("TDP4"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("chimetime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("pausetime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("chimeclock"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_055_Data)

          Plugin_055_Data = new CPlugin_055_Data();



        Plugin_055_Data->lowActive = Settings.TaskDevicePin1Inversed[event->TaskIndex];

        Plugin_055_Data->millisChimeTime = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_055_Data->millisPauseTime = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_055_Data->chimeClock = Settings.TaskDevicePluginConfig[event->TaskIndex][2];



        String log = F("Chime: GPIO: ");

        for (byte i=0; i<4; i++)

        {

          int pin = Settings.TaskDevicePin[i][event->TaskIndex];

          Plugin_055_Data->pin[i] = pin;

          if (pin >= 0)

          {

            pinMode(pin, OUTPUT);

            digitalWrite(pin, Plugin_055_Data->lowActive);

          }

          log += pin;

          log += F(" ");

        }

        if (Plugin_055_Data->lowActive)

          log += F("!");

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_055_Data)

          break;



        String command = parseString(string, 1);



        if (command == F("chime"))

        {

          int paramPos = getParamStartPos(string, 2);

          String param = string.substring(paramPos);

          Plugin_055_AddStringFIFO(param);

          success = true;

        }

        if (command == F("chimeplay"))

        {

          String name = parseString(string, 2);

          String param;

          Plugin_055_ReadChime(name, param);

          Plugin_055_AddStringFIFO(param);

          success = true;

        }

        if (command == F("chimesave"))

        {

          String name = parseString(string, 2);

          int paramPos = getParamStartPos(string, 3);

          String param = string.substring(paramPos);

          Plugin_055_WriteChime(name, param);

          Plugin_055_AddStringFIFO(F("1"));

          success = true;

        }



        break;

      }



      case PLUGIN_CLOCK_IN:

        {

          if (!Plugin_055_Data)

            break;



          String tokens = "";

          byte hours = hour();

          byte minutes = minute();



          if (Plugin_055_Data->chimeClock)

          {

            char tmpString[8];



            sprintf_P(tmpString, PSTR("%02d%02d"), hours, minutes);

            if (Plugin_055_ReadChime(tmpString, tokens))

              Plugin_055_AddStringFIFO(tokens);



            if (minutes == 0)

            {

              if (Plugin_055_ReadChime("hours", tokens) == 0)

                tokens = F("1111!,111!1,111!1!,11!11,11!11!,11!1!1,11!1!1!,1!111,1!111!,1!11!1,1!11!1!,1!1!11");





              hours = hours % 12;

              if (hours == 0)

                hours = 12;



              byte index = hours;



              tokens = parseString(tokens, index);

              Plugin_055_AddStringFIFO(tokens);

            }

          }



          success = true;

          break;

        }





    case PLUGIN_FIFTY_PER_SECOND:



      {

        if (!Plugin_055_Data)

          break;



        long millisAct = millis();



        if (Plugin_055_Data->millisStateEnd > 0)

        {

          if (timeDiff(millisAct, Plugin_055_Data->millisStateEnd) <= 0)

          {

            for (byte i=0; i<4; i++)

            {

              if (Plugin_055_Data->pin[i] >= 0)

                digitalWrite(Plugin_055_Data->pin[i], Plugin_055_Data->lowActive);

            }

            Plugin_055_Data->millisStateEnd = 0;

          }

        }



        if (Plugin_055_Data->millisStateEnd == 0)

        {

          if (! Plugin_055_IsEmptyFIFO())

          {

            char c = Plugin_055_ReadFIFO();



            String log = F("Chime: Process '");

            log += c;

            log += "'";

            addLog(LOG_LEVEL_DEBUG, log);



            switch (c)

            {

              case 'a':

              case 'b':

              case 'c':

              case 'd':

              case 'e':

              case 'f':

              case 'A':

              case 'B':

              case 'C':

              case 'D':

              case 'E':

              case 'F':

                c -= 'A' - '0' - 10;





              case '0':

              case '1':

              case '2':

              case '3':

              case '4':

              case '5':

              case '6':

              case '7':

              case '8':

              case '9':

              {

                byte mask = 1;

                for (byte i=0; i<4; i++)

                {

                  if (Plugin_055_Data->pin[i] >= 0)

                    if (c & mask)

                      digitalWrite(Plugin_055_Data->pin[i], !Plugin_055_Data->lowActive);

                  mask <<= 1;

                }

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime;

                break;

              }

              case '=':

              case ' ':

              case ',':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime*3;

                break;

              case '-':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime;

                break;

              case '.':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime/3;

                break;

              case '|':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime/2;

                break;

              case '#':

                while (Plugin_055_ReadFIFO());

                break;

              default:

                break;

            }

          }



        }

        success = true;

        break;

      }



  }

  return success;

}







void Plugin_055_WriteFIFO(char c)

{

  if (Plugin_055_Data->FIFO_IndexR == ((Plugin_055_Data->FIFO_IndexW+1) & PLUGIN_055_FIFO_MASK))

    return;



  Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexW] = c;

  Plugin_055_Data->FIFO_IndexW++;

  Plugin_055_Data->FIFO_IndexW &= PLUGIN_055_FIFO_MASK;

}



char Plugin_055_ReadFIFO()

{

  if (Plugin_055_IsEmptyFIFO())

    return '\0';



  char c = Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];

  Plugin_055_Data->FIFO_IndexR++;

  Plugin_055_Data->FIFO_IndexR &= PLUGIN_055_FIFO_MASK;



  return c;

}



char Plugin_055_PeekFIFO()

{

  if (Plugin_055_IsEmptyFIFO())

    return '\0';



  return Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];

}



boolean Plugin_055_IsEmptyFIFO()

{

  return (Plugin_055_Data->FIFO_IndexR == Plugin_055_Data->FIFO_IndexW);

}



void Plugin_055_AddStringFIFO(const String& param)

{

  if (param.length() == 0)

    return;



  byte i = 0;

  char c = param[i];

  char c_last = '\0';



  while (c != 0)

  {

    if (isDigit(c) && isDigit(c_last))

      Plugin_055_WriteFIFO('-');

    if (c == '!')

    {

      Plugin_055_WriteFIFO('|');

      c = c_last;

    }

    Plugin_055_WriteFIFO(c);

    c_last = c;



    c = param[++i];

  }



  Plugin_055_WriteFIFO('=');

}







void Plugin_055_WriteChime(const String& name, const String& tokens)

{

  String fileName = F("chime_");

  fileName += name;

  fileName += F(".txt");



  String log = F("Chime: write ");

  log += fileName;

  log += F(" ");



  fs::File f = SPIFFS.open(fileName, "w");

  if (f)

  {

    f.print(tokens);

    f.close();



    log += tokens;

  }



  addLog(LOG_LEVEL_INFO, log);

}



byte Plugin_055_ReadChime(const String& name, String& tokens)

{

  String fileName = F("chime_");

  fileName += name;

  fileName += F(".txt");



  String log = F("Chime: read ");

  log += fileName;

  log += F(" ");



  tokens = "";

  fs::File f = SPIFFS.open(fileName, "r+");

  if (f)

  {

    char c;

    while (f.available())

    {

      c = f.read();

      tokens += c;

    }

    f.close();



    log += tokens;

  }



  addLog(LOG_LEVEL_INFO, log);



  return tokens.length();

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P056_SDS011-Dust.ino"
#ifdef USES_P056
# 26 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P056_SDS011-Dust.ino"
#define PLUGIN_056 

#define PLUGIN_ID_056 56

#define PLUGIN_NAME_056 "Dust - SDS011/018/198 [TESTING]"

#define PLUGIN_VALUENAME1_056 "PM2.5"

#define PLUGIN_VALUENAME2_056 "PM10"



#include <jkSDS011.h>





CjkSDS011 *Plugin_056_SDS = NULL;





boolean Plugin_056(byte function, struct EventStruct *event, String& string)

{

  bool success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_056;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_056);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_056));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_056));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        if (Plugin_056_hasTxPin(event)) {

          addFormNumericBox(F("Sleep time"), F("plugin_056_sleeptime"),

                            Settings.TaskDevicePluginConfig[event->TaskIndex][0],

                            0, 30);

          addUnit(F("Minutes"));

          addFormNote(F("0 = continous, 1..30 = Work 30 seconds and sleep n*60-30 seconds"));

        }

        break;

      }

      case PLUGIN_WEBFORM_SAVE:

        {

          if (Plugin_056_hasTxPin(event)) {



            const int newsleeptime = getFormItemInt(F("plugin_056_sleeptime"));

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] != newsleeptime) {

              Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_056_sleeptime"));

              Plugin_056_setWorkingPeriod(newsleeptime);

            }

          }

          success = true;

          break;

        }

    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &larr; TX");

        event->String2 = F("GPIO &#8674; RX (optional)");

        break;

      }



    case PLUGIN_INIT:

      {

        if (Plugin_056_SDS)

          delete Plugin_056_SDS;

        const int16_t serial_rx = Settings.TaskDevicePin1[event->TaskIndex];

        const int16_t serial_tx = Settings.TaskDevicePin2[event->TaskIndex];

        Plugin_056_SDS = new CjkSDS011(serial_rx, serial_tx);

        String log = F("SDS  : Init OK  ESP GPIO-pin RX:");

        log += serial_rx;

        log += F(" TX:");

        log += serial_tx;

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {
# 232 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P056_SDS011-Dust.ino"
        shouldReboot=true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        if (!Plugin_056_SDS)

          break;



        Plugin_056_SDS->Process();



        if (Plugin_056_SDS->available())

        {

          const float pm2_5 = Plugin_056_SDS->GetPM2_5();

          const float pm10 = Plugin_056_SDS->GetPM10_();

          String log = F("SDS  : act ");

          log += pm2_5;

          log += F(" ");

          log += pm10;

          addLog(LOG_LEVEL_DEBUG, log);



          if (Settings.TaskDeviceTimer[event->TaskIndex] == 0)

          {

            UserVar[event->BaseVarIndex + 0] = pm2_5;

            UserVar[event->BaseVarIndex + 1] = pm10;

            event->sensorType = SENSOR_TYPE_DUAL;

            sendData(event);

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_056_SDS)

          break;



        float pm25, pm10;

        if (Plugin_056_SDS->ReadAverage(pm25, pm10)) {

          UserVar[event->BaseVarIndex + 0] = pm25;

          UserVar[event->BaseVarIndex + 1] = pm10;

          success = true;

        }

        break;

      }

  }



  return success;

}



boolean Plugin_056_hasTxPin(struct EventStruct *event) {

  const int16_t serial_tx = Settings.TaskDevicePin2[event->TaskIndex];

  return serial_tx >= 0;

}



String Plugin_056_ErrorToString(int error) {

  String log;

  if (error < 0) {

    log = F("comm error: ");

    log += error;

  }

  return log;

}



String Plugin_056_WorkingPeriodToString(int workingPeriod) {

  if (workingPeriod < 0) {

    return Plugin_056_ErrorToString(workingPeriod);

  }

  String log;

  if (workingPeriod > 0) {

    log += workingPeriod;

    log += F(" minutes");

  } else {

    log += F(" continuous");

  }

  return log;

}



void Plugin_056_setWorkingPeriod(int minutes) {

  if (!Plugin_056_SDS)

    return;

  Plugin_056_SDS->SetWorkingPeriod(minutes);

  String log = F("SDS  : Working Period set to: ");

  log += Plugin_056_WorkingPeriodToString(minutes);

  addLog(LOG_LEVEL_INFO, log);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P057_HT16K33_LED.ino"
#ifdef USES_P057
# 96 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P057_HT16K33_LED.ino"
#define PLUGIN_057 

#define PLUGIN_ID_057 57

#define PLUGIN_NAME_057 "Display - HT16K33 [TESTING]"



#include <HT16K33.h>



CHT16K33* Plugin_057_M = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_057(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_057;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_057);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);





        addFormSubHeader(F("7-Seg. Clock"));



        int16_t choice = CONFIG(1);

        String options[2] = { F("none"), F("7-Seg. HH:MM") };

        addFormSelector(F("Clock Type"), F("clocktype"), 2, options, NULL, choice);



        addFormNumericBox(F("Seg. for <b>X</b>x:xx"), F("clocksegh10"), CONFIG(2), 0, 7);

        addFormNumericBox(F("Seg. for x<b>X</b>:xx"), F("clocksegh1"), CONFIG(3), 0, 7);

        addFormNumericBox(F("Seg. for xx:<b>X</b>x"), F("clocksegm10"), CONFIG(4), 0, 7);

        addFormNumericBox(F("Seg. for xx:x<b>X</b>"), F("clocksegm1"), CONFIG(5), 0, 7);



        addFormNumericBox(F("Seg. for Colon"), F("clocksegcol"), CONFIG(6), -1, 7);

        addHtml(F(" Value "));

        addNumericBox(F("clocksegcolval"), CONFIG(7), 0, 255);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = getFormItemInt(F("clocktype"));



        CONFIG(2) = getFormItemInt(F("clocksegh10"));

        CONFIG(3) = getFormItemInt(F("clocksegh1"));

        CONFIG(4) = getFormItemInt(F("clocksegm10"));

        CONFIG(5) = getFormItemInt(F("clocksegm1"));

        CONFIG(6) = getFormItemInt(F("clocksegcol"));

        CONFIG(7) = getFormItemInt(F("clocksegcolval"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_057_M)

          Plugin_057_M = new CHT16K33;



        Plugin_057_M->Init(addr);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_057_M)

          return false;



        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);



        if (command == F("mprint"))

        {

          int paramPos = getParamStartPos(lowerString, 2);

          String text = lowerString.substring(paramPos);

          byte seg = 0;



          Plugin_057_M->ClearRowBuffer();

          while (text[seg] && seg < 8)

          {



            char c = text[seg];

            Plugin_057_M->SetDigit(seg, c);

            seg++;

          }

          Plugin_057_M->TransmitRowBuffer();

          success = true;

        }

        else if (command == F("mbr")) {

          int paramPos = getParamStartPos(lowerString, 2);

          uint8_t brightness = lowerString.substring(paramPos).toInt();

          Plugin_057_M->SetBrightness(brightness);

          success = true;

        }

        else if (command == F("m") || command == F("mx") || command == F("mnum"))

        {

          String param;

          String paramKey;

          String paramVal;

          byte paramIdx = 2;

          uint8_t seg = 0;

          uint16_t value = 0;



          lowerString.replace(F("  "), " ");

          lowerString.replace(F(" ="), "=");

          lowerString.replace(F("= "), "=");



          param = parseString(lowerString, paramIdx++);

          if (param.length())

          {

            while (param.length())

            {

              addLog(LOG_LEVEL_DEBUG_MORE, param);



              if (param == F("log"))

              {

                String log = F("MX   : ");

                for (byte i = 0; i < 8; i++)

                {

                  log += String(Plugin_057_M->GetRow(i), 16);

                  log += F("h, ");

                }

                addLog(LOG_LEVEL_INFO, log);

                success = true;

              }



              else if (param == F("test"))

              {

                for (byte i = 0; i < 8; i++)

                  Plugin_057_M->SetRow(i, 1 << i);

                success = true;

              }



              else if (param == F("clear"))

              {

                Plugin_057_M->ClearRowBuffer();

                success = true;

              }



              else

              {

                int index = param.indexOf('=');

                if (index > 0)

                {

                  paramKey = param.substring(0, index);

                  paramVal = param.substring(index+1);

                  seg = paramKey.toInt();

                }

                else

                {

                  paramVal = param;

                }



                if (command == F("mnum"))

                {

                  value = paramVal.toInt();

                  if (value < 16)

                    Plugin_057_M->SetDigit(seg, value);

                  else

                    Plugin_057_M->SetRow(seg, value);

                }

                else if (command == F("mx"))

                {

                  char* ep;

                  value = strtol(paramVal.c_str(), &ep, 16);

                  Plugin_057_M->SetRow(seg, value);

                }

                else

                {

                  value = paramVal.toInt();

                  Plugin_057_M->SetRow(seg, value);

                }



                success = true;

                seg++;

              }



              param = parseString(lowerString, paramIdx++);

            }

          }

          else

          {



          }



          if (success)

            Plugin_057_M->TransmitRowBuffer();

          success = true;

        }



        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        if (!Plugin_057_M || CONFIG(1) == 0)

          break;



        byte hours = hour();

        byte minutes = minute();





        if (hours >= 10)

          Plugin_057_M->SetDigit(CONFIG(2), hours/10);

        else

          Plugin_057_M->SetRow(CONFIG(2), 0);

        Plugin_057_M->SetDigit(CONFIG(3), hours%10);

        Plugin_057_M->SetDigit(CONFIG(4), minutes/10);

        Plugin_057_M->SetDigit(CONFIG(5), minutes%10);





        Plugin_057_M->TransmitRowBuffer();



        success = true;



        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (!Plugin_057_M || CONFIG(1) == 0)

          break;



        if (CONFIG(6) >= 0)

        {

          uint8_t act = ((uint16_t)millis() >> 9) & 1;

          static uint8_t last = 0;

          if (act != last)

          {

            last = act;

            Plugin_057_M->SetRow(CONFIG(6), (act) ? CONFIG(7) : 0);

            Plugin_057_M->TransmitRowBuffer();

          }

        }

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P058_HT16K33_KeyPad.ino"
#ifdef USES_P058
# 60 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P058_HT16K33_KeyPad.ino"
#define PLUGIN_058 

#define PLUGIN_ID_058 58

#define PLUGIN_NAME_058 "Keypad - HT16K33 [TESTING]"

#define PLUGIN_VALUENAME1_058 "ScanCode"



#include <HT16K33.h>



CHT16K33* Plugin_058_K = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_058(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_058;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_058);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_058));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_058_K)

          Plugin_058_K = new CHT16K33;



        Plugin_058_K->Init(addr);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_058_K)

        {

          static uint8_t keyLast = 0;



          uint8_t key = Plugin_058_K->ReadKeys();



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Mkey : key=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_058_K)

        {

        }

        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P059_Encoder.ino"
#ifdef USES_P059
# 34 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P059_Encoder.ino"
#define PLUGIN_059 

#define PLUGIN_ID_059 59

#define PLUGIN_NAME_059 "Switch Input - Rotary Encoder"

#define PLUGIN_VALUENAME1_059 "Counter"



#include <QEIx4.h>



QEIx4* Plugin_059_QE = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef CONFIG_L

#define CONFIG_L(n) (Settings.TaskDevicePluginConfigLong[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif





boolean Plugin_059(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_059;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_059);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_059));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &larr; A");

        event->String2 = F("GPIO &larr; B");

        event->String3 = F("GPIO &#8672; I (optional)");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        if (CONFIG_L(0) == 0 && CONFIG_L(1) == 0)

          CONFIG_L(1) = 100;



        String options[3] = { F("1 pulse per cycle"), F("2 pulses per cycle"), F("4 pulses per cycle") };

        int optionValues[3] = { 1, 2, 4 };

        addFormSelector(F("Mode"), F("qei_mode"), 3, options, optionValues, CONFIG(0));



        addFormNumericBox(F("Limit min."), F("qei_limitmin"), CONFIG_L(0));

        addFormNumericBox(F("Limit max."), F("qei_limitmax"), CONFIG_L(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("qei_mode"));



        CONFIG_L(0) = getFormItemInt(F("qei_limitmin"));

        CONFIG_L(1) = getFormItemInt(F("qei_limitmax"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_059_QE)

          Plugin_059_QE = new QEIx4;



        Plugin_059_QE->begin(PIN(0),PIN(1),PIN(2),CONFIG(0));

        Plugin_059_QE->setLimit(CONFIG_L(0), CONFIG_L(1));

        Plugin_059_QE->setIndexTrigger(true);



        ExtraTaskSettings.TaskDeviceValueDecimals[event->BaseVarIndex] = 0;



        String log = F("QEI  : GPIO: ");

        for (byte i=0; i<3; i++)

        {

          int pin = PIN(i);

          if (pin >= 0)

          {



            setPinState(PLUGIN_ID_059, pin, PIN_MODE_INPUT, 0);

          }

          log += pin;

          log += F(" ");

        }

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_059_QE)

        {

          if (Plugin_059_QE->hasChanged())

          {

            long c = Plugin_059_QE->read();

            UserVar[event->BaseVarIndex] = (float)c;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("QEI  : ");

            log += c;

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_059_QE)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_059_QE->read();

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_059_QE)

        {

            String log = "";

            String command = parseString(string, 1);

            if (command == F("encwrite"))

            {

              if (event->Par1 >= 0)

              {

                log = String(F("QEI  : ")) + string;

                addLog(LOG_LEVEL_INFO, log);

                Plugin_059_QE->write(event->Par1);

              }

              success = true;

            }

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P060_MCP3221.ino"
#ifdef USES_P060
# 19 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P060_MCP3221.ino"
#define PLUGIN_060 

#define PLUGIN_ID_060 60

#define PLUGIN_NAME_060 "Analog input - MCP3221 [TESTING]"

#define PLUGIN_VALUENAME1_060 "Analog"



uint32_t Plugin_060_OversamplingValue = 0;

uint16_t Plugin_060_OversamplingCount = 0;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





uint16_t readMCP3221(byte addr)

{

  uint16_t value;

  Wire.requestFrom(addr, (uint8_t)2);

  if (Wire.available() == 2)

  {

    value = (Wire.read() << 8) | Wire.read();

  }

  else

    value = 9999;



  return value;

}



boolean Plugin_060(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_060;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_060);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_060));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x4D, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4E, 0x4F };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);



        addFormCheckBox(F("Oversampling"), F("plugin_060_oversampling"), CONFIG(1));



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_060_cal"), CONFIG(3));



        addFormNumericBox(F("Point 1"), F("plugin_060_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], 0, 4095);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_060_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_060_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], 0, 4095);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_060_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = isFormItemChecked(F("plugin_060_oversampling"));



        CONFIG(3) = isFormItemChecked(F("plugin_060_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_060_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_060_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_060_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_060_out2"));



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (CONFIG(1))

        {

          Plugin_060_OversamplingValue += readMCP3221(CONFIG(0));

          Plugin_060_OversamplingCount ++;

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("ADMCP: Analog value: ");



        if (Plugin_060_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_060_OversamplingValue / Plugin_060_OversamplingCount;

          Plugin_060_OversamplingValue = 0;

          Plugin_060_OversamplingCount = 0;



          log += String(UserVar[event->BaseVarIndex], 3);

        }

        else

        {

          int16_t value = readMCP3221(CONFIG(0));

          UserVar[event->BaseVarIndex] = (float)value;



          log += value;

        }



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" = ");

            log += String(UserVar[event->BaseVarIndex], 3);

          }

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P061_KeyPad.ino"
#ifdef USES_P061
# 110 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P061_KeyPad.ino"
#define PLUGIN_061 

#define PLUGIN_ID_061 61

#define PLUGIN_NAME_061 "Keypad - PCF8574 / MCP23017 [TESTING]"

#define PLUGIN_VALUENAME1_061 "ScanCode"







#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_061(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_061;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_061);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_061));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[16] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F };

        addFormSelectorI2C(F("i2c_addr"), (CONFIG(1) == 0) ? 8 : 16, optionValues, addr);

        if (CONFIG(1) != 0)

          addFormNote(F("PCF8574 uses address 0x20+; PCF8574<b>A</b> uses address 0x38+"));



        String options[3] = { F("MCP23017 (Matrix 9x8)"), F("PCF8574 (Matrix 5x4)"), F("PCF8574 (Direct 8)") };

        addFormSelector(F("Chip (Mode)"), F("chip"), 3, options, NULL, CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = getFormItemInt(F("chip"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        switch (CONFIG(1))

        {

          case 0: MCP23017_KeyPadMatrixInit(CONFIG(0)); break;

          case 1: PCF8574_KeyPadMatrixInit(CONFIG(0)); break;

          case 2: PCF8574_KeyPadDirectInit(CONFIG(0)); break;

        }



        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        static byte lastScanCode = 0xFF;

       static byte sentScanCode = 0xFF;

        byte actScanCode = 0;



        switch (CONFIG(1))

        {

          case 0: actScanCode = MCP23017_KeyPadMatrixScan(CONFIG(0)); break;

          case 1: actScanCode = PCF8574_KeyPadMatrixScan(CONFIG(0)); break;

          case 2: actScanCode = PCF8574_KeyPadDirectScan(CONFIG(0)); break;

        }



       if (lastScanCode == actScanCode)

       {

        if (sentScanCode != actScanCode)

        {

            UserVar[event->BaseVarIndex] = (float)actScanCode;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("KPad : ScanCode=0x");

            log += String(actScanCode, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);



         sentScanCode = actScanCode;

        }

       }

       else

        lastScanCode = actScanCode;



        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        success = true;

        break;

      }



  }

  return success;

}
# 382 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P061_KeyPad.ino"
#define MCP23017_IODIRA 0x00

#define MCP23017_IODIRB 0x01

#define MCP23017_IPOLA 0x02

#define MCP23017_IPOLB 0x03

#define MCP23017_GPINTENA 0x04

#define MCP23017_GPINTENB 0x05

#define MCP23017_DEFVALA 0x06

#define MCP23017_DEFVALB 0x07

#define MCP23017_INTCONA 0x08

#define MCP23017_INTCONB 0x09

#define MCP23017_IOCON 0x0A

#define MCP23017_GPPUA 0x0C

#define MCP23017_GPPUB 0x0D

#define MCP23017_INTFA 0x0E

#define MCP23017_INTFB 0x0F

#define MCP23017_INTCAPA 0x10

#define MCP23017_INTCAPB 0x11

#define MCP23017_GPIOA 0x12

#define MCP23017_GPIOB 0x13

#define MCP23017_OLATA 0x14

#define MCP23017_OLATB 0x15





void MCP23017_setReg(byte addr, byte reg, byte data)

{

 Wire.beginTransmission(addr);

 Wire.write(reg);

 Wire.write(data);

 Wire.endTransmission();

}



byte MCP23017_getReg(byte addr, byte reg)

{

 Wire.beginTransmission(addr);

 Wire.write(reg);

 Wire.endTransmission();

 Wire.requestFrom(addr, (uint8_t)0x1);

 if (Wire.available())

 {

  return Wire.read();

 }

 return 0xFF;

}



void MCP23017_KeyPadMatrixInit(byte addr)

{

 MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

 MCP23017_setReg(addr, MCP23017_GPIOA, 0x00);

 MCP23017_setReg(addr, MCP23017_IODIRB, 0xFF);

 MCP23017_setReg(addr, MCP23017_GPPUA, 0xFF);

 MCP23017_setReg(addr, MCP23017_GPPUB, 0xFF);

}



byte MCP23017_KeyPadMatrixScan(byte addr)

{

 byte rowMask = 1;

 byte colData;



 colData = MCP23017_getReg(addr, MCP23017_GPIOB);

 if (colData == 0xFF)

  return 0;



 for (byte row = 0; row <= 8; row++)

 {

    if (row == 0)

    MCP23017_setReg(addr, MCP23017_IODIRA, 0xFF);

    else

    {

      MCP23017_setReg(addr, MCP23017_IODIRA, ~rowMask);

      rowMask <<= 1;

    }



  colData = MCP23017_getReg(addr, MCP23017_GPIOB);

  if (colData != 0xFF)

  {

   byte colMask = 1;

   for (byte col = 1; col <= 8; col++)

   {

    if ((colData & colMask) == 0)

    {

     MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

     return ((row << 4) | col);

    }

    colMask <<= 1;

   }

  }

 }



 MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

 return 0;

}







void PCF8574_setReg(byte addr, byte data)

{

 Wire.beginTransmission(addr);

 Wire.write(data);

 Wire.endTransmission();

}



byte PCF8574_getReg(byte addr)

{

 Wire.requestFrom(addr, (uint8_t)0x1);

 if (Wire.available())

 {

  return Wire.read();

 }

 return 0xFF;

}



void PCF8574_KeyPadMatrixInit(byte addr)

{

 PCF8574_setReg(addr, 0xF0);

}



byte PCF8574_KeyPadMatrixScan(byte addr)

{

 byte rowMask = 1;

 byte colData;



 colData = PCF8574_getReg(addr) & 0xF0;

 if (colData == 0xF0)

  return 0;



 for (byte row = 0; row <= 4; row++)

 {

    if (row == 0)

      PCF8574_setReg(addr, 0xFF);

    else

    {

      PCF8574_setReg(addr, ~rowMask);

      rowMask <<= 1;

    }



    colData = PCF8574_getReg(addr) & 0xF0;

  if (colData != 0xF0)

  {

   byte colMask = 0x10;

   for (byte col = 1; col <= 4; col++)

   {

    if ((colData & colMask) == 0)

    {

     PCF8574_setReg(addr, 0xF0);

     return ((row << 4) | col);

    }

    colMask <<= 1;

   }

  }

 }



 PCF8574_setReg(addr, 0xF0);

 return 0;

}







void PCF8574_KeyPadDirectInit(byte addr)

{

 PCF8574_setReg(addr, 0xFF);

}



byte PCF8574_KeyPadDirectScan(byte addr)

{

 byte colData;



 colData = PCF8574_getReg(addr);

 if (colData == 0xFF)

  return 0;



 byte colMask = 0x01;

 for (byte col = 1; col <= 8; col++)

 {

  if ((colData & colMask) == 0)

  {

   return (col);

  }

  colMask <<= 1;

 }



 return 0;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P062_MPR121_KeyPad.ino"
#ifdef USES_P062
# 36 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P062_MPR121_KeyPad.ino"
#define PLUGIN_062 

#define PLUGIN_ID_062 62

#define PLUGIN_NAME_062 "Keypad - MPR121 Touch [TESTING]"

#define PLUGIN_VALUENAME1_062 "ScanCode"



#include <Adafruit_MPR121.h>



Adafruit_MPR121* Plugin_062_K = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_062(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_062;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_062);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_062));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[4] = { 0x5A, 0x5B, 0x5C, 0x5D };

        addFormSelectorI2C(F("i2c_addr"), 4, optionValues, addr);



        addFormCheckBox(F("ScanCode"), F("scancode"), CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = isFormItemChecked(F("scancode"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_062_K)

          Plugin_062_K = new Adafruit_MPR121;



        Plugin_062_K->begin(addr);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_062_K)

        {

          static uint16_t keyLast = 0;



          uint16_t key = Plugin_062_K->touched();



          if (key && CONFIG(1))

          {

            uint16_t colMask = 0x01;

            for (byte col = 1; col <= 12; col++)

            {

              if (key & colMask)

              {

                key = col;

                break;

              }

              colMask <<= 1;

            }

          }



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Tkey : ");

            if (CONFIG(1))

              log = F("ScanCode=0x");

            else

              log = F("KeyMap=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_062_K)

        {

        }

        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P063_TTP229_KeyPad.ino"
#ifdef USES_P063
# 50 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P063_TTP229_KeyPad.ino"
#define PLUGIN_063 

#define PLUGIN_ID_063 63

#define PLUGIN_NAME_063 "Keypad - TTP229 Touch"

#define PLUGIN_VALUENAME1_063 "ScanCode"
# 66 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P063_TTP229_KeyPad.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO)

{

  uint16_t value = 0;

  uint16_t mask = 1;



  pinMode(pinSDO, OUTPUT);

  digitalWrite(pinSDO, HIGH);

  delayMicroseconds(100);



  digitalWrite(pinSDO, LOW);

  delayMicroseconds(10);



  pinMode(pinSDO, INPUT);

  for (byte i = 0; i < 16; i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    if (!digitalRead(pinSDO))

      value |= mask;

    delayMicroseconds(1);

    mask <<= 1;

  }



  return value;

}





boolean Plugin_063(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_063;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_063);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_063));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; SCL");

        event->String2 = F("GPIO &#8644; SDO");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("ScanCode"), F("scancode"), CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(1) = isFormItemChecked(F("scancode"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinSDO = PIN(1);



        String log = F("Tkey : GPIO: ");

        log += pinSCL;

        log += F(" ");

        log += pinSDO;

        addLog(LOG_LEVEL_INFO, log);



        if (pinSCL >= 0 && pinSDO >= 0)

        {

          pinMode(pinSCL, OUTPUT);

          digitalWrite(pinSCL, LOW);

          setPinState(PLUGIN_ID_063, pinSCL, PIN_MODE_OUTPUT, 0);

          pinMode(pinSDO, OUTPUT);

          digitalWrite(pinSDO, LOW);

          setPinState(PLUGIN_ID_063, pinSDO, PIN_MODE_INPUT, 0);

        }



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        static uint16_t keyLast = 0;

        int16_t pinSCL = PIN(0);

        int16_t pinSDO = PIN(1);



        if (pinSCL >= 0 && pinSDO >= 0)

        {

          uint16_t key = readTTP229(pinSCL, pinSDO);



          if (key && CONFIG(1))

          {

            uint16_t colMask = 0x01;

            for (byte col = 1; col <= 16; col++)

            {

              if (key & colMask)

              {

                key = col;

                break;

              }

              colMask <<= 1;

            }

          }



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Tkey : ");

            if (CONFIG(1))

              log = F("ScanCode=0x");

            else

              log = F("KeyMap=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        success = true;

        break;

      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
#ifdef USES_P064
# 36 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
#define PLUGIN_064 

#define PLUGIN_ID_064 64

#define PLUGIN_NAME_064 "Gesture - APDS9960 [DEVELOPMENT]"

#define PLUGIN_VALUENAME1_064 "Gesture"

#define PLUGIN_VALUENAME2_064 "Proximity"

#define PLUGIN_VALUENAME3_064 "Light"
# 60 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
#include <SparkFun_APDS9960.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



SparkFun_APDS9960* PLUGIN_064_pds = NULL;





boolean Plugin_064(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_064;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_064);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_064));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_064));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_064));
# 156 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = 0x39;



        int optionValues[1] = { 0x39 };

        addFormSelectorI2C(F("i2c_addr"), 1, optionValues, addr);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {





        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (PLUGIN_064_pds)

          delete PLUGIN_064_pds;

        PLUGIN_064_pds = new SparkFun_APDS9960();



        String log = F("APDS : ");

        if ( PLUGIN_064_pds->init() )

        {

          log += F("Init");



          PLUGIN_064_pds->enablePower();



          if (! PLUGIN_064_pds->enableLightSensor(false))

            log += F(" - Error during light sensor init!");

          if (! PLUGIN_064_pds->enableProximitySensor(false))

            log += F(" - Error during proximity sensor init!");



          if (! PLUGIN_064_pds->enableGestureSensor(false))

            log += F(" - Error during gesture sensor init!");

        }

        else

        {

          log += F("Error during APDS-9960 init!");

        }



        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        if (!PLUGIN_064_pds)

          break;



        if ( !PLUGIN_064_pds->isGestureAvailable() )

          break;



        int gesture = PLUGIN_064_pds->readGesture();
# 296 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
        if (gesture >= 0)

        {

          String log = F("APDS : Gesture=");



          switch ( gesture )

          {

            case DIR_UP: log += F("UP"); break;

            case DIR_DOWN: log += F("DOWN"); break;

            case DIR_LEFT: log += F("LEFT"); break;

            case DIR_RIGHT: log += F("RIGHT"); break;

            case DIR_NEAR: log += F("NEAR"); break;

            case DIR_FAR: log += F("FAR"); break;

            default: log += F("NONE"); break;

          }

          log += F(" (");

          log += gesture;

          log += F(")");



          UserVar[event->BaseVarIndex] = (float)gesture;

          event->sensorType = SENSOR_TYPE_SWITCH;



          sendData(event);



          addLog(LOG_LEVEL_INFO, log);

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!PLUGIN_064_pds)

          break;







        if (1)

        {

          uint8_t proximity_data = 0;

          PLUGIN_064_pds->readProximity(proximity_data);

          UserVar[event->BaseVarIndex + 1] = (float)proximity_data;



          uint16_t ambient_light = 0;

          PLUGIN_064_pds->readAmbientLight(ambient_light);

          UserVar[event->BaseVarIndex + 2] = (float)ambient_light;
# 412 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P064_APDS9960.ino"
        }



        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P065_DRF0299_MP3.ino"
#ifdef USES_P065
# 61 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P065_DRF0299_MP3.ino"
#define PLUGIN_065 

#define PLUGIN_ID_065 65

#define PLUGIN_NAME_065 "Notify - DFPlayer-Mini MP3 [TESTING]"

#define PLUGIN_VALUENAME1_065 ""



#include <ESPeasySoftwareSerial.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



ESPeasySoftwareSerial* Plugin_065_SoftSerial = NULL;





boolean Plugin_065(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_065;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_065);

        break;

      }



      case PLUGIN_GET_DEVICEGPIONAMES:

        {

          event->String1 = F("GPIO &rarr; RX");

          break;

        }



    case PLUGIN_WEBFORM_LOAD:

      {

          addFormNumericBox(F("Volume"), F("volume"), CONFIG(0), 1, 30);



          success = true;

          break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("volume"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        #pragma GCC diagnostic push



        #pragma GCC diagnostic warning "-Wdelete-non-virtual-dtor"

        if (Plugin_065_SoftSerial)

          delete Plugin_065_SoftSerial;

        #pragma GCC diagnostic pop





        Plugin_065_SoftSerial = new ESPeasySoftwareSerial(-1, PIN(0));



        Plugin_065_SoftSerial->begin(9600);



        Plugin_065_SetVol(CONFIG(0));



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_065_SoftSerial)

          break;



        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);

        String param = parseString(lowerString, 2);



        if (command == F("play"))

        {

          String log = F("MP3  : play=");



          uint16_t track = param.toInt();

          Plugin_065_Play(track);

          log += track;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        if (command == F("stop"))

        {

          String log = F("MP3  : stop");



          Plugin_065_SendCmd(0x0E, 0);



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        if (command == F("vol"))

        {

          String log = F("MP3  : vol=");



          int8_t vol = param.toInt();

          if (vol == 0) vol = 30;

          CONFIG(0) = vol;

          Plugin_065_SetVol(vol);

          log += vol;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        if (command == F("eq"))

        {

          String log = F("MP3  : eq=");



          int8_t eq = param.toInt();

          Plugin_065_SetEQ(eq);

          log += eq;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        break;

      }

  }

  return success;

}





void Plugin_065_Play(uint16_t track)

{

  Plugin_065_SendCmd(0x03, track);

}



void Plugin_065_SetVol(int8_t vol)

{

  if (vol < 1) vol = 1;

  if (vol > 30) vol = 30;

  Plugin_065_SendCmd(0x06, vol);

}



void Plugin_065_SetEQ(int8_t eq)

{

  if (eq < 0) eq = 0;

  if (eq > 5) eq = 5;

  Plugin_065_SendCmd(0x07, eq);

}



void Plugin_065_SendCmd(byte cmd, int16_t data)

{

  if (!Plugin_065_SoftSerial)

    return;



  byte buffer[10] = { 0x7E, 0xFF, 0x06, 0, 0x00, 0, 0, 0, 0, 0xEF };



  buffer[3] = cmd;

  buffer[5] = data >> 8;

  buffer[6] = data & 0xFF;



  int16_t checksum = -(buffer[1] + buffer[2] + buffer[3] + buffer[4] + buffer[5] + buffer[6]);

  buffer[7] = checksum >> 8;

  buffer[8] = checksum & 0xFF;



  Plugin_065_SoftSerial->write(buffer, 10);



  String log = F("MP3  : Send Cmd ");

  for (byte i=0; i<10; i++)

  {

    log += String(buffer[i], 16);

    log += F(" ");

  }

  addLog(LOG_LEVEL_DEBUG, log);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P066_VEML6040.ino"
#ifdef USES_P066
# 26 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P066_VEML6040.ino"
#define PLUGIN_066 

#define PLUGIN_ID_066 66

#define PLUGIN_NAME_066 "Color - VEML6040 [TESTING]"

#define PLUGIN_VALUENAME1_066 "R"

#define PLUGIN_VALUENAME2_066 "G"

#define PLUGIN_VALUENAME3_066 "B"

#define PLUGIN_VALUENAME4_066 "W"



#define VEML6040_ADDR 0x10





#include <math.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_066(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_066;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_066);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_066));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        int optionValues[1] = { VEML6040_ADDR };

        addFormSelectorI2C(F("i2c_addr"), 1, optionValues, VEML6040_ADDR);



        String optionsMode[6] = { F("40ms (16496)"), F("80ms (8248)"), F("160ms (4124)"), F("320ms (2062)"), F("640ms (1031)"), F("1280ms (515)") };

        addFormSelector(F("Integration Time (Max Lux)"), F("itime"), 6, optionsMode, NULL, CONFIG(1));



        String optionsVarMap[6] = {

          F("R, G, B, W"),

          F("r, g, b, W - relative rgb [&#37;]"),

          F("r, g, b, W - relative rgb^Gamma [&#37;]"),

          F("R, G, B, Color Temperature [K]"),

          F("R, G, B, Ambient Light [Lux]"),

          F("Color Temperature [K], Ambient Light [Lux], Y, W") };

        addFormSelector(F("Value Mapping"), F("map"), 6, optionsVarMap, NULL, CONFIG(2));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        CONFIG(1) = getFormItemInt(F("itime"));

        CONFIG(2) = getFormItemInt(F("map"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        VEML6040_Init(CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        float R, G, B, W;



        R = VEML6040_GetValue(0x08);

        G = VEML6040_GetValue(0x09);

        B = VEML6040_GetValue(0x0A);

        W = VEML6040_GetValue(0x0B);



        switch (CONFIG(2))

        {

          default:

          case 0:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 1:

          {

            UserVar[event->BaseVarIndex + 0] = Plugin_066_CalcRelW(R, W) * 100.0;

            UserVar[event->BaseVarIndex + 1] = Plugin_066_CalcRelW(G, W) * 100.0;

            UserVar[event->BaseVarIndex + 2] = Plugin_066_CalcRelW(B, W) * 100.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 2:

          {

            UserVar[event->BaseVarIndex + 0] = pow(Plugin_066_CalcRelW(R, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 1] = pow(Plugin_066_CalcRelW(G, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 2] = pow(Plugin_066_CalcRelW(B, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 3:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = Plugin_066_CalcCCT(R, G, B);

            break;

          }

          case 4:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = Plugin_066_CalcAmbientLight(G, CONFIG(1));

            break;

          }

          case 5:

          {

            UserVar[event->BaseVarIndex + 0] = Plugin_066_CalcCCT(R, G, B);

            UserVar[event->BaseVarIndex + 1] = Plugin_066_CalcAmbientLight(G, CONFIG(1));

            UserVar[event->BaseVarIndex + 2] = (R + G + B) / 3.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

        }

        success = true;

        break;

      }



  }

  return success;

}
# 360 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P066_VEML6040.ino"
void VEML6040_setControlReg(byte data)

{

 Wire.beginTransmission(VEML6040_ADDR);

  Wire.write(0);

 Wire.write(data);

  Wire.write(0);

 Wire.endTransmission();

}



float VEML6040_GetValue(byte reg)

{

 Wire.beginTransmission(VEML6040_ADDR);

 Wire.write(reg);

 Wire.endTransmission(false);

 Wire.requestFrom((uint8_t)VEML6040_ADDR, (uint8_t)0x2);

 if (Wire.available() == 2)

 {

    uint16_t lsb = Wire.read();

    uint16_t msb = Wire.read();

  return (float)((msb << 8) | lsb);

 }

 return -1.0;

}



void VEML6040_Init(byte it)

{

  VEML6040_setControlReg(it << 4);

}





float Plugin_066_CalcCCT(float R, float G, float B)

{

  if (G == 0)

    return 0;



  float CCTi = (R - B) / G + 0.5;

  float CCT = 4278.6 * pow(CCTi, -1.2455);

  return CCT;

}



float Plugin_066_CalcAmbientLight(float G, byte it)

{

  float Sensitivity[6] = { 0.25168, 0.12584, 0.06292, 0.03146, 0.01573, 0.007865 };



  return G * Sensitivity[it];

}



float Plugin_066_CalcRelW(float X, float W)

{

  if (W == 0)

    return 0;



  return X / W;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P067_HX711_Load_Cell.ino"
#ifdef USES_P067
# 30 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P067_HX711_Load_Cell.ino"
#define PLUGIN_067 

#define PLUGIN_ID_067 67

#define PLUGIN_NAME_067 "Weight - HX711 Load Cell [TESTING]"

#define PLUGIN_VALUENAME1_067 "Weight"
# 46 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P067_HX711_Load_Cell.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



int32_t Plugin_067_OversamplingValue = 0;

int16_t Plugin_067_OversamplingCount = 0;





void initHX711(int16_t pinSCL, int16_t pinDOUT)

{

  digitalWrite(pinSCL, LOW);

  pinMode(pinSCL, OUTPUT);



  pinMode(pinDOUT, INPUT_PULLUP);

}





boolean isReadyHX711(int16_t pinSCL, int16_t pinDOUT)

{

  return (!digitalRead(pinDOUT));

}



int32_t readHX711(int16_t pinSCL, int16_t pinDOUT, uint8_t mode)

{

  int32_t value = 0;

  int32_t mask = 0x00800000;



  for (byte i = 0; i < 24; i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    if (digitalRead(pinDOUT))

      value |= mask;

    delayMicroseconds(1);

    mask >>= 1;

  }



  for (byte i = 0; i < (mode+1); i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    delayMicroseconds(1);

  }



  if (value & 0x00800000)

    value |= 0xFF000000;



  return value;

}





boolean Plugin_067(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_067;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_067);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_067));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; SCL");

        event->String2 = F("GPIO &larr; DOUT");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormSubHeader(F("Measurement"));



        addFormCheckBox(F("Oversampling"), F("oversampling"), CONFIG(0));



        String optionsMode[3] = { F("Channel A, Gain 128"), F("Channel B, Gain 32"), F("Channel A, Gain 64") };

        addFormSelector(F("Mode"), F("mode"), 3, optionsMode, NULL, CONFIG(1));



        addFormTextBox(F("Offset"), F("Plugin_067_offset"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3], 3), 25);

        addHtml(F(" &nbsp; &nbsp; &#8617; Tare: "));

        addCheckBox(F("tare"), 0);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("Plugin_067_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("Plugin_067_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0]);

        addHtml(F(" &#8793; "));

        addTextBox(F("Plugin_067_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("Plugin_067_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1]);

        addHtml(F(" &#8793; "));

        addTextBox(F("Plugin_067_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = isFormItemChecked(F("oversampling"));



        CONFIG(1) = getFormItemInt(F("mode"));



        if (isFormItemChecked(F("tare")))

        {

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = -UserVar[event->BaseVarIndex + 1];

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;

        }

        else

        {

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = getFormItemFloat(F("Plugin_067_offset"));

        }



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("Plugin_067_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("Plugin_067_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("Plugin_067_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("Plugin_067_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("Plugin_067_out2"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinDOUT = PIN(1);



        String log = F("HX711: GPIO: SCL=");

        log += pinSCL;

        log += F(" DOUT=");

        log += pinDOUT;

        addLog(LOG_LEVEL_INFO, log);



        if (pinSCL >= 0 && pinDOUT >= 0)

        {

          initHX711(pinSCL, pinDOUT);

        }



        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinDOUT = PIN(1);



        if (Plugin_067_OversamplingCount < 250)

        if (pinSCL >= 0 && pinDOUT >= 0)

        if (isReadyHX711(pinSCL, pinDOUT))

        {

          int32_t value = readHX711(pinSCL, pinDOUT, CONFIG(1));



          if (CONFIG(0))

          {

            Plugin_067_OversamplingValue += value;

            Plugin_067_OversamplingCount ++;

          }

          else

          {

            Plugin_067_OversamplingValue = value;

            Plugin_067_OversamplingCount = 1;

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("HX711: Value: ");



        if (Plugin_067_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex + 1] = (float)Plugin_067_OversamplingValue / Plugin_067_OversamplingCount;

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;



          UserVar[event->BaseVarIndex] = UserVar[event->BaseVarIndex + 1] + Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3];



          log += String(UserVar[event->BaseVarIndex], 3);



          if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

          {

            int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

            int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

            float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

            float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

            if (adc1 != adc2)

            {

              float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

              UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



              log += F(" = ");

              log += String(UserVar[event->BaseVarIndex], 3);

            }

          }

        }

        else

        {

          log += F("NO NEW VALUE");

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);



        if (command == F("tare"))

        {

          String log = F("HX711: tare");



          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = -UserVar[event->BaseVarIndex + 1];

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P068_SHT3x.ino"
#ifdef USES_P068
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P068_SHT3x.ino"
#define PLUGIN_068 

#define PLUGIN_ID_068 68

#define PLUGIN_NAME_068 "Environment - SHT30/31/35 [TESTING]"

#define PLUGIN_VALUENAME1_068 "Temperature"

#define PLUGIN_VALUENAME2_068 "Humidity"
# 45 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P068_SHT3x.ino"
# ifndef SHT3X_H

#define SHT3X_H 



class SHT3X

{

public:

 SHT3X(uint8_t addr);

 void get(void);

 float tmp=0;

 float hum=0;



private:

 uint8_t _i2c_device_address;

};



#endif
# 85 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P068_SHT3x.ino"
SHT3X::SHT3X(uint8_t addr)

{

 _i2c_device_address = addr;







 Wire.beginTransmission(_i2c_device_address);

 Wire.write(0x20);

 Wire.write(0x32);

 Wire.endTransmission();

}



void SHT3X::get()

{

 uint16_t data[6];



 Wire.beginTransmission(_i2c_device_address);

 Wire.write(0xE0);

 Wire.write(0x00);

 Wire.endTransmission();



 Wire.requestFrom(_i2c_device_address, (uint8_t)6);

 if (Wire.available() == 6)

 {

  data[0] = Wire.read();

  data[1] = Wire.read();

  data[2] = Wire.read();

  data[3] = Wire.read();

  data[4] = Wire.read();

  data[5] = Wire.read();







  tmp = ((((data[0] << 8) | data[1]) * 175.0) / 65535.0) - 45.0;

  hum = ((((data[3] << 8) | data[4]) * 100.0) / 65535.0);

 }

 else

 {

  tmp = NAN;

  hum = NAN;

 }

}



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



SHT3X* Plugin_068_SHT3x[TASKS_MAX] = { NULL, };
# 193 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P068_SHT3x.ino"
boolean Plugin_068(byte function, struct EventStruct *event, String& string)

{

 boolean success = false;



 switch (function)

 {

  case PLUGIN_DEVICE_ADD:

  {

   Device[++deviceCount].Number = PLUGIN_ID_068;

   Device[deviceCount].Type = DEVICE_TYPE_I2C;

   Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

   Device[deviceCount].Ports = 0;

   Device[deviceCount].PullUpOption = false;

   Device[deviceCount].InverseLogicOption = false;

   Device[deviceCount].FormulaOption = true;

   Device[deviceCount].ValueCount = 2;

   Device[deviceCount].SendDataOption = true;

   Device[deviceCount].TimerOption = true;

   Device[deviceCount].GlobalSyncOption = true;

   break;

  }



  case PLUGIN_GET_DEVICENAME:

  {

   string = F(PLUGIN_NAME_068);

   break;

  }



  case PLUGIN_GET_DEVICEVALUENAMES:

  {

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_068));

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_068));

   break;

  }



  case PLUGIN_WEBFORM_LOAD:

  {

   int optionValues[2] = { 0x44, 0x45 };

   addFormSelectorI2C(F("i2c_addr"), 2, optionValues, CONFIG(0));



   success = true;

   break;

  }



  case PLUGIN_WEBFORM_SAVE:

  {

   CONFIG(0) = getFormItemInt(F("i2c_addr"));



   success = true;

   break;

  }



  case PLUGIN_INIT:

  {

   if (Plugin_068_SHT3x[event->TaskIndex])

    delete Plugin_068_SHT3x[event->TaskIndex];

   Plugin_068_SHT3x[event->TaskIndex] = new SHT3X(CONFIG(0));



   success = true;

   break;

  }



  case PLUGIN_READ:

  {

   if (!Plugin_068_SHT3x[event->TaskIndex])

    return success;



   Plugin_068_SHT3x[event->TaskIndex]->get();

   UserVar[event->BaseVarIndex + 0] = Plugin_068_SHT3x[event->TaskIndex]->tmp;

   UserVar[event->BaseVarIndex + 1] = Plugin_068_SHT3x[event->TaskIndex]->hum;

   String log = F("SHT3x: Temperature: ");

   log += UserVar[event->BaseVarIndex + 0];

   addLog(LOG_LEVEL_INFO, log);

   log = F("SHT3x: Humidity: ");

   log += UserVar[event->BaseVarIndex + 1];

   addLog(LOG_LEVEL_INFO, log);

   success = true;

   break;

  }

 }

 return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P069_LM75A.ino"
#ifdef USES_P069
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P069_LM75A.ino"
#define PLUGIN_069 

#define PLUGIN_ID_069 69

#define PLUGIN_NAME_069 "Environment - LM75A"

#define PLUGIN_VALUENAME1_069 "Temperature"





#ifndef LM75A_h

#define LM75A_h 



#define INVALID_LM75A_TEMPERATURE 1000



namespace LM75AConstValues

{

  const int LM75A_BASE_ADDRESS = 0x48;

  const float LM75A_DEGREES_RESOLUTION = 0.125;

  const int LM75A_REG_ADDR_TEMP = 0;

}



using namespace LM75AConstValues;



class LM75A

{

public:

  LM75A(bool A0_value = false, bool A1_value = false, bool A2_value = false)

  {

    _i2c_device_address = LM75A_BASE_ADDRESS;



    if (A0_value) {

      _i2c_device_address += 1;

    }



    if (A1_value) {

      _i2c_device_address += 2;

    }



    if (A2_value) {

      _i2c_device_address += 4;

    }





  }



  LM75A(uint8_t addr)

  {

    _i2c_device_address = addr;



  }



  float getTemperatureInDegrees() const

  {

    float real_result = INVALID_LM75A_TEMPERATURE;

    int16_t value = 0;





    Wire.beginTransmission(_i2c_device_address);

    Wire.write(LM75A_REG_ADDR_TEMP);

    if (Wire.endTransmission())

    {



      return real_result;

    }





    Wire.requestFrom(_i2c_device_address, (uint8_t)2);

    if (Wire.available() == 2)

    {

      value = (Wire.read() << 8) | Wire.read();

    }

    else

    {



      return real_result;

    }





    value >>= 5;





    if (value & 0x0400)

    {

      value |= 0xFC00;

    }





    real_result = (float)value * LM75A_DEGREES_RESOLUTION;



    return real_result;

  }



private:

  uint8_t _i2c_device_address;

};



#endif



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



LM75A* PLUGIN_069_LM75A = NULL;





boolean Plugin_069(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

    {

      Device[++deviceCount].Number = PLUGIN_ID_069;

      Device[deviceCount].Type = DEVICE_TYPE_I2C;

      Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

      Device[deviceCount].Ports = 0;

      Device[deviceCount].PullUpOption = false;

      Device[deviceCount].InverseLogicOption = false;

      Device[deviceCount].FormulaOption = true;

      Device[deviceCount].ValueCount = 1;

      Device[deviceCount].SendDataOption = true;

      Device[deviceCount].TimerOption = true;

      Device[deviceCount].GlobalSyncOption = true;

      break;

    }



    case PLUGIN_GET_DEVICENAME:

    {

      string = F(PLUGIN_NAME_069);

      break;

    }



    case PLUGIN_GET_DEVICEVALUENAMES:

    {

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_069));

      break;

    }



    case PLUGIN_WEBFORM_LOAD:

    {

      int optionValues[8] = { 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F };

      addFormSelectorI2C(F("i2c_addr"), 8, optionValues, CONFIG(0));



      success = true;

      break;

    }



    case PLUGIN_WEBFORM_SAVE:

    {

      CONFIG(0) = getFormItemInt(F("i2c_addr"));



      success = true;

      break;

    }



    case PLUGIN_INIT:

    {

      if (PLUGIN_069_LM75A)

        delete PLUGIN_069_LM75A;

      PLUGIN_069_LM75A = new LM75A((uint8_t)CONFIG(0));



      success = true;

      break;

    }



    case PLUGIN_READ:

    {

      if (!PLUGIN_069_LM75A)

        return success;



      float tempC = PLUGIN_069_LM75A->getTemperatureInDegrees();



      if (tempC == INVALID_LM75A_TEMPERATURE)

      {

        String log = F("LM75A: No reading!");

        addLog(LOG_LEVEL_INFO, log);

        UserVar[event->BaseVarIndex] = NAN;

      }

      else

      {

        UserVar[event->BaseVarIndex] = tempC;

        String log = F("LM75A: Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

      }

      break;

    }

  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P070_NeoPixel_Clock.ino"
#ifdef USES_P070
# 13 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P070_NeoPixel_Clock.ino"
#ifdef PLUGIN_BUILD_DISABLED
# 31 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P070_NeoPixel_Clock.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



#include <Adafruit_NeoPixel.h>



#define NUMBER_LEDS 60



boolean Plugin_070_enabled;

byte Plugin_070_brightness;

byte Plugin_070_marks;

byte Plugin_070_offset;

boolean thick_12_mark;

byte marks[14];



Adafruit_NeoPixel * Plugin_070_pixels;



#define PLUGIN_070 

#define PLUGIN_ID_070 70

#define PLUGIN_NAME_070 "Output - NeoPixel Ring Clock [TESTING]"

#define PLUGIN_VALUENAME1_070 "Enabled"

#define PLUGIN_VALUENAME2_070 "Brightness"

#define PLUGIN_VALUENAME3_070 "Marks"

boolean Plugin_070(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_070;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_070);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_070));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_070));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_070));

        break;

      }



 case PLUGIN_GET_DEVICEGPIONAMES:

   {

      event->String1 = F("GPIO &rarr; LED");

        break;

   }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormSubHeader(F("Clock configuration"));

        addFormNumericBox(F("12 o'clock LED position"), F("offset"), CONFIG(3), 0, 59);

        addFormNote(F("Position of the 12 o'clock LED in the strip"));

        addFormCheckBox(F("Thick 12 o'clock mark"), F("thick_12_mark"), CONFIG(4));

        addFormNote(F("Check to have 3 LEDs marking the 12 o'clock position"));

        addFormCheckBox(F("Clock display enabled"), F("enabled"), CONFIG(0));

        addFormNote(F("LED activation"));

        addFormNumericBox(F("LED brightness"), F("brightness"), CONFIG(1), 0, 255);

        addFormNote(F("Brightness level of the H/M/S hands (0-255)"));

        addFormNumericBox(F("Hour mark brightness"), F("marks"), CONFIG(2), 0, 255);

        addFormNote(F("Brightness level of the hour marks (0-255)"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = isFormItemChecked(F("enabled"));

        CONFIG(1) = getFormItemInt(F("brightness"));

        CONFIG(2) = getFormItemInt(F("marks"));

        CONFIG(3) = getFormItemInt(F("offset"));

        CONFIG(4) = isFormItemChecked(F("thick_12_mark"));



        Plugin_070_enabled = CONFIG(0);

        Plugin_070_brightness = CONFIG(1);

        Plugin_070_marks = CONFIG(2);

        Plugin_070_offset = CONFIG(3);

        thick_12_mark = CONFIG(4);



        calculateMarks();



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_070_pixels)

        {

          Plugin_070_pixels = new Adafruit_NeoPixel(NUMBER_LEDS, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          Plugin_070_pixels->begin();

        }

        Plugin_070_enabled = CONFIG(0);

        Plugin_070_brightness = CONFIG(1);

        Plugin_070_marks = CONFIG(2);

        Plugin_070_offset = CONFIG(3);

        thick_12_mark = CONFIG(4);



        calculateMarks();



        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        Clock_update();

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);

        String param1 = parseString(lowerString, 2);

        String param2 = parseString(lowerString, 3);

        String param3 = parseString(lowerString, 4);



        if (command == F("clock")) {

          if (param1 != "") {

            int val_Mode = param1.toInt();

            if (val_Mode > -1 && val_Mode < 2) {

              Plugin_070_enabled = val_Mode;

              CONFIG(0) = Plugin_070_enabled;

            }

          }

          if (param2 != "") {

            int val_Bright = param2.toInt();

            if (val_Bright > -1 && val_Bright < 256) {

              Plugin_070_brightness = val_Bright;

              CONFIG(1) = Plugin_070_brightness;

            }

          }

          if (param3 != "") {

            int val_Marks = param3.toInt();

            if (val_Marks > -1 && val_Marks < 256) {

              Plugin_070_marks = val_Marks;

              CONFIG(2) = Plugin_070_marks;

            }

          }
# 379 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P070_NeoPixel_Clock.ino"
          success = true;

        }

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_070_enabled;

        UserVar[event->BaseVarIndex + 1] = Plugin_070_brightness;

        UserVar[event->BaseVarIndex + 2] = Plugin_070_marks;



        success = true;

      }



  }

  return success;

}



void Clock_update()

{

  clearClock();

  if (Plugin_070_enabled > 0) {

    int Hours = hour();

    int Minutes = minute();

    int Seconds = second();

    timeToStrip(Hours, Minutes, Seconds);

  }

  Plugin_070_pixels->show();

}



void calculateMarks()

{

  for (int i = 0; i < 12; i++) {

    marks[i] = 5 * i + (Plugin_070_offset % 5);

  }

  if (thick_12_mark) {

    if (Plugin_070_offset == 0) {

      marks[12] = 1;

      marks[13] = 59;

    }

    else if (Plugin_070_offset == 59) {

      marks[12] = 0;

      marks[13] = 58;

    }

    else {

      marks[12] = Plugin_070_offset + 1;

      marks[13] = Plugin_070_offset - 1;

    }

  }

  else {

    marks[12] = 255;

    marks[13] = 255;

  }

}



void clearClock() {

  for (int i = 0; i < NUMBER_LEDS; i++) {

    Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(0, 0, 0));

  }

}



void timeToStrip(int hours, int minutes, int seconds) {

  if (hours > 11) hours = hours - 12;

  hours = (hours * 5) + (minutes / 12) + Plugin_070_offset;

  if (hours > 59) hours = hours - 60;

  minutes = minutes + Plugin_070_offset;

  if (minutes > 59) minutes = minutes - 60;

  seconds = seconds + Plugin_070_offset;

  if (seconds > 59) seconds = seconds - 60;

  for (int i = 0 ; i < 14; i ++) {

    if ((marks[i] != hours) && (marks[i] != minutes) && (marks[i] != seconds) && (marks[i] != 255)) {

      Plugin_070_pixels->setPixelColor(marks[i], Plugin_070_pixels->Color(Plugin_070_marks, Plugin_070_marks, Plugin_070_marks));

    }

  }

  uint32_t currentColor;

  uint8_t r_val, g_val, b_val;

  for (int i = 0; i < NUMBER_LEDS; i++) {

    if (i == hours) {

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(Plugin_070_brightness, 0, 0));

    }

    if (i == minutes) {

      currentColor = Plugin_070_pixels->getPixelColor(i);

      r_val = (uint8_t)(currentColor >> 16);

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(r_val, Plugin_070_brightness, 0));

    }

    if (i == seconds) {

      currentColor = Plugin_070_pixels->getPixelColor(i);

      r_val = (uint8_t)(currentColor >> 16);

      g_val = (uint8_t)(currentColor >> 8);

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(r_val, g_val, Plugin_070_brightness));

    }

  }

}



#endif

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P071_Kamstrup401.ino"
#ifdef USES_P071
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P071_Kamstrup401.ino"
#include <ESPeasySoftwareSerial.h>

#define PLUGIN_071 

#define PLUGIN_ID_071 71

#define PLUGIN_NAME_071 "Communication - Kamstrup Multical 401 [TESTING]"

#define PLUGIN_VALUENAME1_071 "Heat"

#define PLUGIN_VALUENAME2_071 "Volume"



boolean Plugin_071_init = false;

byte PIN_KAMSER_RX = 0;

byte PIN_KAMSER_TX = 0;



boolean Plugin_071(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_071;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_071);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_071));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_071));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_071_init = true;



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        PIN_KAMSER_RX = Settings.TaskDevicePin1[event->TaskIndex];

        PIN_KAMSER_TX = Settings.TaskDevicePin2[event->TaskIndex];



        ESPeasySoftwareSerial kamSer(PIN_KAMSER_RX, PIN_KAMSER_TX, false);



        pinMode(PIN_KAMSER_RX,INPUT);

        pinMode(PIN_KAMSER_TX,OUTPUT);





        byte sendmsg1[] = { 175,163,177 };



        byte r = 0;

        byte to = 0;

        byte i;

        char message[255];

        int parityerrors;





        kamSer.begin(300);

        for (int x = 0; x < 3; x++) {

          kamSer.write(sendmsg1[x]);

        }



        kamSer.flush();



        kamSer.begin(1200);



        to = 0;

        r = 0;

        i = 0;

        parityerrors = 0;

        char *tmpstr;

        double m_energy, m_volume;

        float m_tempin, m_tempout, m_tempdiff, m_power;

        long m_hours, m_flow;



        while(r != 0x0A)

        {

          if (kamSer.available())

          {



            r = kamSer.read();



            if (parity_check(r))

            {

               parityerrors += 1;

            }

            r = r & 127;



            message[i++] = char(r);

          }

          else

          {

            to++;

            delay(25);

          }



          if (i>=79)

          {

            if ( parityerrors == 0 )

            {





              message[i] = 0;



              tmpstr = strtok(message, " ");

              if (tmpstr){

               m_energy = atol(tmpstr)/3.6*1000;

              }

              else

               m_energy = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_volume = atol(tmpstr);

              else

               m_volume = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_hours = atol(tmpstr);

              else

               m_hours = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempin = atol(tmpstr)/100.0;

              else

               m_tempin = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempout = atol(tmpstr)/100.0;

              else

               m_tempout = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempdiff = atol(tmpstr)/100.0;

              else

               m_tempdiff = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_power = atol(tmpstr)/10.0;

              else

               m_power = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_flow = atol(tmpstr);

              else

               m_flow = 0;



               String log = F("Kamstrup output: ");

               log += m_energy;

               log += F(" MJ;  ");

               log += m_volume;

               log += F(" L; ");

               log += m_hours;

               log += F(" h; ");

               log += m_tempin;

               log += F(" C; ");

               log += m_tempout;

               log += F(" C; ");

               log += m_tempdiff;

               log += F(" C; ");

               log += m_power;

               log += F(" ");

               log += m_flow;

               log += F(" L/H");





              UserVar[event->BaseVarIndex] = m_energy;

              UserVar[event->BaseVarIndex+1] = m_volume;



              log = F("Kamstrup  : Heat value: ");

              log += m_energy/1000;

              log += F(" kWh");

              addLog(LOG_LEVEL_INFO, log);

              log = F("Kamstrup  : Volume value: ");

              log += m_volume;

              log += F(" Liter");

              addLog(LOG_LEVEL_INFO, log);

            }

            else

            {

              message[i] = 0;

              String log = F("ERR(PARITY):" );

              Serial.print("par");

              log += message;

              addLog(LOG_LEVEL_INFO, log);





            }

            break;

          }

          if (to>100)

          {

            message[i] = 0;

            String log = F("ERR(TIMEOUT):" );

            log += message;

            addLog(LOG_LEVEL_INFO, log);







            break;

          }

        }
# 497 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P071_Kamstrup401.ino"
        success = true;

        break;

      }

  }

  return success;

}



bool parity_check(unsigned input) {

    bool inputparity = input & 128;

    int x = input & 127;



    int parity = 0;

    while(x != 0) {

        parity ^= x;

        x >>= 1;

    }



    if ( (parity & 0x1) != inputparity )

      return(1);

    else

      return(0);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P072_HDC1080.ino"
#ifdef USES_P072
# 13 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P072_HDC1080.ino"
#define PLUGIN_072 

#define PLUGIN_ID_072 72

#define PLUGIN_NAME_072 "Environment - HDC1080 (I2C) [TESTING]"

#define PLUGIN_VALUENAME1_072 "Temperature"

#define PLUGIN_VALUENAME2_072 "Humidity"



boolean Plugin_072_init = false;



#define HDC1080_I2C_ADDRESS 0x40



boolean Plugin_072(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_072;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_072);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_072));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_072));

        break;

      }



    case PLUGIN_READ:

      {

        byte hdc1080_msb, hdc1080_lsb;

        uint16_t hdc1080_rawtemp, hdc1080_rawhum;

        float hdc1080_temp, hdc1080_hum;



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x02);

        Wire.write(0b00000000);

        Wire.write(0x00);

        Wire.endTransmission();

        delay(10);



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x00);

        Wire.endTransmission();

        delay(9);

        Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);

        hdc1080_msb = Wire.read();

        hdc1080_lsb = Wire.read();

        hdc1080_rawtemp = hdc1080_msb << 8 | hdc1080_lsb;

        hdc1080_temp = (hdc1080_rawtemp / pow(2,16)) * 165 -40;



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x01);

        Wire.endTransmission();

        delay(9);

        Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);

        hdc1080_msb = Wire.read();

        hdc1080_lsb = Wire.read();

        hdc1080_rawhum = hdc1080_msb << 8 | hdc1080_lsb;

        hdc1080_hum = (hdc1080_rawhum / pow(2,16)) * 100;



        UserVar[event->BaseVarIndex] = hdc1080_temp;

        UserVar[event->BaseVarIndex + 1] = hdc1080_hum;

        String log = F("HDC1080: Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        log = F("HDC1080: Humidity: ");

        log += UserVar[event->BaseVarIndex + 1];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;



      }

  }

  return success;

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
#ifdef USES_P073
# 53 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
#define PLUGIN_073 

#define PLUGIN_ID_073 73

#define PLUGIN_NAME_073 "Display - 7-segment display [TESTING]"

#define PLUGIN_073_DEBUG false
# 69 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
class p073_7dgt

{

  public:

    uint8_t pin1, pin2, pin3;

    byte type;

    byte output;

    byte brightness;

    boolean timesep;

};

p073_7dgt *Plugin_073_7dgt = NULL;





uint8_t p073_showbuffer[8];

byte p073_spidata[2];

byte p073_dotpos;

bool p073_shift;



#define TM1637_POWER_ON B10001000

#define TM1637_POWER_OFF B10000000

#define TM1637_CLOCKDELAY 40

#define TM1637_4DIGIT 4

#define TM1637_6DIGIT 2
# 125 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
const byte CharTableTM1637 [13] = {B00111111,B00000110,B01011011,B01001111,B01100110,B01101101,B01111101,B00000111,B01111111,B01101111,B00000000,B01000000,B01100011};

const byte CharTableMAX7219 [13] = {B01111110,B00110000,B01101101,B01111001,B00110011,B01011011,B01011111,B01110000,B01111111,B01111011,B00000000,B00000001,B01100011};



boolean Plugin_073(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_073;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_073);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("TM1637:  1st=CLK-Pin, 2nd=DIO-Pin"));

        addFormNote(F("MAX7219: 1st=DIN-Pin, 2nd=CLK-Pin, 3rd=CS-Pin"));

        String displtype[5] = { F("TM1637 - 4 digit (colon)"), F("TM1637 - 4 digit (dots)"), F("TM1637 - 6 digit"), F("MAX7219 - 8 digit")};

        addFormSelector(F("Display Type"), F("plugin_073_displtype"), 4, displtype, NULL, Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        String displout[4] = { F("Manual"), F("Clock - Blink"), F("Clock - No Blink"), F("Date") };

        addFormSelector(F("Display Output"), F("plugin_073_displout"), 4, displout, NULL, Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addFormNumericBox(F("Brightness"), F("plugin_073_brightness"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 15);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_073_displtype"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_073_displout"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_073_brightness"));

        if (Plugin_073_7dgt) {

          Plugin_073_7dgt->pin1 = Settings.TaskDevicePin1[event->TaskIndex];

          Plugin_073_7dgt->pin2 = Settings.TaskDevicePin2[event->TaskIndex];

          Plugin_073_7dgt->pin3 = Settings.TaskDevicePin3[event->TaskIndex];

          Plugin_073_7dgt->type = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          Plugin_073_7dgt->output = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          Plugin_073_7dgt->brightness = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          Plugin_073_7dgt->timesep = true;

          switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          {

            case 0:

            case 1:

            case 2:

              {

                int tm1637_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 2;

                tm1637_SetPowerBrightness(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], tm1637_bright, true);

                if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 0)

                  tm1637_ClearDisplay(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex]);

                break;

              }

            case 3:

              {

                max7219_SetPowerBrightness(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin3[event->TaskIndex], Settings.TaskDevicePluginConfig[event->TaskIndex][2], true);

                if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 0)

                  max7219_ClearDisplay(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin3[event->TaskIndex]);

                break;

              }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_073_7dgt) {

          Plugin_073_7dgt = new p073_7dgt;

            Plugin_073_7dgt->pin1 = Settings.TaskDevicePin1[event->TaskIndex];

            Plugin_073_7dgt->pin2 = Settings.TaskDevicePin2[event->TaskIndex];

            Plugin_073_7dgt->pin3 = Settings.TaskDevicePin3[event->TaskIndex];

            Plugin_073_7dgt->type = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            Plugin_073_7dgt->output = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Plugin_073_7dgt->brightness = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          {

            case 0:

            case 1:

            case 2:

              {

                tm1637_InitDisplay(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex]);

                int tm1637_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 2;

                tm1637_SetPowerBrightness(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], tm1637_bright, true);

                break;

              }

            case 3:

              {

                max7219_InitDisplay(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin3[event->TaskIndex]);

                max7219_SetPowerBrightness(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin3[event->TaskIndex], Settings.TaskDevicePluginConfig[event->TaskIndex][2], true);

                break;

              }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_073_7dgt)

          break;



        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        String tmpStr = string;

        int comma1 = tmpStr.indexOf(',');



        if (tmpString.equalsIgnoreCase(F("7dn"))) {

          if (Plugin_073_7dgt->output != 0)

            break;

          String log = F("7DGT : Show Number=");

          log += event->Par1;

          addLog(LOG_LEVEL_INFO, log);

          switch (Plugin_073_7dgt->type)

          {

            case 0:

              if (event->Par1 > -1000 && event->Par1 < 10000)

                p073_FillBufferWithNumber(String(int(event->Par1)));

              else

                p073_FillBufferWithDash();

              tm1637_ShowBuffer(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, TM1637_4DIGIT);

              break;

            case 1:

            {

              if (event->Par1 > -1000 && event->Par1 < 10000)

                p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

              else

                p073_FillBufferWithDash();

              tm1637_ShowBuffer(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, TM1637_4DIGIT);

              break;

            }

            case 2:

            {

              if (event->Par1 > -100000 && event->Par1 < 1000000)

                p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

              else

                p073_FillBufferWithDash();

              tm1637_SwapDigitInBuffer();

              tm1637_ShowBuffer(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, TM1637_6DIGIT);

              break;

            }

            case 3:

            {

              if (comma1 > 0) {

                if (event->Par1 > -10000000 && event->Par1 < 100000000) {

                  p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

                }

                else

                  p073_FillBufferWithDash();

                max7219_ShowBuffer(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->pin3);

              }

              break;

            }

          }

          success = true;

        } else if (tmpString.equalsIgnoreCase(F("7dt"))) {

          if (Plugin_073_7dgt->output != 0)

            break;

          double p073_temptemp = 0;

          bool p073_tempflagdot = false;

          if (comma1 > 0)

            p073_temptemp = atof(tmpStr.substring(comma1+1).c_str());

          String log = F("7DGT : Show Temperature=");

          log += p073_temptemp;

          addLog(LOG_LEVEL_INFO, log);

          switch (Plugin_073_7dgt->type)

          {

            case 0:

            case 1:

            {

              if (p073_temptemp > 999 || p073_temptemp < -99.9)

                p073_FillBufferWithDash();

              else {

                if (p073_temptemp < 100 && p073_temptemp > -10) {

                  p073_temptemp = int(p073_temptemp*10);

                  p073_tempflagdot = true;

                }

                p073_FillBufferWithTemp(p073_temptemp);

                if (p073_temptemp == 0 && p073_tempflagdot)

                  p073_showbuffer[5] = 0;

              }

              tm1637_ShowTimeTemp4(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, p073_tempflagdot, 4);

              break;

            }

            case 2:

            {

              if (p073_temptemp > 999 || p073_temptemp < -99.9)

                p073_FillBufferWithDash();

              else {

                if (p073_temptemp < 100 && p073_temptemp > -10) {

                  p073_temptemp = int(p073_temptemp*10);

                  p073_tempflagdot = true;

                }

                p073_FillBufferWithTemp(p073_temptemp);

                if (p073_temptemp == 0 && p073_tempflagdot)

                  p073_showbuffer[5] = 0;

              }

              tm1637_ShowTemp6(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, p073_tempflagdot);

              break;

            }

            case 3:

            {

              p073_temptemp = int(p073_temptemp*10);

              p073_FillBufferWithTemp(p073_temptemp);

              if (p073_temptemp == 0)

                p073_showbuffer[5] = 0;

              max7219_ShowTemp(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->pin3);

              break;

            }

          }

          success = true;

        } else {

          bool p073_validcmd = false;

          bool p073_displayon;

          if (tmpString.equalsIgnoreCase(F("7don"))) {

            String log = F("7DGT : Display ON");

            addLog(LOG_LEVEL_INFO, log);

            p073_displayon = true;

            p073_validcmd = true;

          }

          else if (tmpString.equalsIgnoreCase(F("7doff"))) {

            String log = F("7DGT : Display OFF");

            addLog(LOG_LEVEL_INFO, log);

            p073_displayon = false;

            p073_validcmd = true;

          }

          else if (tmpString.equalsIgnoreCase(F("7db"))) {

            if (event->Par1 >= 0 && event->Par1 < 16) {

              String log = F("7DGT : Brightness=");

              log += event->Par1;

              addLog(LOG_LEVEL_INFO, log);

              Plugin_073_7dgt->brightness = event->Par1;

              p073_displayon = true;

              p073_validcmd = true;

            }

          }

          if (p073_validcmd) {

            success = true;

            switch (Plugin_073_7dgt->type)

            {

              case 0:

              case 1:

              case 2:

              { int tm1637_bright = Plugin_073_7dgt->brightness / 2;

                tm1637_SetPowerBrightness(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, tm1637_bright, p073_displayon);

                break; }

              case 3:

              { max7219_SetPowerBrightness(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->pin3, Plugin_073_7dgt->brightness, p073_displayon);

                break; }

            }

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if (Plugin_073_7dgt->output == 0)

          break;



        if (Plugin_073_7dgt->output == 1)

          { Plugin_073_7dgt->timesep = !Plugin_073_7dgt->timesep; }

        else

          { Plugin_073_7dgt->timesep = true; }



        if (Plugin_073_7dgt->output == 3)

          p073_FillBufferWithDate();

        else

          p073_FillBufferWithTime();



        switch (Plugin_073_7dgt->type)

        {

          case 0:

          case 1:

          {

            tm1637_ShowTimeTemp4(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->timesep, 0);

            break;

          }

          case 2:

          {

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 3)

              tm1637_ShowDate6(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->timesep);

            else

              tm1637_ShowTime6(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->timesep);

            break;

          }

          case 3:

          {

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 3)

              max7219_ShowDate(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->pin3);

            else

              max7219_ShowTime(Plugin_073_7dgt->pin1, Plugin_073_7dgt->pin2, Plugin_073_7dgt->pin3, Plugin_073_7dgt->timesep);

            break;

          }

        }

      }



  }

  return success;

}



void p073_FillBufferWithTime()

{

  memset(p073_showbuffer,0,sizeof(p073_showbuffer));

  byte sevendgt_hours = hour();

  byte sevendgt_minutes = minute();

  byte sevendgt_seconds = second();

  uint8_t p073_digit1, p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_hours / 10);

  p073_digit2 = sevendgt_hours - p073_digit1*10;

  p073_showbuffer[0] = p073_digit1; p073_showbuffer[1] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_minutes / 10);

  p073_digit2 = sevendgt_minutes - p073_digit1*10;

  p073_showbuffer[2] = p073_digit1; p073_showbuffer[3] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_seconds / 10);

  p073_digit2 = sevendgt_seconds - p073_digit1*10;

  p073_showbuffer[4] = p073_digit1; p073_showbuffer[5] = p073_digit2;

}



void p073_FillBufferWithDate()

{

  memset(p073_showbuffer,0,sizeof(p073_showbuffer));

  byte sevendgt_day = day();

  byte sevendgt_month = month();

  byte sevendgt_year1 = uint8_t(year()/100);

  byte sevendgt_year2 = uint8_t(year()-(sevendgt_year1*100));

  uint8_t p073_digit1, p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_day / 10);

  p073_digit2 = sevendgt_day - p073_digit1*10;

  p073_showbuffer[0] = p073_digit1; p073_showbuffer[1] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_month / 10);

  p073_digit2 = sevendgt_month - p073_digit1*10;

  p073_showbuffer[2] = p073_digit1; p073_showbuffer[3] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_year1 / 10);

  p073_digit2 = sevendgt_year1 - p073_digit1*10;

  p073_showbuffer[4] = p073_digit1; p073_showbuffer[5] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_year2 / 10);

  p073_digit2 = sevendgt_year2 - p073_digit1*10;

  p073_showbuffer[6] = p073_digit1; p073_showbuffer[7] = p073_digit2;

}



void p073_FillBufferWithNumber(String number)

{

  memset(p073_showbuffer,10,sizeof(p073_showbuffer));

  byte p073_numlenght = number.length();

  byte p073_dispdigit;

  byte p073_index = 7;

  p073_dotpos = -1;

  for (int i=p073_numlenght;i>0;i--) {

    char p073_tmpchar = number.charAt(i-1);

    p073_dispdigit = 10;

    if (p073_tmpchar > 47 && p073_tmpchar < 58)

      p073_dispdigit = p073_tmpchar-48;

    else if (p073_tmpchar == 32)

      p073_dispdigit = 10;

    else if (p073_tmpchar == 45)

      p073_dispdigit = 11;

    if (p073_tmpchar == 46)

      p073_dotpos = p073_index;

    else {

      p073_showbuffer[p073_index] = p073_dispdigit;

      p073_index--; }

  }

}



void p073_FillBufferWithTemp(long temperature)

{

  memset(p073_showbuffer,10,sizeof(p073_showbuffer));

  char p073_digit[8];

  sprintf(p073_digit, "%7d", static_cast<int>(temperature));

  int p073_numlenght = strlen(p073_digit);

  byte p073_dispdigit;

  for (int i=0;i<p073_numlenght;i++) {

    if (p073_digit[i] > 47 && p073_digit[i] < 58)

      p073_dispdigit = p073_digit[i]-48;

    else if (p073_digit[i] == 32)

      p073_dispdigit = 10;

    else if (p073_digit[i] == 45)

      p073_dispdigit = 11;

    p073_showbuffer[i] = p073_dispdigit;

  }

  p073_showbuffer[7] = 12;

}



void p073_FillBufferWithDash()

{

  memset(p073_showbuffer,11,sizeof(p073_showbuffer));

}
# 955 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
#define CLK_HIGH() digitalWrite(clk_pin, HIGH)

#define CLK_LOW() digitalWrite(clk_pin, LOW)

#define DIO_HIGH() pinMode(dio_pin, INPUT)

#define DIO_LOW() pinMode(dio_pin, OUTPUT)



void tm1637_i2cStart (uint8_t clk_pin, uint8_t dio_pin)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm Start");

    addLog(LOG_LEVEL_INFO, log);

  }

  DIO_HIGH();

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_LOW();

}



void tm1637_i2cStop (uint8_t clk_pin, uint8_t dio_pin)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm Stop");

    addLog(LOG_LEVEL_INFO, log);

  }

  CLK_LOW();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_LOW();

  delayMicroseconds(TM1637_CLOCKDELAY);

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_HIGH();

}



void tm1637_i2cAck (uint8_t clk_pin, uint8_t dio_pin)

{

  bool dummyAck = false;

  CLK_LOW();

  pinMode(dio_pin, INPUT_PULLUP);



  delayMicroseconds(TM1637_CLOCKDELAY);



  dummyAck = digitalRead(dio_pin);

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm ACK=");

    if (dummyAck == 0) { log += F("TRUE"); } else { log += F("FALSE"); }

    addLog(LOG_LEVEL_INFO, log);

  }

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  CLK_LOW();

  pinMode(dio_pin, OUTPUT);

}



void tm1637_i2cWrite (uint8_t clk_pin, uint8_t dio_pin, uint8_t bytetoprint)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : WriteByte");

    addLog(LOG_LEVEL_INFO, log);

  }

  uint8_t i;

  for(i=0; i<8; i++)

  {

    CLK_LOW();

    (bytetoprint & B00000001)? DIO_HIGH() : DIO_LOW();

    delayMicroseconds(TM1637_CLOCKDELAY);

    bytetoprint = bytetoprint >> 1;

    CLK_HIGH();

    delayMicroseconds(TM1637_CLOCKDELAY);

  }

}



void tm1637_ClearDisplay (uint8_t clk_pin, uint8_t dio_pin)

{

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_SetPowerBrightness (uint8_t clk_pin, uint8_t dio_pin, uint8_t brightlvl, bool poweron)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Set BRIGHT");

    addLog(LOG_LEVEL_INFO, log);

  }

  uint8_t brightvalue = (brightlvl & 0b111);

  if (poweron)

    brightvalue = TM1637_POWER_ON | brightvalue;

  else

    brightvalue = TM1637_POWER_OFF | brightvalue;

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, brightvalue);

  tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_InitDisplay(uint8_t clk_pin, uint8_t dio_pin)

{

  pinMode(clk_pin, OUTPUT);

  pinMode(dio_pin, OUTPUT);

  CLK_HIGH();

  DIO_HIGH();





  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0x40);

  tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

  tm1637_ClearDisplay(clk_pin, dio_pin);

}



void tm1637_ShowTime6(uint8_t clk_pin, uint8_t dio_pin, bool sep)

{

  byte p073_datashowpos1;

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[2]]); tm1637_i2cAck(clk_pin, dio_pin);



    p073_datashowpos1 = CharTableTM1637[p073_showbuffer[1]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[0]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[5]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[4]]); tm1637_i2cAck(clk_pin, dio_pin);



    p073_datashowpos1 = CharTableTM1637[p073_showbuffer[3]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_ShowDate6(uint8_t clk_pin, uint8_t dio_pin, bool sep)

{

  byte p073_datashowpos1;

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[2]]); tm1637_i2cAck(clk_pin, dio_pin);



    p073_datashowpos1 = CharTableTM1637[p073_showbuffer[1]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[0]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[7]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[6]]); tm1637_i2cAck(clk_pin, dio_pin);



    p073_datashowpos1 = CharTableTM1637[p073_showbuffer[3]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_ShowTemp6(uint8_t clk_pin, uint8_t dio_pin, bool sep)

{

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);



    byte p073_datashowpos1 = CharTableTM1637[p073_showbuffer[5]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[4]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[10]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[10]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[7]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[6]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_ShowTimeTemp4(uint8_t clk_pin, uint8_t dio_pin, bool sep, byte bufoffset)

{

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[0+bufoffset]]); tm1637_i2cAck(clk_pin, dio_pin);



    byte p073_datashowpos1 = CharTableTM1637[p073_showbuffer[1+bufoffset]];

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[2+bufoffset]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, CharTableTM1637[p073_showbuffer[3+bufoffset]]); tm1637_i2cAck(clk_pin, dio_pin);

  tm1637_i2cStop(clk_pin, dio_pin);

}



void tm1637_SwapDigitInBuffer() {

  uint8_t p073_temp;

  p073_temp = p073_showbuffer[4]; p073_showbuffer[4] = p073_showbuffer[2]; p073_showbuffer[2] = p073_temp;

  p073_temp = p073_showbuffer[5]; p073_showbuffer[5] = p073_showbuffer[7]; p073_showbuffer[7] = p073_temp;

  switch (p073_dotpos)

  {

    case 2: { p073_dotpos = 4; break; }

    case 4: { p073_dotpos = 2; break; }

    case 5: { p073_dotpos = 7; break; }

    case 7: { p073_dotpos = 5; break; }

  }

}



void tm1637_ShowBuffer(uint8_t clk_pin, uint8_t dio_pin, byte digits)

{

  byte p073_datashowpos1;

  tm1637_i2cStart(clk_pin, dio_pin);

  tm1637_i2cWrite(clk_pin, dio_pin, 0xC0); tm1637_i2cAck(clk_pin, dio_pin);

    for(int i=digits;i<8;i++) {

    p073_datashowpos1 = CharTableTM1637[p073_showbuffer[i]];

    if (p073_dotpos == i) p073_datashowpos1 |= 0b10000000;

    tm1637_i2cWrite(clk_pin, dio_pin, p073_datashowpos1); tm1637_i2cAck(clk_pin, dio_pin);

  }

  tm1637_i2cStop(clk_pin, dio_pin);

}
# 1385 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P073_7DGT.ino"
#define OP_DECODEMODE 9

#define OP_INTENSITY 10

#define OP_SCANLIMIT 11

#define OP_SHUTDOWN 12

#define OP_DISPLAYTEST 15



void max7219_spiTransfer (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, volatile byte opcode, volatile byte data)

{

  p073_spidata[0]=(byte)0; p073_spidata[1]=(byte)0;

  p073_spidata[1]=opcode; p073_spidata[0]=data;

  digitalWrite(cs_pin,LOW);

  shiftOut(din_pin,clk_pin,MSBFIRST,p073_spidata[1]);

  shiftOut(din_pin,clk_pin,MSBFIRST,p073_spidata[0]);

  digitalWrite(cs_pin,HIGH);

}



void max7219_ClearDisplay (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin)

{

  for(int i=0;i<8;i++) {

    max7219_spiTransfer(din_pin, clk_pin, cs_pin, i+1, 0);

  }

}



void max7219_SetPowerBrightness (uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, uint8_t brightlvl, bool poweron)

{

  max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_INTENSITY, brightlvl);

  if (poweron)

    max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_SHUTDOWN, 1);

  else

    max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_SHUTDOWN, 0);

}



void max7219_SetDigit(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, int dgtpos, byte dgtvalue, boolean showdot)

{

  byte p073_tempvalue;

  p073_tempvalue = CharTableMAX7219[dgtvalue];

  if(showdot)

    p073_tempvalue |= 0b10000000;

  max7219_spiTransfer(din_pin, clk_pin, cs_pin, dgtpos+1, p073_tempvalue);

}



void max7219_InitDisplay(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin)

{

  pinMode(din_pin, OUTPUT);

  pinMode(clk_pin, OUTPUT);

  pinMode(cs_pin, OUTPUT);

  digitalWrite(cs_pin, HIGH);

  max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_DISPLAYTEST, 0);

  max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_SCANLIMIT, 7);

  max7219_spiTransfer(din_pin, clk_pin, cs_pin, OP_DECODEMODE, 0);

  max7219_ClearDisplay(din_pin, clk_pin, cs_pin);

  max7219_SetPowerBrightness(din_pin, clk_pin, cs_pin,0,false);

}



void max7219_ShowTime(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin, bool sep)

{

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 0, p073_showbuffer[5], false);

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 1, p073_showbuffer[4], false);

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 3, p073_showbuffer[3], false);

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 4, p073_showbuffer[2], false);

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 6, p073_showbuffer[1], false);

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 7, p073_showbuffer[0], false);

  if (sep) {

    max7219_SetDigit(din_pin, clk_pin, cs_pin, 2, 11, false);

    max7219_SetDigit(din_pin, clk_pin, cs_pin, 5, 11, false);

  }

  else {

    max7219_SetDigit(din_pin, clk_pin, cs_pin, 2, 10, false);

    max7219_SetDigit(din_pin, clk_pin, cs_pin, 5, 10, false);

  }

}



void max7219_ShowTemp(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin)

{

  max7219_SetDigit(din_pin, clk_pin, cs_pin, 0, 10, false);

  byte dotflags[8] = {false,false,false,false,false,true,false,false};

  for(int i=1;i<8;i++)

    max7219_SetDigit(din_pin, clk_pin, cs_pin, i, p073_showbuffer[8-i], dotflags[8-i]);

}



void max7219_ShowDate(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin)

{

  byte dotflags[8] = {false,true,false,true,false,false,false,false};

  for(int i=0;i<8;i++)

    max7219_SetDigit(din_pin, clk_pin, cs_pin, i, p073_showbuffer[7-i], dotflags[7-i]);

}



void max7219_ShowBuffer(uint8_t din_pin, uint8_t clk_pin, uint8_t cs_pin)

{

  byte dotflags[8] = {false,false,false,false,false,false,false,false};

  if (p073_dotpos >= 0) dotflags[p073_dotpos] = true;

  for(int i=0;i<8;i++)

    max7219_SetDigit(din_pin, clk_pin, cs_pin, i, p073_showbuffer[7-i], dotflags[7-i]);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
#ifdef USES_P074
# 27 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
#define PLUGIN_074 

#define PLUGIN_ID_074 74

#define PLUGIN_NAME_074 "Light/Lux - TSL2591 [TESTING]"

#define PLUGIN_VALUENAME1_074 "Lux"

#define PLUGIN_VALUENAME2_074 "Full"

#define PLUGIN_VALUENAME3_074 "Visible"

#define PLUGIN_VALUENAME4_074 "IR"





#include <Adafruit_Sensor.h>

#include "Adafruit_TSL2591.h"



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



Adafruit_TSL2591 tsl;

boolean TSL2591_initialized = false;



boolean Plugin_074(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_074;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_074);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_074));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        int optionValues[1] = { TSL2591_ADDR };

        addFormSelectorI2C(F("plugin_074_i2c_addr"), 1, optionValues, TSL2591_ADDR);
# 167 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
        String optionsMode[6] = { F("100ms"), F("200ms"), F("300ms"), F("400ms"), F("500ms"), F("600ms") };

        addFormSelector(F("Integration Time"), F("plugin_074_itime"), 6, optionsMode, NULL, CONFIG(1));
# 185 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
        String optionsGain[4] = {

          F("low gain (1x)"),

          F("medium gain (25x)"),

          F("medium gain (428x)"),

          F("max gain (9876x)") };

        addFormSelector(F("Value Mapping"), F("plugin_074_gain"), 4, optionsGain, NULL, CONFIG(2));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        CONFIG(1) = getFormItemInt(F("plugin_074_itime"));

        CONFIG(2) = getFormItemInt(F("plugin_074_gain"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

       tsl = Adafruit_TSL2591(2591);



        if (tsl.begin())

        {

          String log = F("TSL2591: Address: 0x");

          log += String(TSL2591_ADDR,HEX);
# 251 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
          switch (CONFIG(1))

          {

            default:

            case 0:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_100MS);

              break;

            }

            case 1:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_200MS);

              break;

            }

            case 2:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_300MS);

              break;

            }

            case 3:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_400MS);

              break;

            }

            case 4:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_500MS);

              break;

            }

            case 5:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_600MS);

              break;

            }

          }



          log += F(": Integration Time: ");

          log += String((tsl.getTiming() + 1) * 100, DEC);

          log += F(" ms");







      switch (CONFIG(2))

      {

       default:

       case 0:

       {

        tsl.setGain(TSL2591_GAIN_LOW);

        break;

       }

       case 1:

       {

        tsl.setGain(TSL2591_GAIN_MED);

        break;

       }

       case 2:

       {

        tsl.setGain(TSL2591_GAIN_HIGH);

        break;

       }

       case 3:

       {

        tsl.setGain(TSL2591_GAIN_MAX);

        break;

       }

      }
# 389 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P074_TSL2591.ino"
      log += (F(" Gain: "));

          tsl2591Gain_t gain = tsl.getGain();

          switch(gain)

          {

            case TSL2591_GAIN_LOW:

             log += F("1x (Low)");

              break;

            case TSL2591_GAIN_MED:

             log += F("25x (Medium)");

              break;

            case TSL2591_GAIN_HIGH:

             log += F("428x (High)");

              break;

            case TSL2591_GAIN_MAX:

             log += F("9876x (Max)");

              break;

          }



          TSL2591_initialized = true;

          addLog(LOG_LEVEL_INFO,log);



        }

        else

        {

         TSL2591_initialized = false;

         addLog(LOG_LEVEL_ERROR,F("TSL2591: No sensor found ... check your wiring?"));

        }





        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       if (TSL2591_initialized)

       {







     float lux, full, visible, ir;

     visible = tsl.getLuminosity(TSL2591_VISIBLE);

     ir = tsl.getLuminosity(TSL2591_INFRARED);

     full = tsl.getLuminosity(TSL2591_FULLSPECTRUM);

     lux = tsl.calculateLuxf(full, ir);



     UserVar[event->BaseVarIndex + 0] = lux;

     UserVar[event->BaseVarIndex + 1] = full;

     UserVar[event->BaseVarIndex + 2] = visible;

     UserVar[event->BaseVarIndex + 3] = ir;



     String log = F("TSL2591: Lux: ");

     log += String(lux);

     log += F(" Full: ");

     log += String(full);

     log += F(" Visible: ");

     log += String(visible);

     log += F(" IR: ");

     log += String(ir);

     addLog(LOG_LEVEL_INFO,log);

       }

       else {

        addLog(LOG_LEVEL_ERROR,F("TSL2591: Sensor not initialized!?"));

       }



      }



  }

  return success;

}

#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P075_Nextion.ino"
# 9 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P075_Nextion.ino"
#ifdef USES_P075



#include <ESPeasySoftwareSerial.h>



#define PLUGIN_075 

#define PLUGIN_ID_075 75

#define PLUGIN_NAME_075 "Display - Nextion [TESTING]"

#define PLUGIN_VALUENAME1_075 "code"



unsigned long Plugin_075_code = 0;

int8_t Plugin_075_RXpin = -1;

int8_t Plugin_075_TXpin = -1;



#define Nlines 12



ESPeasySoftwareSerial *nextion = NULL;



boolean Plugin_075(byte function, struct EventStruct *event, String &string) {

  boolean success = false;



  switch (function) {



    case PLUGIN_DEVICE_ADD: {

      Device[++deviceCount].Number = PLUGIN_ID_075;



      Device[deviceCount].Type = DEVICE_TYPE_DUAL;

      Device[deviceCount].VType = SENSOR_TYPE_DUAL;

      Device[deviceCount].Ports = 0;

      Device[deviceCount].PullUpOption = true;

      Device[deviceCount].InverseLogicOption = false;

      Device[deviceCount].FormulaOption = false;

      Device[deviceCount].ValueCount = 2;

      Device[deviceCount].SendDataOption = true;

      Device[deviceCount].TimerOption = true;

      Device[deviceCount].GlobalSyncOption = true;



      break;

    }



    case PLUGIN_GET_DEVICENAME: {

      string = F(PLUGIN_NAME_075);

      break;

    }



    case PLUGIN_GET_DEVICEVALUENAMES: {

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],PSTR(PLUGIN_VALUENAME1_075));

      break;

    }



    case PLUGIN_TEN_PER_SECOND: {

      char __buffer[80];



      uint16_t i;

      uint8_t c;

      String Vidx;

      String Nvalue;

      String Svalue;

      String Nswitch;



      while (nextion->available() > 0) {

        delay(10);

        c = nextion->read();



        if (0x65 == c) {

          if (nextion->available() >= 6) {

            __buffer[0] = c;

            for (i = 1; i < 7; i++) {

              __buffer[i] = nextion->read();

            }



            __buffer[i] = 0x00;



            if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6]) {

              Plugin_075_code = ((__buffer[1] >> 8) & __buffer[2] >> 8) & __buffer[3];

              UserVar[event->BaseVarIndex] = __buffer[1] * 256 + __buffer[2];

              UserVar[event->BaseVarIndex + 1] = __buffer[3];

              String log = F("Nextion : code: ");

              log += __buffer[1];

              log += ",";

              log += __buffer[2];

              log += ",";

              log += __buffer[3];



              addLog(LOG_LEVEL_INFO, log);

              sendData(event);

            }

          }

        } else {



          if (c == '|') {

            i = 1;

            __buffer[0] = c;

            c=0;

            while (nextion->available() > 0) {

              __buffer[i] = nextion->read();

              if (__buffer[i]==0x0d) break;

              i++;

            }

            __buffer[i] = 0x00;



            String tmpString = __buffer;



            int argIndex = tmpString.indexOf(F(",i"));

            int argEnd = tmpString.indexOf(',', argIndex + 1);

            if (argIndex)

            Vidx = tmpString.substring(argIndex + 2,argEnd);



            switch (__buffer[1]){



              case 'u':



                argIndex = argEnd;

                argEnd = tmpString.indexOf(',',argIndex + 1);

                if (argIndex)

                  Nvalue = tmpString.substring(argIndex + 2,argEnd);



                argIndex = argEnd;

                argEnd = tmpString.indexOf(0x0a);

                if (argIndex)

                  Svalue = tmpString.substring(argIndex + 2,argEnd);



                break;



              case 's':



                argIndex = argEnd;

                argEnd = tmpString.indexOf(0x0a);

                if (argIndex)

                  Nvalue = tmpString.substring(argIndex + 2,argEnd);

                if (Nvalue == F("On"))

                  Svalue='1';

                if (Nvalue == F("Off"))

                  Svalue='0';



                break;



            }



            UserVar[event->BaseVarIndex] = Vidx.toFloat();

            UserVar[event->BaseVarIndex+1] = Svalue.toFloat();



            String log = F("Nextion : send command: ");

            log += __buffer;

            log += UserVar[event->BaseVarIndex];

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);



            ExecuteCommand(VALUE_SOURCE_SYSTEM, __buffer);

          }

        }

      }



      success = true;

      break;

    }



    case PLUGIN_ONCE_A_SECOND: {

        success = true;

        break;

      }





    case PLUGIN_WEBFORM_SAVE: {



        String argName;



        char deviceTemplate[Nlines][64];

        for (byte varNr = 0; varNr < Nlines; varNr++)

        {

          String arg = F("Plugin_075_template");

          arg += varNr + 1;

          String tmpString = WebServer.arg(arg);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr])-1);

          deviceTemplate[varNr][63]=0;





        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



      success = true;

      break;

    }



    case PLUGIN_WEBFORM_LOAD: {

      char deviceTemplate[Nlines][64];

      LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



      for (byte varNr = 0; varNr < Nlines; varNr++)

      {

        addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_075_template")) + (varNr + 1), deviceTemplate[varNr], 64);

      }



      success = true;

      break;

    }



    case PLUGIN_INIT: {



      LoadTaskSettings(event->TaskIndex);



      if (Settings.TaskDevicePin1[event->TaskIndex] != -1)

        {

          Plugin_075_RXpin = Settings.TaskDevicePin1[event->TaskIndex];

        }



      if (Settings.TaskDevicePin2[event->TaskIndex] != -1)

        {

          Plugin_075_TXpin = Settings.TaskDevicePin2[event->TaskIndex];

        }



      if (!nextion) {

        nextion = new ESPeasySoftwareSerial(Plugin_075_RXpin , Plugin_075_TXpin);

      }



      nextion->begin(9600);



      success = true;

      break;

    }



    case PLUGIN_EXIT:

      {

          if (nextion)

          {

            delete nextion;

            nextion=NULL;

          }

          break;

      }



    case PLUGIN_READ: {

        char deviceTemplate[Nlines][64];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        String newString;



        for (byte x = 0; x < Nlines; x++) {

          String tmpString = deviceTemplate[x];

          if (tmpString.length())

          {

            int rssiIndex = tmpString.indexOf(F("rssi"));

            if(rssiIndex >= 0)

            {

              int barVal;

              newString = tmpString.substring(0, rssiIndex);

              int nbars = WiFi.RSSI();

              if (nbars < -100)

                 barVal=0;

              else if (nbars >= -100 and nbars < -90)

                 barVal=20;

              else if (nbars >= -90 and nbars < -80)

                 barVal=40;

              else if (nbars >= -80 and nbars < -70)

                 barVal=60;

              else if (nbars >= -70 and nbars < -60)

                 barVal=80;

              else if (nbars >= -60)

                 barVal=100;



              newString += String(barVal,DEC);

            }

            else

            {

              newString = parseTemplate(tmpString, 0);

            }



            sendCommand(newString.c_str());

          }

        }



        success = false;

        break;

      }





    case PLUGIN_WRITE: {

      String tmpString = string;

      int argIndex = tmpString.indexOf(',');

      if (argIndex)

        tmpString = tmpString.substring(0, argIndex);

      if (tmpString.equalsIgnoreCase(F("NEXTION"))) {

        argIndex = string.indexOf(',');

        tmpString = string.substring(argIndex + 1);



        sendCommand(tmpString.c_str());



        Serial.println(tmpString);

        success = true;

      }

      break;

    }

  }

  return success;

}





void sendCommand(const char *cmd) {

  nextion->print(cmd);

  nextion->write(0xff);

  nextion->write(0xff);

  nextion->write(0xff);

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P076_HLW8012.ino"
#ifdef USES_P076
# 31 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P076_HLW8012.ino"
#include <HLW8012.h>

HLW8012 *Plugin_076_hlw = NULL;



#define PLUGIN_076 

#define PLUGIN_ID_076 76

#define PLUGIN_076_DEBUG true

#define PLUGIN_NAME_076 "Energy (AC) - HLW8012 [TESTING]"

#define PLUGIN_VALUENAME1_076 "Voltage (V)"

#define PLUGIN_VALUENAME2_076 "Current (A)"

#define PLUGIN_VALUENAME3_076 "Active Power (W)"

#define PLUGIN_VALUENAME4_076 "Power Factor (%)"
# 63 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_P076_HLW8012.ino"
#define HLW_CURRENT_MODE HIGH

#define HLW_DELAYREADING 500





#define HLW_CURRENT_RESISTOR 0.001

#define HLW_VOLTAGE_RESISTOR_UP ( 5 * 470000 )

#define HLW_VOLTAGE_RESISTOR_DOWN ( 1000 )





byte StoredTaskIndex;



boolean Plugin_076(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_076;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_076);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_076));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("Sonoff POW: 1st(SEL)=GPIO-5, 2nd(CF1)=GPIO-13, 3rd(CF)=GPIO-14"));

        addFormSubHeader(F("Calibration Values"));

        double hlwMultipliers[3];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

        addFormTextBox(F("Current Multiplier"), F("plugin_076_currmult"), String(hlwMultipliers[0], 2), 25);

        addFormTextBox(F("Voltage Multiplier"), F("plugin_076_voltmult"), String(hlwMultipliers[1], 2), 25);

        addFormTextBox(F("Power Multiplier"), F("plugin_076_powmult"), String(hlwMultipliers[2], 2), 25);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        double hlwMultipliers[3];

        String tmpString, arg1;

          arg1 = F("plugin_076_currmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[0] = atof(tmpString.c_str());

          arg1 = F("plugin_076_voltmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[1] = atof(tmpString.c_str());

          arg1 = F("plugin_076_powmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[2] = atof(tmpString.c_str());

        SaveCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Saved Calibration from Config Page");

          addLog(LOG_LEVEL_INFO, log);

        }

        if (Plugin_076_hlw) {

          Plugin_076_hlw->setCurrentMultiplier(hlwMultipliers[0]);

          Plugin_076_hlw->setVoltageMultiplier(hlwMultipliers[1]);

          Plugin_076_hlw->setPowerMultiplier(hlwMultipliers[2]);

        }

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Multipliers Reassigned");

          addLog(LOG_LEVEL_INFO, log);

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      if (Plugin_076_hlw) {

        Plugin_076_hlw->setMode(MODE_CURRENT); delay(HLW_DELAYREADING); double hcurrent = Plugin_076_hlw->getCurrent();

        Plugin_076_hlw->setMode(MODE_VOLTAGE); delay(HLW_DELAYREADING); unsigned int hvoltage = Plugin_076_hlw->getVoltage();

        unsigned int hpower = Plugin_076_hlw->getActivePower();



        unsigned int hpowfact = (int) (100 * Plugin_076_hlw->getPowerFactor());

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Read values");

          log += F(" - V="); log += hvoltage;

          log += F(" - A="); log += hcurrent;

          log += F(" - W="); log += hpower;

          log += F(" - Pf%="); log += hpowfact;

          addLog(LOG_LEVEL_INFO, log);

        }

        UserVar[event->BaseVarIndex] = hvoltage;

        UserVar[event->BaseVarIndex + 1] = hcurrent;

        UserVar[event->BaseVarIndex + 2] = hpower;

        UserVar[event->BaseVarIndex + 3] = hpowfact;



      }

      success = true;

      break;



    case PLUGIN_INIT:

      {

        if (!Plugin_076_hlw)

        {

          Plugin_076_hlw = new HLW8012;



          Plugin_076_hlw->begin(Settings.TaskDevicePin3[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin1[event->TaskIndex], HLW_CURRENT_MODE, false, 1000000);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Init object done"));

          Plugin_076_hlw->setResistors(HLW_CURRENT_RESISTOR, HLW_VOLTAGE_RESISTOR_UP, HLW_VOLTAGE_RESISTOR_DOWN);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Init Basic Resistor Values done"));



          double hlwMultipliers[3];

          LoadCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

            if (hlwMultipliers[0] == 0) { hlwMultipliers[0] = Plugin_076_hlw->getCurrentMultiplier(); }

            if (hlwMultipliers[1] == 0) { hlwMultipliers[1] = Plugin_076_hlw->getVoltageMultiplier(); }

            if (hlwMultipliers[2] == 0) { hlwMultipliers[2] = Plugin_076_hlw->getPowerMultiplier(); }

          SaveCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Saved Calibration after INIT"));

          Plugin_076_hlw->setCurrentMultiplier(hlwMultipliers[0]);

          Plugin_076_hlw->setVoltageMultiplier(hlwMultipliers[1]);

          Plugin_076_hlw->setPowerMultiplier(hlwMultipliers[2]);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Applied Calibration after INIT"));

          StoredTaskIndex = event->TaskIndex;

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_076_hlw)

        {

          String tmpString = string;

          int argIndex = tmpString.indexOf(',');

          if (argIndex)

            tmpString = tmpString.substring(0, argIndex);



          if (tmpString.equalsIgnoreCase(F("hlwreset")))

          {

            Plugin_076_hlw->resetMultipliers();

            Plugin076_SaveMultipliers();

            if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Reset Multipliers to DEFAULT"));

            success = true;

          }



          if (tmpString.equalsIgnoreCase(F("hlwcalibrate")))

          {

            String tmpStr = string;

            unsigned int CalibVolt = 0;

            double CalibCurr = 0;

            unsigned int CalibAcPwr = 0;

            int comma1 = tmpStr.indexOf(',');

            int comma2 = tmpStr.indexOf(',', comma1+1);

            int comma3 = tmpStr.indexOf(',', comma2+1);

            if (comma1 != 0) {

              if (comma2 == 0) {

                CalibVolt = tmpStr.substring(comma1+1).toInt();

              } else if (comma3 == 0) {

                CalibVolt = tmpStr.substring(comma1+1, comma2).toInt();

                CalibCurr = atof(tmpStr.substring(comma2+1).c_str());

              } else {

                CalibVolt = tmpStr.substring(comma1+1, comma2).toInt();

                CalibCurr = atof(tmpStr.substring(comma2+1, comma3).c_str());

                CalibAcPwr = tmpStr.substring(comma3+1).toInt();

              }

            }

            if (PLUGIN_076_DEBUG) {

              String log = F("HLW8012: Calibration to values");

              log += F(" - Expected-V="); log += CalibVolt;

              log += F(" - Expected-A="); log += CalibCurr;

              log += F(" - Expected-W="); log += CalibAcPwr;

              addLog(LOG_LEVEL_INFO, log);

            }

            if (CalibVolt != 0) { Plugin_076_hlw->expectedVoltage(CalibVolt); }

            if (CalibCurr != 0) { Plugin_076_hlw->expectedCurrent(CalibCurr); }

            if (CalibAcPwr != 0) { Plugin_076_hlw->expectedActivePower(CalibAcPwr); }



            if ((CalibVolt + CalibCurr + CalibAcPwr) != 0) { Plugin076_SaveMultipliers(); }

            success = true;

          }

        }

        break;

      }



  }

  return success;

}



void Plugin076_SaveMultipliers() {

    double hlwMultipliers[3];

    hlwMultipliers[0] = Plugin_076_hlw->getCurrentMultiplier();

    hlwMultipliers[1] = Plugin_076_hlw->getVoltageMultiplier();

    hlwMultipliers[2] = Plugin_076_hlw->getPowerMultiplier();

    SaveCustomTaskSettings(StoredTaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

}



#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_Pxxx_PluginTemplate.ino"
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_Reporting.ino"




#ifdef FEATURE_REPORTING





#include <ArduinoJson.h>





#define REPORT_HOST "espeasy.datux.nl"

#define FEATURE_REPORTING 



void ReportStatus()

{

  String log;

  String host=F(REPORT_HOST);



  log=F("REP  : Reporting status to ");

  log+=host;

  addLog(LOG_LEVEL_INFO, log);





  WiFiClient client;

  if (!client.connect(host.c_str(), 80))

  {

    addLog(LOG_LEVEL_ERROR, F("REP  : connection failed"));

    return;

  }



  StaticJsonBuffer<256> jsonBuffer;

  JsonObject& root = jsonBuffer.createObject();



  root[F("chipId")] = ESP.getChipId();

  root[F("flashId")] = ESP.getFlashChipId();

  root[F("uptime")] = wdcounter /2;







  String body;

  root.printTo(body);



  String payload = F("POST /report.php HTTP/1.1\r\n");

  payload += F("Host: ");

  payload += host;

  payload += F("\r\n");

  payload += F("Connection: close\r\n");

  payload += F("Content-Length: ");

  payload += String(body.length());

  payload += F("\r\n\r\n");

  payload += body;



  Serial.println(payload);

  client.print(payload);







  addLog(LOG_LEVEL_INFO, F("REP  : report uploaded"));



}
# 187 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/_Reporting.ino"
#endif
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__CPlugin.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__CPlugin.ino"
static const char ADDCPLUGIN_ERROR[] PROGMEM = "System: Error - To much C-Plugins";
# 37 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__CPlugin.ino"
#define ADDCPLUGIN(NNN) if (x < CPLUGIN_MAX) { CPlugin_id[x] = CPLUGIN_ID_ ##NNN; CPlugin_ptr[x++] = &CPlugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDCPLUGIN_ERROR));





void CPluginInit(void)

{

  byte x;





  for (x = 0; x < CPLUGIN_MAX; x++)

  {

    CPlugin_ptr[x] = 0;

    CPlugin_id[x] = 0;

  }



  x = 0;



#ifdef CPLUGIN_001

  ADDCPLUGIN(001)

#endif



#ifdef CPLUGIN_002

  ADDCPLUGIN(002)

#endif



#ifdef CPLUGIN_003

  ADDCPLUGIN(003)

#endif



#ifdef CPLUGIN_004

  ADDCPLUGIN(004)

#endif



#ifdef CPLUGIN_005

  ADDCPLUGIN(005)

#endif



#ifdef CPLUGIN_006

  ADDCPLUGIN(006)

#endif



#ifdef CPLUGIN_007

  ADDCPLUGIN(007)

#endif



#ifdef CPLUGIN_008

  ADDCPLUGIN(008)

#endif



#ifdef CPLUGIN_009

  ADDCPLUGIN(009)

#endif



#ifdef CPLUGIN_010

  ADDCPLUGIN(010)

#endif



#ifdef CPLUGIN_011

  ADDCPLUGIN(011)

#endif



#ifdef CPLUGIN_012

  ADDCPLUGIN(012)

#endif



#ifdef CPLUGIN_013

  ADDCPLUGIN(013)

#endif



#ifdef CPLUGIN_014

  ADDCPLUGIN(014)

#endif



#ifdef CPLUGIN_015

  ADDCPLUGIN(015)

#endif



#ifdef CPLUGIN_016

  ADDCPLUGIN(016)

#endif



#ifdef CPLUGIN_017

  ADDCPLUGIN(017)

#endif



#ifdef CPLUGIN_018

  ADDCPLUGIN(018)

#endif



#ifdef CPLUGIN_019

  ADDCPLUGIN(019)

#endif



#ifdef CPLUGIN_020

  ADDCPLUGIN(020)

#endif



#ifdef CPLUGIN_021

  ADDCPLUGIN(021)

#endif



#ifdef CPLUGIN_022

  ADDCPLUGIN(022)

#endif



#ifdef CPLUGIN_023

  ADDCPLUGIN(023)

#endif



#ifdef CPLUGIN_024

  ADDCPLUGIN(024)

#endif



#ifdef CPLUGIN_025

  ADDCPLUGIN(025)

#endif



  CPluginCall(CPLUGIN_PROTOCOL_ADD, 0);

  CPluginCall(CPLUGIN_INIT, 0);

}



byte CPluginCall(byte Function, struct EventStruct *event)

{

  int x;

  struct EventStruct TempEvent;



 if (event == 0)

    event=&TempEvent;



  switch (Function)

  {



    case CPLUGIN_PROTOCOL_ADD:

      for (x = 0; x < CPLUGIN_MAX; x++)

        if (CPlugin_id[x] != 0){

          checkRAM(F("CPluginCallADD"),x);

          CPlugin_ptr[x](Function, event, dummyString);

        }

      return true;

      break;





    case CPLUGIN_INIT:

    case CPLUGIN_UDP_IN:

      for (byte x=0; x < CONTROLLER_MAX; x++)

        if (Settings.Protocol[x] != 0 && Settings.ControllerEnabled[x]) {

          event->ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

          CPlugin_ptr[event->ProtocolIndex](Function, event, dummyString);

        }

      return true;

      break;

  }



  return false;

}





bool anyControllerEnabled() {

  for (byte i=0; i < CONTROLLER_MAX; i++) {

    if (Settings.Protocol[i] != 0 && Settings.ControllerEnabled[i]) {

      return true;

    }

  }

  return false;

}





byte findFirstEnabledControllerWithId(byte cpluginid) {

  for (byte i=0; i < CONTROLLER_MAX; i++) {

    if (Settings.Protocol[i] == cpluginid && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return CONTROLLER_MAX;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__NPlugin.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__NPlugin.ino"
static const char ADDNPLUGIN_ERROR[] PROGMEM = "System: Error - To much N-Plugins";
# 39 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__NPlugin.ino"
#define ADDNPLUGIN(NNN) if (x < NPLUGIN_MAX) { NPlugin_id[x] = NPLUGIN_ID_ ##NNN; NPlugin_ptr[x++] = &NPlugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDNPLUGIN_ERROR));





void NPluginInit(void)

{

  byte x;





  for (x = 0; x < NPLUGIN_MAX; x++)

  {

    NPlugin_ptr[x] = 0;

    NPlugin_id[x] = 0;

  }



  x = 0;



#ifdef NPLUGIN_001

  ADDNPLUGIN(001)

#endif



#ifdef NPLUGIN_002

  ADDNPLUGIN(002)

#endif



#ifdef NPLUGIN_003

  ADDNPLUGIN(003)

#endif



#ifdef NPLUGIN_004

  ADDNPLUGIN(004)

#endif



#ifdef NPLUGIN_005

  ADDNPLUGIN(005)

#endif



#ifdef NPLUGIN_006

  ADDNPLUGIN(006)

#endif



#ifdef NPLUGIN_007

  ADDNPLUGIN(007)

#endif



#ifdef NPLUGIN_008

  ADDNPLUGIN(008)

#endif



#ifdef NPLUGIN_009

  ADDNPLUGIN(009)

#endif



#ifdef NPLUGIN_010

  ADDNPLUGIN(010)

#endif



#ifdef NPLUGIN_011

  ADDNPLUGIN(011)

#endif



#ifdef NPLUGIN_012

  ADDNPLUGIN(012)

#endif



#ifdef NPLUGIN_013

  ADDNPLUGIN(013)

#endif



#ifdef NPLUGIN_014

  ADDNPLUGIN(014)

#endif



#ifdef NPLUGIN_015

  ADDNPLUGIN(015)

#endif



#ifdef NPLUGIN_016

  ADDNPLUGIN(016)

#endif



#ifdef NPLUGIN_017

  ADDNPLUGIN(017)

#endif



#ifdef NPLUGIN_018

  ADDNPLUGIN(018)

#endif



#ifdef NPLUGIN_019

  ADDNPLUGIN(019)

#endif



#ifdef NPLUGIN_020

  ADDNPLUGIN(020)

#endif



#ifdef NPLUGIN_021

  ADDNPLUGIN(021)

#endif



#ifdef NPLUGIN_022

  ADDNPLUGIN(022)

#endif



#ifdef NPLUGIN_023

  ADDNPLUGIN(023)

#endif



#ifdef NPLUGIN_024

  ADDNPLUGIN(024)

#endif



#ifdef NPLUGIN_025

  ADDNPLUGIN(025)

#endif



  NPluginCall(NPLUGIN_PROTOCOL_ADD, 0);

}



byte NPluginCall(byte Function, struct EventStruct *event)

{

  int x;

  struct EventStruct TempEvent;



 if (event == 0)

    event=&TempEvent;



  switch (Function)

  {



    case NPLUGIN_PROTOCOL_ADD:

      for (x = 0; x < NPLUGIN_MAX; x++)

        if (NPlugin_id[x] != 0)

          NPlugin_ptr[x](Function, event, dummyString);

      return true;

      break;

  }



  return false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__Plugin.ino"
# 11 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__Plugin.ino"
static const char ADDPLUGIN_ERROR[] PROGMEM = "System: Error - To much Plugins";
# 37 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__Plugin.ino"
#define ADDPLUGIN(NNN) if (x < PLUGIN_MAX) { Plugin_id[x] = PLUGIN_ID_ ##NNN; Plugin_ptr[x++] = &Plugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDPLUGIN_ERROR));





void PluginInit(void)

{

  byte x;





  for (x = 0; x < PLUGIN_MAX; x++)

  {

    Plugin_ptr[x] = 0;

    Plugin_id[x] = 0;

  }



  x = 0;



#ifdef PLUGIN_001

  ADDPLUGIN(001)

#endif



#ifdef PLUGIN_002

  ADDPLUGIN(002)

#endif



#ifdef PLUGIN_003

  ADDPLUGIN(003)

#endif



#ifdef PLUGIN_004

  ADDPLUGIN(004)

#endif



#ifdef PLUGIN_005

  ADDPLUGIN(005)

#endif



#ifdef PLUGIN_006

  ADDPLUGIN(006)

#endif



#ifdef PLUGIN_007

  ADDPLUGIN(007)

#endif



#ifdef PLUGIN_008

  ADDPLUGIN(008)

#endif



#ifdef PLUGIN_009

  ADDPLUGIN(009)

#endif



#ifdef PLUGIN_010

  ADDPLUGIN(010)

#endif



#ifdef PLUGIN_011

  ADDPLUGIN(011)

#endif



#ifdef PLUGIN_012

  ADDPLUGIN(012)

#endif



#ifdef PLUGIN_013

  ADDPLUGIN(013)

#endif



#ifdef PLUGIN_014

  ADDPLUGIN(014)

#endif



#ifdef PLUGIN_015

  ADDPLUGIN(015)

#endif



#ifdef PLUGIN_016

  ADDPLUGIN(016)

#endif



#ifdef PLUGIN_017

  ADDPLUGIN(017)

#endif



#ifdef PLUGIN_018

  ADDPLUGIN(018)

#endif



#ifdef PLUGIN_019

  ADDPLUGIN(019)

#endif



#ifdef PLUGIN_020

  ADDPLUGIN(020)

#endif



#ifdef PLUGIN_021

  ADDPLUGIN(021)

#endif



#ifdef PLUGIN_022

  ADDPLUGIN(022)

#endif



#ifdef PLUGIN_023

  ADDPLUGIN(023)

#endif



#ifdef PLUGIN_024

  ADDPLUGIN(024)

#endif



#ifdef PLUGIN_025

  ADDPLUGIN(025)

#endif



#ifdef PLUGIN_026

  ADDPLUGIN(026)

#endif



#ifdef PLUGIN_027

  ADDPLUGIN(027)

#endif



#ifdef PLUGIN_028

  ADDPLUGIN(028)

#endif



#ifdef PLUGIN_029

  ADDPLUGIN(029)

#endif



#ifdef PLUGIN_030

  ADDPLUGIN(030)

#endif



#ifdef PLUGIN_031

  ADDPLUGIN(031)

#endif



#ifdef PLUGIN_032

  ADDPLUGIN(032)

#endif



#ifdef PLUGIN_033

  ADDPLUGIN(033)

#endif



#ifdef PLUGIN_034

  ADDPLUGIN(034)

#endif



#ifdef PLUGIN_035

  ADDPLUGIN(035)

#endif



#ifdef PLUGIN_036

  ADDPLUGIN(036)

#endif



#ifdef PLUGIN_037

  ADDPLUGIN(037)

#endif



#ifdef PLUGIN_038

  ADDPLUGIN(038)

#endif



#ifdef PLUGIN_039

  ADDPLUGIN(039)

#endif



#ifdef PLUGIN_040

  ADDPLUGIN(040)

#endif



#ifdef PLUGIN_041

  ADDPLUGIN(041)

#endif



#ifdef PLUGIN_042

  ADDPLUGIN(042)

#endif



#ifdef PLUGIN_043

  ADDPLUGIN(043)

#endif



#ifdef PLUGIN_044

  ADDPLUGIN(044)

#endif



#ifdef PLUGIN_045

  ADDPLUGIN(045)

#endif



#ifdef PLUGIN_046

  ADDPLUGIN(046)

#endif



#ifdef PLUGIN_047

  ADDPLUGIN(047)

#endif



#ifdef PLUGIN_048

  ADDPLUGIN(048)

#endif



#ifdef PLUGIN_049

  ADDPLUGIN(049)

#endif



#ifdef PLUGIN_050

  ADDPLUGIN(050)

#endif



#ifdef PLUGIN_051

  ADDPLUGIN(051)

#endif



#ifdef PLUGIN_052

  ADDPLUGIN(052)

#endif



#ifdef PLUGIN_053

  ADDPLUGIN(053)

#endif



#ifdef PLUGIN_054

  ADDPLUGIN(054)

#endif



#ifdef PLUGIN_055

  ADDPLUGIN(055)

#endif



#ifdef PLUGIN_056

  ADDPLUGIN(056)

#endif



#ifdef PLUGIN_057

  ADDPLUGIN(057)

#endif



#ifdef PLUGIN_058

  ADDPLUGIN(058)

#endif



#ifdef PLUGIN_059

  ADDPLUGIN(059)

#endif



#ifdef PLUGIN_060

  ADDPLUGIN(060)

#endif



#ifdef PLUGIN_061

  ADDPLUGIN(061)

#endif



#ifdef PLUGIN_062

  ADDPLUGIN(062)

#endif



#ifdef PLUGIN_063

  ADDPLUGIN(063)

#endif



#ifdef PLUGIN_064

  ADDPLUGIN(064)

#endif



#ifdef PLUGIN_065

  ADDPLUGIN(065)

#endif



#ifdef PLUGIN_066

  ADDPLUGIN(066)

#endif



#ifdef PLUGIN_067

  ADDPLUGIN(067)

#endif



#ifdef PLUGIN_068

  ADDPLUGIN(068)

#endif



#ifdef PLUGIN_069

  ADDPLUGIN(069)

#endif



#ifdef PLUGIN_070

  ADDPLUGIN(070)

#endif



#ifdef PLUGIN_071

  ADDPLUGIN(071)

#endif



#ifdef PLUGIN_072

  ADDPLUGIN(072)

#endif



#ifdef PLUGIN_073

  ADDPLUGIN(073)

#endif



#ifdef PLUGIN_074

  ADDPLUGIN(074)

#endif



#ifdef PLUGIN_075

  ADDPLUGIN(075)

#endif



#ifdef PLUGIN_076

  ADDPLUGIN(076)

#endif



#ifdef PLUGIN_077

  ADDPLUGIN(077)

#endif



#ifdef PLUGIN_078

  ADDPLUGIN(078)

#endif



#ifdef PLUGIN_079

  ADDPLUGIN(079)

#endif



#ifdef PLUGIN_080

  ADDPLUGIN(080)

#endif



#ifdef PLUGIN_081

  ADDPLUGIN(081)

#endif



#ifdef PLUGIN_082

  ADDPLUGIN(082)

#endif



#ifdef PLUGIN_083

  ADDPLUGIN(083)

#endif



#ifdef PLUGIN_084

  ADDPLUGIN(084)

#endif



#ifdef PLUGIN_085

  ADDPLUGIN(085)

#endif



#ifdef PLUGIN_086

  ADDPLUGIN(086)

#endif



#ifdef PLUGIN_087

  ADDPLUGIN(087)

#endif



#ifdef PLUGIN_088

  ADDPLUGIN(088)

#endif



#ifdef PLUGIN_089

  ADDPLUGIN(089)

#endif



#ifdef PLUGIN_090

  ADDPLUGIN(090)

#endif



#ifdef PLUGIN_091

  ADDPLUGIN(091)

#endif



#ifdef PLUGIN_092

  ADDPLUGIN(092)

#endif



#ifdef PLUGIN_093

  ADDPLUGIN(093)

#endif



#ifdef PLUGIN_094

  ADDPLUGIN(094)

#endif



#ifdef PLUGIN_095

  ADDPLUGIN(095)

#endif



#ifdef PLUGIN_096

  ADDPLUGIN(096)

#endif



#ifdef PLUGIN_097

  ADDPLUGIN(097)

#endif



#ifdef PLUGIN_098

  ADDPLUGIN(098)

#endif



#ifdef PLUGIN_099

  ADDPLUGIN(099)

#endif



#ifdef PLUGIN_100

  ADDPLUGIN(100)

#endif



#ifdef PLUGIN_101

  ADDPLUGIN(101)

#endif



#ifdef PLUGIN_102

  ADDPLUGIN(102)

#endif



#ifdef PLUGIN_103

  ADDPLUGIN(103)

#endif



#ifdef PLUGIN_104

  ADDPLUGIN(104)

#endif



#ifdef PLUGIN_105

  ADDPLUGIN(105)

#endif



#ifdef PLUGIN_106

  ADDPLUGIN(106)

#endif



#ifdef PLUGIN_107

  ADDPLUGIN(107)

#endif



#ifdef PLUGIN_108

  ADDPLUGIN(108)

#endif



#ifdef PLUGIN_109

  ADDPLUGIN(109)

#endif



#ifdef PLUGIN_110

  ADDPLUGIN(110)

#endif



#ifdef PLUGIN_111

  ADDPLUGIN(111)

#endif



#ifdef PLUGIN_112

  ADDPLUGIN(112)

#endif



#ifdef PLUGIN_113

  ADDPLUGIN(113)

#endif



#ifdef PLUGIN_114

  ADDPLUGIN(114)

#endif



#ifdef PLUGIN_115

  ADDPLUGIN(115)

#endif



#ifdef PLUGIN_116

  ADDPLUGIN(116)

#endif



#ifdef PLUGIN_117

  ADDPLUGIN(117)

#endif



#ifdef PLUGIN_118

  ADDPLUGIN(118)

#endif



#ifdef PLUGIN_119

  ADDPLUGIN(119)

#endif



#ifdef PLUGIN_120

  ADDPLUGIN(120)

#endif



#ifdef PLUGIN_121

  ADDPLUGIN(121)

#endif



#ifdef PLUGIN_122

  ADDPLUGIN(122)

#endif



#ifdef PLUGIN_123

  ADDPLUGIN(123)

#endif



#ifdef PLUGIN_124

  ADDPLUGIN(124)

#endif



#ifdef PLUGIN_125

  ADDPLUGIN(125)

#endif



#ifdef PLUGIN_126

  ADDPLUGIN(126)

#endif



#ifdef PLUGIN_127

  ADDPLUGIN(127)

#endif



#ifdef PLUGIN_128

  ADDPLUGIN(128)

#endif



#ifdef PLUGIN_129

  ADDPLUGIN(129)

#endif



#ifdef PLUGIN_130

  ADDPLUGIN(130)

#endif



#ifdef PLUGIN_131

  ADDPLUGIN(131)

#endif



#ifdef PLUGIN_132

  ADDPLUGIN(132)

#endif



#ifdef PLUGIN_133

  ADDPLUGIN(133)

#endif



#ifdef PLUGIN_134

  ADDPLUGIN(134)

#endif



#ifdef PLUGIN_135

  ADDPLUGIN(135)

#endif



#ifdef PLUGIN_136

  ADDPLUGIN(136)

#endif



#ifdef PLUGIN_137

  ADDPLUGIN(137)

#endif



#ifdef PLUGIN_138

  ADDPLUGIN(138)

#endif



#ifdef PLUGIN_139

  ADDPLUGIN(139)

#endif



#ifdef PLUGIN_140

  ADDPLUGIN(140)

#endif



#ifdef PLUGIN_141

  ADDPLUGIN(141)

#endif



#ifdef PLUGIN_142

  ADDPLUGIN(142)

#endif



#ifdef PLUGIN_143

  ADDPLUGIN(143)

#endif



#ifdef PLUGIN_144

  ADDPLUGIN(144)

#endif



#ifdef PLUGIN_145

  ADDPLUGIN(145)

#endif



#ifdef PLUGIN_146

  ADDPLUGIN(146)

#endif



#ifdef PLUGIN_147

  ADDPLUGIN(147)

#endif



#ifdef PLUGIN_148

  ADDPLUGIN(148)

#endif



#ifdef PLUGIN_149

  ADDPLUGIN(149)

#endif



#ifdef PLUGIN_150

  ADDPLUGIN(150)

#endif



#ifdef PLUGIN_151

  ADDPLUGIN(151)

#endif



#ifdef PLUGIN_152

  ADDPLUGIN(152)

#endif



#ifdef PLUGIN_153

  ADDPLUGIN(153)

#endif



#ifdef PLUGIN_154

  ADDPLUGIN(154)

#endif



#ifdef PLUGIN_155

  ADDPLUGIN(155)

#endif



#ifdef PLUGIN_156

  ADDPLUGIN(156)

#endif



#ifdef PLUGIN_157

  ADDPLUGIN(157)

#endif



#ifdef PLUGIN_158

  ADDPLUGIN(158)

#endif



#ifdef PLUGIN_159

  ADDPLUGIN(159)

#endif



#ifdef PLUGIN_160

  ADDPLUGIN(160)

#endif



#ifdef PLUGIN_161

  ADDPLUGIN(161)

#endif



#ifdef PLUGIN_162

  ADDPLUGIN(162)

#endif



#ifdef PLUGIN_163

  ADDPLUGIN(163)

#endif



#ifdef PLUGIN_164

  ADDPLUGIN(164)

#endif



#ifdef PLUGIN_165

  ADDPLUGIN(165)

#endif



#ifdef PLUGIN_166

  ADDPLUGIN(166)

#endif



#ifdef PLUGIN_167

  ADDPLUGIN(167)

#endif



#ifdef PLUGIN_168

  ADDPLUGIN(168)

#endif



#ifdef PLUGIN_169

  ADDPLUGIN(169)

#endif



#ifdef PLUGIN_170

  ADDPLUGIN(170)

#endif



#ifdef PLUGIN_171

  ADDPLUGIN(171)

#endif



#ifdef PLUGIN_172

  ADDPLUGIN(172)

#endif



#ifdef PLUGIN_173

  ADDPLUGIN(173)

#endif



#ifdef PLUGIN_174

  ADDPLUGIN(174)

#endif



#ifdef PLUGIN_175

  ADDPLUGIN(175)

#endif



#ifdef PLUGIN_176

  ADDPLUGIN(176)

#endif



#ifdef PLUGIN_177

  ADDPLUGIN(177)

#endif



#ifdef PLUGIN_178

  ADDPLUGIN(178)

#endif



#ifdef PLUGIN_179

  ADDPLUGIN(179)

#endif



#ifdef PLUGIN_180

  ADDPLUGIN(180)

#endif



#ifdef PLUGIN_181

  ADDPLUGIN(181)

#endif



#ifdef PLUGIN_182

  ADDPLUGIN(182)

#endif



#ifdef PLUGIN_183

  ADDPLUGIN(183)

#endif



#ifdef PLUGIN_184

  ADDPLUGIN(184)

#endif



#ifdef PLUGIN_185

  ADDPLUGIN(185)

#endif



#ifdef PLUGIN_186

  ADDPLUGIN(186)

#endif



#ifdef PLUGIN_187

  ADDPLUGIN(187)

#endif



#ifdef PLUGIN_188

  ADDPLUGIN(188)

#endif



#ifdef PLUGIN_189

  ADDPLUGIN(189)

#endif



#ifdef PLUGIN_190

  ADDPLUGIN(190)

#endif



#ifdef PLUGIN_191

  ADDPLUGIN(191)

#endif



#ifdef PLUGIN_192

  ADDPLUGIN(192)

#endif



#ifdef PLUGIN_193

  ADDPLUGIN(193)

#endif



#ifdef PLUGIN_194

  ADDPLUGIN(194)

#endif



#ifdef PLUGIN_195

  ADDPLUGIN(195)

#endif



#ifdef PLUGIN_196

  ADDPLUGIN(196)

#endif



#ifdef PLUGIN_197

  ADDPLUGIN(197)

#endif



#ifdef PLUGIN_198

  ADDPLUGIN(198)

#endif



#ifdef PLUGIN_199

  ADDPLUGIN(199)

#endif



#ifdef PLUGIN_200

  ADDPLUGIN(200)

#endif



#ifdef PLUGIN_201

  ADDPLUGIN(201)

#endif



#ifdef PLUGIN_202

  ADDPLUGIN(202)

#endif



#ifdef PLUGIN_203

  ADDPLUGIN(203)

#endif



#ifdef PLUGIN_204

  ADDPLUGIN(204)

#endif



#ifdef PLUGIN_205

  ADDPLUGIN(205)

#endif



#ifdef PLUGIN_206

  ADDPLUGIN(206)

#endif



#ifdef PLUGIN_207

  ADDPLUGIN(207)

#endif



#ifdef PLUGIN_208

  ADDPLUGIN(208)

#endif



#ifdef PLUGIN_209

  ADDPLUGIN(209)

#endif



#ifdef PLUGIN_210

  ADDPLUGIN(210)

#endif



#ifdef PLUGIN_211

  ADDPLUGIN(211)

#endif



#ifdef PLUGIN_212

  ADDPLUGIN(212)

#endif



#ifdef PLUGIN_213

  ADDPLUGIN(213)

#endif



#ifdef PLUGIN_214

  ADDPLUGIN(214)

#endif



#ifdef PLUGIN_215

  ADDPLUGIN(215)

#endif



#ifdef PLUGIN_216

  ADDPLUGIN(216)

#endif



#ifdef PLUGIN_217

  ADDPLUGIN(217)

#endif



#ifdef PLUGIN_218

  ADDPLUGIN(218)

#endif



#ifdef PLUGIN_219

  ADDPLUGIN(219)

#endif



#ifdef PLUGIN_220

  ADDPLUGIN(220)

#endif



#ifdef PLUGIN_221

  ADDPLUGIN(221)

#endif



#ifdef PLUGIN_222

  ADDPLUGIN(222)

#endif



#ifdef PLUGIN_223

  ADDPLUGIN(223)

#endif



#ifdef PLUGIN_224

  ADDPLUGIN(224)

#endif



#ifdef PLUGIN_225

  ADDPLUGIN(225)

#endif



#ifdef PLUGIN_226

  ADDPLUGIN(226)

#endif



#ifdef PLUGIN_227

  ADDPLUGIN(227)

#endif



#ifdef PLUGIN_228

  ADDPLUGIN(228)

#endif



#ifdef PLUGIN_229

  ADDPLUGIN(229)

#endif



#ifdef PLUGIN_230

  ADDPLUGIN(230)

#endif



#ifdef PLUGIN_231

  ADDPLUGIN(231)

#endif



#ifdef PLUGIN_232

  ADDPLUGIN(232)

#endif



#ifdef PLUGIN_233

  ADDPLUGIN(233)

#endif



#ifdef PLUGIN_234

  ADDPLUGIN(234)

#endif



#ifdef PLUGIN_235

  ADDPLUGIN(235)

#endif



#ifdef PLUGIN_236

  ADDPLUGIN(236)

#endif



#ifdef PLUGIN_237

  ADDPLUGIN(237)

#endif



#ifdef PLUGIN_238

  ADDPLUGIN(238)

#endif



#ifdef PLUGIN_239

  ADDPLUGIN(239)

#endif



#ifdef PLUGIN_240

  ADDPLUGIN(240)

#endif



#ifdef PLUGIN_241

  ADDPLUGIN(241)

#endif



#ifdef PLUGIN_242

  ADDPLUGIN(242)

#endif



#ifdef PLUGIN_243

  ADDPLUGIN(243)

#endif



#ifdef PLUGIN_244

  ADDPLUGIN(244)

#endif



#ifdef PLUGIN_245

  ADDPLUGIN(245)

#endif



#ifdef PLUGIN_246

  ADDPLUGIN(246)

#endif



#ifdef PLUGIN_247

  ADDPLUGIN(247)

#endif



#ifdef PLUGIN_248

  ADDPLUGIN(248)

#endif



#ifdef PLUGIN_249

  ADDPLUGIN(249)

#endif



#ifdef PLUGIN_250

  ADDPLUGIN(250)

#endif



#ifdef PLUGIN_251

  ADDPLUGIN(251)

#endif



#ifdef PLUGIN_252

  ADDPLUGIN(252)

#endif



#ifdef PLUGIN_253

  ADDPLUGIN(253)

#endif



#ifdef PLUGIN_254

  ADDPLUGIN(254)

#endif



#ifdef PLUGIN_255

  ADDPLUGIN(255)

#endif



  PluginCall(PLUGIN_DEVICE_ADD, 0, dummyString);

  PluginCall(PLUGIN_INIT_ALL, 0, dummyString);



}
# 2127 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__Plugin.ino"
byte PluginCall(byte Function, struct EventStruct *event, String& str)

{

  int x;

  struct EventStruct TempEvent;



  if (event == 0)

    event = &TempEvent;



  switch (Function)

  {



    case PLUGIN_DEVICE_ADD:

    case PLUGIN_UNCONDITIONAL_POLL:

      for (x = 0; x < PLUGIN_MAX; x++)

        if (Plugin_id[x] != 0)

          Plugin_ptr[x](Function, event, str);

      return true;

      break;





    case PLUGIN_WRITE:

    case PLUGIN_REQUEST:

      for (x = 0; x < PLUGIN_MAX; x++)

        if (Plugin_id[x] != 0)

          if (Plugin_ptr[x](Function, event, str))

            return true;

      break;





    case PLUGIN_SERIAL_IN:

    case PLUGIN_UDP_IN:

      {

        for (byte y = 0; y < TASKS_MAX; y++)

        {

          if (Settings.TaskDeviceEnabled[y] && Settings.TaskDeviceNumber[y] != 0)

          {

            for (x = 0; x < PLUGIN_MAX; x++)

            {

              if (Plugin_id[x] == Settings.TaskDeviceNumber[y])

              {

                byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[y]);

                TempEvent.TaskIndex = y;

                TempEvent.BaseVarIndex = y * VARS_PER_TASK;



                TempEvent.sensorType = Device[DeviceIndex].VType;

                if (Plugin_ptr[x](Function, event, str)){

                  checkRAM(F("PluginCallUDP"),x);

                  return true;

                }

              }

            }

          }

        }

        return false;

        break;

      }





    case PLUGIN_ONCE_A_SECOND:

    case PLUGIN_TEN_PER_SECOND:

    case PLUGIN_FIFTY_PER_SECOND:

    case PLUGIN_INIT_ALL:

    case PLUGIN_CLOCK_IN:

    case PLUGIN_EVENT_OUT:

      {

        if (Function == PLUGIN_INIT_ALL)

          Function = PLUGIN_INIT;

        for (byte y = 0; y < TASKS_MAX; y++)

        {

          if (Settings.TaskDeviceEnabled[y] && Settings.TaskDeviceNumber[y] != 0)

          {

            if (Settings.TaskDeviceDataFeed[y] == 0)

            {

              byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[y]);

              TempEvent.TaskIndex = y;

              TempEvent.BaseVarIndex = y * VARS_PER_TASK;



              TempEvent.sensorType = Device[DeviceIndex].VType;

              TempEvent.OriginTaskIndex = event->TaskIndex;

              for (x = 0; x < PLUGIN_MAX; x++)

              {

                if (Plugin_id[x] == Settings.TaskDeviceNumber[y])

                {

                  checkRAM(F("PluginCall_s"),x);

                  Plugin_ptr[x](Function, &TempEvent, str);

                }

              }

            }

          }

        }

        return true;

        break;

      }





    case PLUGIN_INIT:

    case PLUGIN_EXIT:

    case PLUGIN_WEBFORM_LOAD:

    case PLUGIN_WEBFORM_SAVE:

    case PLUGIN_WEBFORM_SHOW_VALUES:

    case PLUGIN_WEBFORM_SHOW_CONFIG:

    case PLUGIN_GET_DEVICEVALUENAMES:

    case PLUGIN_GET_DEVICEGPIONAMES:

    case PLUGIN_READ:

    case PLUGIN_SET_CONFIG:

    case PLUGIN_GET_CONFIG:

      for (x = 0; x < PLUGIN_MAX; x++)

      {

        if ((Plugin_id[x] != 0 ) && (Plugin_id[x] == Settings.TaskDeviceNumber[event->TaskIndex]))

        {

          event->BaseVarIndex = event->TaskIndex * VARS_PER_TASK;

          checkRAM(F("PluginCall_init"),x);

          return Plugin_ptr[x](Function, event, str);

        }

      }

      return false;

      break;



  }

  return false;

}
# 1 "D:/_domoticz/espeasy/ESPEasy_Mega_Kees/src/__ReleaseNotes.ino"